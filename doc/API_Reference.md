# Atom Probe Toolbox - API Quick Reference

_Auto-generated by doc/generateApiReference.m_

A condensed reference of all functions organized by category.

---

## Data Import/Export

| Function | Syntax | Description |
|----------|--------|-------------|
| `posLoad` | `pos = posLoad(fileName, options) % POSLOAD Canonical loader for APT datasets (.pos, .epos, .apt, .h5) % % pos = posLoad(fileName) % pos = posLoad(fileName, 'format', 'pos') % pos = posLoad(fileName, 'skipErrors', true) % % OPTIONS: % 'format' - Explicit format override: 'pos', 'epos', 'apt', 'h5' % 'skipErrors' - Return empty table on failure (default: false) % 'quiet' - Suppress informational output (default: false) % 'dataset' - Reserved for future HDF5 dataset override % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments fileName (1,:) char = '' options.format (1,:) char = '' options.skipErrors (1,1) logical = false options.quiet (1,1) logical = false options.dataset (1,:) char = '' end if isempty(fileName) [file, path] = uigetfile({ '*.pos;*.epos;*.apt;*.h5;*.hdf5', 'APT files (*.pos, *.epos, *.apt, *.h5, *.hdf5)'; '*.*', 'All files (*.*)' }, 'Select APT data file'); if isequal(file, 0) pos = table(); return; end fileName = fullfile(path, file); end if isstring(fileName) fileName = char(fileName); end if istable(fileName) pos = fileName; return; end format = normalizeFormat(options.format, fileName); try switch format case {'pos', 'epos'} pos = posToTable(fileName); case 'apt' pos = aptToTable(fileName); case {'h5', 'hdf5'} if ~isempty(options.dataset) error('posLoad:datasetUnsupported', ... 'HDF5 dataset override not supported.'); end pos = posTableFromHDF5(fileName); otherwise error('posLoad:unknownFormat', 'Unknown file format: %s', format); end catch ME if options.skipErrors warning('posLoad:loadFailed', 'Failed to load %s: %s', fileName, ME.message); pos = table(); return; end rethrow(ME); end pos = normalizePosTable(pos); if ~options.quiet if istable(pos) fprintf('Loaded %d ions from %s\n', height(pos), fileName); end end end function format = normalizeFormat(formatOpt, fileName) format = lower(strtrim(formatOpt)); format = regexprep(format, '^\.+', ''); if isempty(format) || strcmp(format, 'auto') [~, ~, ext] = fileparts(fileName); format = lower(strrep(ext, '.', '')); end end function pos = normalizePosTable(pos) if isempty(pos) || ~istable(pos) return; end if ~ismember('ionIdx', pos.Properties.VariableNames) pos = addvars(pos, (1:height(pos))', 'Before', 1, 'NewVariableNames', 'ionIdx'); end units = pos.Properties.VariableUnits; if isempty(units) || numel(units) ~= width(pos) units = repmat({''}, 1, width(pos)); end unitMap = struct(... 'ionIdx', '1', ... 'x', 'nm', ... 'y', 'nm', ... 'z', 'nm', ... 'mc', 'Da', ... 'tof', 'ns', ... 'VDC', 'V', ... 'VP', 'V', ... 'detx', 'mm', ... 'dety', 'mm', ... 'deltaP', '1', ... 'multi', '1', ... 'atomNum', '1'); names = pos.Properties.VariableNames; for i = 1:numel(names) name = names{i}; if isfield(unitMap, name) units{i} = unitMap.(name); elseif isempty(units{i}) units{i} = ''; end end pos.Properties.VariableUnits = units; end` | POSLOAD Canonical loader for APT datasets (.pos, .epos, .apt, .h5) |
| `posExport` | `posExport(posIn, fileName) % posExport writes data from a pos table to a .pos or .epos file % % tableToPos(posIn, fileName) % tableToPos(posIn) % % INPUT % posIn: is the pos table variable that contains the data from the atom probe for writing to a file % fileName: is the name of the output .pos or .epos file, it is optional. % A dialog box will pop up if no file name is given. % % OUTPUT % None % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% if nargin < 2 [file, path, ~] = uiputfile({'*.pos';'*.epos'},'Save as pos file'); fileName = [path file]; disp(['Saving to file ' file]); end [~, ~, ext] = fileparts(fileName); switch ext case '.pos' idx = 1; case '.epos' idx = 2; otherwise error('Invalid file extension. Only .pos and .epos files are supported.'); end fid = fopen(fileName, 'w'); if idx == 1 posData = posIn{:, 2:5}; posData = posData'; fwrite(fid, posData(:), 'float32', 'b'); elseif idx == 2 posData = posIn{:, 2:10}; posData = [posData zeros(height(posData),2)]; %% creates two dummy values to be placeholder for the uint32 data posData = posData'; frewind(fid); fwrite(fid, posData, '11*float32',0, 'ieee-be'); frewind(fid); pulseData = posIn{:, 11:12}; pulseData = pulseData'; fwrite(fid, pulseData, '2*uint32', 36, 'ieee-be'); end fclose(fid); end` | posExport writes data from a pos table to a .pos or .epos file |
| `posTableAddToHDF5` | `posTableAddToHDF5(fileName,pos) % posTableAddToHDF5 enables the user to add pos/epos data % to an existing HDF5 file with the appropriate groups structure. % % posTableAddToHDF5(fileName,pos) % % INPUT % fileName: full file name including path as string or char array % % pos: pos or epos table variable. Should contain the following entries: % ionIdx,x,y,z,mc,tof,VDC,VP,detx,dety,deltaP,multi,ion,atom,isotope,chargeState,ionComplexity % decomposition state is automatically determined and the % corresponding data is written either into the group: % '/atomProbeTomography/reconstruction/ion/' % (undecomposed) % '/atomProbeTomography/reconstruction/atom/' % (decomposed) % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% writing pos data ==> APT specific! numEntries = height(pos); isDecomposed = numEntries > max(pos.ionIdx); % check if pos file is decomposed if isDecomposed == 0 dataPath = '/atomProbeTomography/reconstruction/atom/'; h5writeatt(fileName,'/atomProbeTomography/reconstruction','isDecomposed', 'false'); else dataPath = '/atomProbeTomography/reconstruction/ion/'; h5writeatt(fileName,'/atomProbeTomography/reconstruction','isDecomposed', 'true'); end dataPathDetectorEvent = '/atomProbeTomography/detectorEvent/'; %% Bring decomposed/raw pos file back to initial pos file % Delete the columns ion, chargeState, atom, isotope, ionComplexity posColumnNames = pos.Properties.VariableNames; for col = 1:width(pos) if ismember(posColumnNames{col},{'ion','chargeState','atom', 'isotope', 'ionComplexity'}) pos = removevars(pos, posColumnNames{col}); end end % delete duplicate rows pos = unique(pos); numEntriesNew = height(pos); %% hdf5 write for individual variables posColumnNames = pos.Properties.VariableNames; for col = 1:width(pos) if ismember(posColumnNames{col},{'x','y','z'}) % float type coords data = table2array(pos(:,col)); h5create(fileName,[dataPath posColumnNames{col}],[numEntriesNew 1]); h5write(fileName,[dataPath posColumnNames{col}],data); h5writeatt(fileName,[dataPath posColumnNames{col}],'unit','nm','TextEncoding','UTF-8'); % elseif ismember(posColumnNames{col},{'chargeState','isotope','ionComplexity'}) % int type coords % data = table2array(pos(:,col)); % h5create(fileName,[dataPath posColumnNames{col}],[numEntries 1]); % h5write(fileName,[dataPath posColumnNames{col}],data); elseif ismember(posColumnNames{col},{'mc'}) % mass to charge state in Da data = table2array(pos(:,col)); h5create(fileName,[dataPath 'massToChargeState'],[numEntriesNew 1]); h5write(fileName,[dataPath 'massToChargeState'],data); h5writeatt(fileName,[dataPath 'massToChargeState'],'unit','Da','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'ionIdx'}) % field evaporation index in the sequence data = table2array(pos(:,col)); h5create(fileName,[dataPath 'fieldEvaporationSequenceIndex'],[numEntriesNew 1]); h5write(fileName,[dataPath 'fieldEvaporationSequenceIndex'],data); % elseif ismember(posColumnNames{col},{'ion'}) % categorical arrays converted to string arrays % data = string(table2array(pos(:,col))); % h5create(fileName,[dataPath 'ion'],[numEntries 1]); % h5write(fileName,[dataPath 'ion'],data); %dataType = 'string'; % data = [1]; % dataType = 'single'; % string arrays are not supported yet with the h5write function % epos variables elseif ismember(posColumnNames{col},{'tof'}) % export of ion flight times data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'timeOfFlight'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'timeOfFlight'],data); h5writeatt(fileName,[dataPathDetectorEvent 'timeOfFlight'],'unit','ns','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'VDC'}) % export of experiment standing voltage data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'standingVoltage'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'standingVoltage'],data); h5writeatt(fileName,[dataPathDetectorEvent 'standingVoltage'],'unit','V','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'VP'}) % export of experiment pulse voltage data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'voltagePulseAmplitude'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'voltagePulseAmplitude'],data); h5writeatt(fileName,[dataPathDetectorEvent 'voltagePulseAmplitude'],'unit','V','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'detx'}) % export of detector x hit coordinates data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'x'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'x'],data); h5writeatt(fileName,[dataPathDetectorEvent 'x'],'unit','mm','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'dety'})% export of detector y hit coordinates data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'y'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'y'],data); h5writeatt(fileName,[dataPathDetectorEvent 'y'],'unit','mm','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'deltaP'})% export of detector pulse trigger intervals data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'pulseInterval'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'pulseInterval'],data); h5writeatt(fileName,[dataPathDetectorEvent 'pulseInterval'],'unit','1','TextEncoding','UTF-8'); elseif ismember(posColumnNames{col},{'multi'})% export of detector pulse trigger intervals data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'multi'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'multi'],data); elseif ismember(posColumnNames{col},{'atomNum'})% export of detector pulse trigger intervals data = table2array(pos(:,col)); h5create(fileName,[dataPathDetectorEvent 'atomNum'],[numEntriesNew 1]); h5write(fileName,[dataPathDetectorEvent 'atomNum'],data); end if width(pos) >= 6 posType = "epos"; else posType = "pos"; end % h5writeatt(fileName,'/atomProbeTomography/reconstruction','posType', posType); end` | posTableAddToHDF5 enables the user to add pos/epos data |
| `posTableFromHDF5` | `pos = posTableFromHDF5(fileName) % posTableFromHDF5 extract the pos/epos table from an h5 file % Detailed explanation goes here %% check for pos / epos file attval = h5readatt(fileName,'/atomProbeTomography/reconstruction','isDecomposed'); if attval == "false" dataPath = '/atomProbeTomography/reconstruction/atom/'; else dataPath = '/atomProbeTomography/reconstruction/ion/'; end dataPathDetectorEvent = '/atomProbeTomography/detectorEvent/'; % check for posType attrInfo = h5info(fileName,'/atomProbeTomography/detectorEvent'); allDatasets = {attrInfo.Name}.'; tof = strcmp('timeOfFlight', allDatasets); if sum(tof) == 1 posType = "epos"; else posType = "pos"; end %% get the data out of the h5 file % stored in /atomProbeTomography/reconstruction/atom/ or /ion ionIdx = h5read(fileName, [dataPath 'fieldEvaporationSequenceIndex']); x = h5read(fileName, [dataPath 'x']); y = h5read(fileName, [dataPath 'y']); z = h5read(fileName, [dataPath 'z']); mc = h5read(fileName, [dataPath 'massToChargeState']); % end for pos file if posType == "epos" % stored in the group '/atomProbeTomography/detectorEvent/' tof = h5read(fileName, [dataPathDetectorEvent 'timeOfFlight']); VDC = h5read(fileName, [dataPathDetectorEvent 'standingVoltage']); VP = h5read(fileName, [dataPathDetectorEvent 'voltagePulseAmplitude']); detx = h5read(fileName, [dataPathDetectorEvent 'x']); dety = h5read(fileName, [dataPathDetectorEvent 'y']); deltaP = h5read(fileName, [dataPathDetectorEvent 'pulseInterval']); %check if multi is stored in the HDF5 file multiCheck = strcmp('multi', allDatasets); if sum(multiCheck) == 1 multi = h5read(fileName, [dataPathDetectorEvent 'multi']); end atomNumCheck = strcmp('atomNum', allDatasets); if sum(atomNumCheck) == 1 atomNum = h5read(fileName, [dataPathDetectorEvent 'atomNum']); end % end for epos file end %for bug fixing bug = length(x); % h5write does not support writing strings therefore just the pos file is % stored in an h5 data set % ion = (1 : bug)'; % chargeState = h5read(fileName, [dataPath 'chargeState']); % % if attval == 'true' % atom = (1 : bug)'; % isotope = h5read(fileName, [dataPath 'isotope']); % ionComplexity = h5read(fileName, [dataPath 'ionComplexity']); % end if posType == "pos" pos = table(ionIdx, x, y, z, mc); % complete initial pos file else if sum(multiCheck) + sum(atomNumCheck)== 2 pos = table(ionIdx, x, y, z, mc, tof, VDC, VP, detx, dety, deltaP, multi, atomNum); % complete initial epos file else pos = table(ionIdx, x, y, z, mc, tof, VDC, VP, detx, dety, deltaP); end end end` | posTableFromHDF5 extract the pos/epos table from an h5 file |
| `rangesExtractFromFile` | `rangeTable = rangesExtractFromFile(fileName) % rangesExtractFromFile loads all ranges and additional information % from a MATLAB figure containing a mass spectrum % % rangeTable = rangesExtractFromMassSpec(spec) % % INPUT % fileName: MATLAB figure containing an area plot that displays the mass spectrum (histogram of m/c % frequencies)either in raw counts or normalised to bin width % and total ion count % % OUTPUT % rangeTable: table with allocated ranges of the ions and additional % information(charge state, corresponding color code) % % (c) by Prof. Peter Felfer Group @FAU Erlangen-N�rnberg if ~exist('fileName','var') [file, path] = uigetfile('*.fig','select figure file with ranges'); fileName = [path '/' file]; end % loading of ranges from figure rangeFigureVisibility = 'invisible'; rngFig = openfig(fileName,rangeFigureVisibility); spec = findobj( get(rngFig,'Children'), '-depth', 2, 'DisplayName', 'mass spectrum'); rangeTable = rangesExtractFromMassSpec(spec); close(rngFig);` | rangesExtractFromFile loads all ranges and additional information |
| `hdf5FileCreateFromMetaDataList` | `hdf5FileCreateFromMetaDataList(fileName,metaData) % hdf5FileCreateFromMetaDataList creates a hdf5 file with all the metadata % that is provided in the metaData variable. This variable is a cell array % with variable name, including path in the first column, variable value in % the second, and variable unit in the third column. Experimental data and % data from the analysis can then be added to this file. % % hdf5FileCreateFromMetaDataList(fileName,metaData) % % INPUT % fileName = full file name including path as string or char array % (e.g. '\Desktop\test.h5') % % metaData = cell array of metadata in the form {path/varName, value, % unit} % % OUTPUT % a hdf5 file with the entire metadata, automatically saved in the current % folder % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% creating hdf5 file fid = H5F.create(fileName); %% creating dataset groups % extracting groups form metadata list % group list needs to be created such that a group is created before its % subgroup. This demands extracting the individual components of each path % deleting the individual variable names groupsTmp = string(metaData(:,1)); delPos = regexp(groupsTmp,"/"); delPos = cellfun(@(x) x(end),delPos); groupsTmp = extractBefore(groupsTmp,delPos+1); groupsTmp = unique(groupsTmp); % extracting the group hierarchy delPos = regexp(groupsTmp,"/"); groups = []; for gr = 1:length(groupsTmp) groupDepth = length(delPos{gr}); tmp = repmat(groupsTmp(gr),groupDepth,1); tmp = extractBefore(tmp,(delPos{gr})'); groups = [groups; tmp]; end % format group list groups = unique(groups); groups = sort(groups); groups(groups == "") = []; groups = groups + "/"; % creating individual groups for gr = 1:length(groups) groupID(gr) = H5G.create(fid,groups(gr),... 'H5P_DEFAULT','H5P_DEFAULT','H5P_DEFAULT'); H5G.close(groupID(gr)); end %% writing metadata for m = 1:size(metaData,1) % formatting of metadata for writing if ~isempty(metaData{m,2}) % get dataset path in hdf5 file from metadata text idxLastSlash = find(metaData{m,1} == '/'); idxLastSlash = max(idxLastSlash); path = metaData{m,1}(1:idxLastSlash); attribute = metaData{m,1}(idxLastSlash+1:end); if isdatetime(metaData{m,2}) % for dates data = datestr(metaData{m,2}); elseif iscategorical(metaData{m,2}) % for enums (categoricals in Matlab) data = string(metaData{m,2}); elseif islogical(metaData{m,2}) if metaData{m,2} data = 'true'; else data = 'false'; end else data = metaData{m,2}; end h5writeatt(fileName,path,attribute,data,'TextEncoding','UTF-8'); end end H5F.close(fid);` | hdf5FileCreateFromMetaDataList creates a hdf5 file with all the metadata |
| `patchToObj` | `patchToObj(patch,objName,fileName) % exports obj file into Wavefront obj % if a list (vector) of patches is parsed it will be saved in one obj file % object names can be parsed in 'objNames' % % patchToObj(); % opens a "Save *.obj file to" window if selected object is a % patch % patchToObj(patch); % opens a "Save *.obj file to" window % patchToObj(patch,[],fileName); % saves file in current folder % patchToObj(patch,objName,fileName); % saves file in current folder % % INPUTS: % patch: structure with faces (f) and vertices (v) % % objName: object names can be parsed in 'objNames' % % fileName: desired name of saved file with .obj as suffix % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg if ~exist('patch','var') object = gco; patch.vertices = get(object,'vertices'); patch.faces = get(object,'faces'); end numPatch = length(patch); if ~exist('fileName','var') % Create filepath [file path] = uiputfile('*.obj','Save *.obj file to'); fileName = [path file]; end if ~exist('objName','var') for p = 1:numPatch objName{p} = ['mesh' num2str(p)]; end elseif numPatch == 1 objNameCell{1} = objName; % Create a cell array from a string objName = objNameCell; end fid = fopen(fileName,'wt'); if( fid == -1 ) error('Cant open file.'); return; end fprintf(fid, '# openVA obj exporter, (c) Peter Felfer, The University of Sydney 2012 \n'); %% writing each patch offset = 0; for p = 1:numPatch fprintf(fid, 'v %f %f %f\n', patch(p).vertices'); patch(p).faces = patch(p).faces + offset; offset = offset + length(patch(p).vertices(:,1)); end %% writing faces for individual objects for p = 1:numPatch oName = ['o ' objName{p} '\n']; fprintf(fid, oName); if not(isempty(patch(p).faces)) fprintf(fid, 'f %u %u %u\n', patch(p).faces'); end end fclose(fid); clear fid; end` | exports obj file into Wavefront obj |
| `patchToPly` | `patchToPly(fv,vertColors,fileName,comment) % patchToPly saves a patch to a ply file (polygon file format). This format % contains information about the coloring of individual vertices and can be % read by many popular 3d programs. A file definition can be found on: http://paulbourke.net/dataformats/ply/ % % patchToPly(fv); % opens a "Save *.ply file to" window % % patchToPly(fv, vertColors); % opens a "Save *.ply file to" window % % patchToPly(fv, vertColors, 'filename.ply'); % saves filename.ply in current folder % % patchToPly(fv, vertColors, 'filename.ply', 'comment'); % saves filename.ply in current folder, including a comment % % INPUTS: % fv: structure with faces (f) and vertices (v) % % vertColors: represents color code for all vertices; % must be a n-by-3 array with n = number of vertices % color code values must be all integers between 0 and 255 % or all values <1 % % fileName: desired filename, input as character array with .ply suffix % % comment: optional, inserts comment about values used as limits into ply % input as character array % % % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg % % if ~exist('fileName','var') [file path] = uiputfile('*.ply','Save *.ply file to'); fileName = [path file]; if ~file disp('no file selected'); return end end if ~exist('vertColors','var') & ~exist('fv','var') object = gco; fv.vertices = get(object,'vertices'); fv.faces = get(object,'faces'); cmap = get(gcf,'Colormap'); lim = caxis(gca); vals = get(object,'FaceVertexCdata'); vals(vals > lim(2)) = lim(2); vals(vals < lim(1)) = lim(1); vertColors = value2VertColor(vals,cmap,lim); comment = ['value min: ' num2str(min(vals),2) ' at/nm2 '... 'max: ' num2str(max(vals)) ' at/nm2']; % inserts comment about values used as limits into ply end numVerts = length(fv.vertices(:,1)); numFaces = length(fv.faces(:,1)); % indexing is 0 based in *.ply fv.faces = fv.faces - 1; %% writing header header = ['ply \nformat ascii 1.0 \n']; header = [header 'comment openVA ply exporter, (c) Peter Felfer, The University of Sydney 2013 \n']; if exist('comment','var') header = [header comment '\n']; end % vertex properties header = [header 'element vertex ' num2str(numVerts) ' \n']; header = [header 'property float x \nproperty float y \nproperty float z \n']; if exist('vertColors','var') header = [header 'property uchar red \nproperty uchar green \nproperty uchar blue \n']; % vertex colors are from 0 - 255 if max(vertColors)<=1 vertColors = round(vertColors* 255); end if max(vertColors)>255 error('vertColors values exceed 255') end end header = [header 'element face ' num2str(numFaces) ' \n']; header = [header 'property list uchar uint vertex_indices\n']; header = [header 'end_header \n']; %% file writing if fileName fid = fopen(fileName,'wt'); if( fid == -1 ) error('Cant open file.'); return; end else return end fprintf(fid, header); if exist('vertColors','var') for v = 1:numVerts fprintf(fid, '%f %f %f ', fv.vertices(v,:)'); fprintf(fid, '%u %u %u\n', vertColors(v,:)'); end else fprintf(fid, '%f %f %f\n', fv.vertices'); end fprintf(fid, '3 %u %u %u\n', fv.faces'); fclose(fid); clear fid; end` | patchToPly saves a patch to a ply file (polygon file format). This format |
| `posToObj` | `posToObj(pos,species,fileName) % posToObj exports pos file's coordinates to an obj file, so that it can be % read into various computer graphics programs such as Blender. % % posToObj(pos) exports obj file % posToObj(pos,species) exports obj file of selected species % posToObj(pos,{}) exports obj file of species selected dl % posToObj(pos,species,fileName) export to specific file name % posToObj(pos,~,fileName) export whole variable to file name % % INPUT % pos = pos is the pos variable to be exported % % fileName = name of the file % % species = optional with the format cellstr {'Fe','Cr',...} or % string ["Fe", "Cr",..] % if species is an empty cell variable {}, an dialogue will % pop up with the possible selections % % OUTPUT % .obj file stored with the fileName % % (c) by Prof. Peter Felfer Group @FAU Erlangen-N�rnberg % get file name if it is not provided if ~exist('fileName','var') getFileName = true; elseif isempty(fileName) getFileName = true; end if getFileName [file path] = uiputfile('*.obj','writing obj files'); fileName = [path file(1:end-4)]; end % determine which coordinates are to be written out if ~exist('species','var') % all coordinates are used coords = [pos.x, pos.y, pos.z]; elseif iscell(species) % find if its ionic or atomic decomposed isAtomic = any(pos.Properties.VariableNames == "atom"); if ~isempty(species) % select only the relevant atoms / ions if isAtomic isIn = ismember(pos.atom, species); else isIn = ismember(pos.ion, species); end else % select atoms / ions in a dialogue if isAtomic types = categories(pos.atom); [idx,tf] = listdlg('ListString',types); if tf isIn = ismember(pos.atom, types(idx)); else return end else % for ions types = categories(pos.ion); [idx,tf] = listdlg('ListString',types); if tf isIn = ismember(pos.ion, types(idx)); else return end end end % create coordinate variable coords = [pos.x(isIn), pos.y(isIn), pos.z(isIn)]; else error('species format not recognized') end % write obj as text file fid = fopen([fileName '.obj'],'wt'); if( fid == -1 ) error('Cant open file.'); return; end fprintf(fid, '# written by APT toolbox obj exporter, (c) Peter Felfer \n'); fprintf(fid, 'v %f %f %f\n',coords(:,1:3)'); fclose(fid); clear fid;` | posToObj exports pos file's coordinates to an obj file, so that it can be |

---

## Ion and Range Management

| Function | Syntax | Description |
|----------|--------|-------------|
| `ionAdd` | `h = ionAdd(spec,ion,chargeState,isotopeTable,colorScheme,sumMargin,minAbundance,maxHeight,maxSeparation) % ionAdd creates a stem plot in the mass spectrum (spec) for the parsed ion % and its corresponding charge state. The stem line will be according to % charge state. % % h = ionAdd(spec,ion,chargeState,isotopeTable,colorScheme,sumMargin,minAbundance,maxHeight,maxSeparation) % h = ionAdd(spec,ion,chargeState,isotopeTable,colorScheme,sumMargin,minAbundance) % % INPUT % spec: mass spectrum to whom the stem plot is added to % % ion: chemical symbol of the ion that will be added, % string scalar or string array % % chargeState: charge state of the ion; if ion is a string array, % chargeState can be a scalar, a vector of charge states for % all ions (e.g.[1 2 3]) or a vector with the same number % of entries as the ion list % % isotopeTable: the parsed isotope table is the basis of the relative % abundances % % colorScheme: each ion has a different color % % sumMargin: specifies a margin within which two peaks will be summed up % % minAbundance: is the minimal abundance, value between 0 and 1 % % maxHeight: is the height of the most abundant isotope (counts or % relative frequency) % nothing parsed: to the YScale of the plotaxis % numeric value: you can type in the desired height of the % highest peak % 'selection': uses a graphical input to select a peak, to % which the nearest isotopic combination will be scaled % 'most abundant': adjusts the height of the most abundant % peak to the closest peak in the mass spectrum % TODO:'least squares': adjusts the heights of the peaks to least % squares match the peaks in the mass spectrum. Peaks that % are close to other assigned peaks are not used. % % maxSeparation:is used when peak detection is used. The maximum of the % mass spectrum within this range will be used for scaling % % OUTPUT % h: optional, is a 1x1 stem plot handle to the object % % THE FOLLOWING WILL BE STORED IN THE USER DATA SECTION OF THE PLOT: % plotType = 'ion' % % isotopicCombinations: list of peaks vs. nucleides in the ion and % charge state % % ToDo: % - implement specifying certain isotope (isotope combo) for peak height % - implement isnumeric('minHeight') % - implement 'least squares' % - implement checking for duplicate ions % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% check ion name if isstring(ion) ion = char(ion); end ax = spec.Parent; %% get individual isotopic combinations [ionType, abundance, weight] = ionsCreateIsotopeList(ion, isotopeTable); %% cluster peaks together if sumMargin > 0 % if peaks are summed up, the dominant peak will be taken if (sumMargin > 0) & (length(abundance) > 1) [ionType, abundance, weight] = ionsMergePeaks(ionType, abundance, weight, sumMargin); end %% eliminate peaks that are below minAbundance weight(abundance <= minAbundance) = []; ionType(abundance <= minAbundance) = []; abundance(abundance <= minAbundance) = []; %% create charge state ("CS") plotWeight = []; plotAbundance = []; ionTypeCS = []; ionCS = []; for cs = 1:length(chargeState) plotWeight = [plotWeight, weight/chargeState(cs)]; plotAbundance = [plotAbundance, abundance]; ionTypeCS = [ionTypeCS ionType]; ionCS = [ionCS repmat(chargeState(cs), 1, length(abundance))]; end %% normalise height if ~exist('maxHeight','var') % default is the height of current axis scaling maxPeak = max(abundance); maxDisp = ax.YLim(2); plotAbundance = plotAbundance * maxDisp / maxPeak; elseif isnumeric(maxHeight) % if single value, most abundant isotope will be that height % if two element vector, the peak closest to maxHeight(1) will be % scaled to maxHeight(2) if isscalar(maxHeight) maxDisp = maxHeight; %XXXXX missing implementation else maxDisp = maxHeight(2); dist = maxHeight(1) - plotWeight; peakIdx = find(abs(dist) == min(abs(dist))); peakIdx = peakIdx(1); plotAbundance = plotAbundance * maxDisp / plotAbundance(peakIdx); end else if strcmp(maxHeight,'selection') % selection of individual peak rect = getrect(ax); mcbegin = rect(1); mcend = rect(1) + rect(3); xdata = spec.XData; ydata = spec.YData; maxDisp = max(ydata(xdata > mcbegin & xdata < mcend)); peak = max(plotAbundance((plotWeight > mcbegin) & (plotWeight < mcend))); if isempty(peak) error('peak not within selected range'); end plotAbundance = plotAbundance * maxDisp / peak; elseif strcmp(maxHeight,'most abundant') % adjusts the height of the most abundant peak to the closest peak % in the mass spectrum mostAbundant = find(plotAbundance == max(plotAbundance)); % if multiple charge states are present, there are as many max height peaks as charge states mostAbundant = mostAbundant(1); peak = plotAbundance(mostAbundant); mi = plotWeight(mostAbundant) - maxSeparation; mx = plotWeight(mostAbundant) + maxSeparation; inRange = spec.XData > mi & spec.XData < mx; maxDisp = max(spec.YData(inRange)); plotAbundance = plotAbundance * maxDisp / peak; elseif strcmp(maxHeight,'least squares') % adjusts the heights of the peaks to least squares that match the % peaks in the mass spectrum. Peaks that are close to other % assigned peaks are not used. error('least squares fitting not implemented yet'); end end %% plot h = ionStemPlot(ax, plotWeight, plotAbundance, ionTypeCS, chargeState, colorScheme);` | ionAdd creates a stem plot in the mass spectrum (spec) for the parsed ion |
| `ionConvertName` | `varargout = ionConvertName(varargin) % ionConvertName converts an ion name to a table variable and reverse. % As input parameters, also categorical or an array of elements is % possible. % % Create ionTable % ionTable = ionConvertName(ionName); % [ionTable chargeState] = ionConvertName(ionName); % % Create ionName % table: % ionName = ionConvertName(ionTable,chargeState,format); % ionName = ionConvertName(ionTable,chargeState); % ionName = ionConvertName(ionTable,NaN,format); % ionName = ionConvertName(ionTable); % categorical: % ionName = ionConvertName(ionCategorical,chargeState,format); % ionName = ionConvertName(ionCategorical,chargeState); % ionName = ionConvertName(ionCategorical) % array: % ionName = ionConvertName(ionArray,chargeState,format,isotopeTable); % % INPUT/OUTPUT % % ionName: Name of the ion % (isotope element count) x N chargestate '56Fe2 16O3 ++' % (element count) x N chargestate 'Fe2 O3 ++' % (element count) x N 'Fe2 O3' % individual nucleides will be sorted by atomic number descending % e.g. 'O H2' % % ionTable: table that contains the element and the isotope % % ionCategorical: ion table that is stored as an categorical array % % ionArray: matrix of element and isotope number % e.g. Fe2O3 [26,56;26,56;8,16;8,16;8,16;] % vector of elements % e.g. Fe2O3 [26;26;8;8;8] % % chargeState: is the charge state of the ion % % NaN: if no charge state is parsed % % format: can be 'plain' or 'LaTeX' % % isotopeTable: table with all isotopes % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% conversion from array to table/categorical. The new table/categorical is saved as an input % argument and is converted to table if isotopes are given, categorical if % only elements are given as a vector % check for input as an array if ismatrix(varargin{1}) & ~istable(varargin{1}) & ~iscategorical(varargin{1}) & ~ischar(varargin{1}) & ~isstring(varargin{1}) % check for isotopeTable as an input variable if nargin == 4 & istable(varargin{4}) ionArray = varargin{1}; isotopeTable = varargin{4}; % create element List for j = 1:length(ionArray) isotopeName = isotopeTable.element(isotopeTable.atomicNumber==ionArray(j,1)); element(j,1) = isotopeName(1,1); end if isvector(ionArray) varargin{1} = categorical(element); else % create isotope list isotope = ionArray(:,2); % create ionTable with element and isotope ionTable = table(element, isotope); varargin{1} = ionTable; end else error('no isotopeTable is parsed'); end end %% conversion from table to name if istable(varargin{1}) ionTable = varargin{1}; if nargin == 3 format = varargin{3}; else format = 'plain'; end % add atomic number to table numAtom = height(ionTable); for at = 1:numAtom atomicNumber(at,:) = symbolConvertAtomicNumber(char(ionTable.element(at))); end % for unknown ions, NaNs are swapped for 0, to enable sorting atomicNumber(isnan(atomicNumber)) = 0; ionTable = addvars(ionTable, atomicNumber,'NewVariableNames','atomicNumber'); % sort by atomic number descending ionTable = sortrows(ionTable,{'atomicNumber','isotope'},{'descend','descend'},'MissingPlacement','first'); % get multiplicity of atom occurrences in ion and write out names ionName = []; isotopeGroup = sortedFindgroups(ionTable); for i = 1:max(isotopeGroup) idx = find(isotopeGroup == i,1); % add isotope to the name if ~isnan(ionTable.isotope(idx)) if strcmp(format,'LaTeX') ionName = [ionName '^{' num2str(ionTable.isotope(idx)) '}']; else ionName = [ionName num2str(ionTable.isotope(idx))]; end end % add chemical element to the name ionName = [ionName char(ionTable.element(idx))]; % add chemical element to the name if sum(isotopeGroup == i) > 1 if strcmp(format,'LaTeX') ionName = [ionName '_{' num2str(sum(isotopeGroup == i)) '}']; else ionName = [ionName num2str(sum(isotopeGroup == i))]; end end ionName = [ionName ' ']; end % add + (or -) for charge states to the name if nargin > 1 chargeState = varargin{2}; if ~isnan(chargeState) % NaN for undefined charge state, e.g. in noise if chargeState < 0 sym = '-'; else sym = '+'; end if strcmp(format,'LaTeX') ionName = [ionName ' ^{' repmat(sym,1,abs(chargeState)) '}']; else ionName = [ionName repmat(sym,1,abs(chargeState))]; end end end varargout{1} = strtrim(ionName); end %% conversion from categorical to name if iscategorical(varargin{1}) element = varargin{1}; if nargin == 3 format = varargin{3}; else format = 'plain'; end numAtom = length(element); for at = 1:numAtom atomicNumber(at,:) = symbolConvertAtomicNumber(char(element(at))); end ionTable = table(element,atomicNumber); % sort by atomic number descending ionTable = sortrows(ionTable,{'atomicNumber'},{'descend'}); % get multiplicity of atom occurrences in ion and write out names ionName = []; isotopeGroup = sortedFindgroups(ionTable); for i = 1:max(isotopeGroup) idx = find(isotopeGroup == i,1); ionName = [ionName ' ' char(ionTable.element(idx))]; if sum(isotopeGroup == i) > 1 if strcmp(format,'LaTeX') ionName = [ionName '_{' num2str(sum(isotopeGroup == i)) '}']; else ionName = [ionName num2str(sum(isotopeGroup == i))]; end end end % add + (or -) for charge states if nargin > 1 chargeState = varargin{2}; if ~isnan(chargeState) % NaN for undefined charge state, e.g. in noise if chargeState < 0 sym = '-'; else sym = '+'; end if strcmp(format,'LaTeX') ionName = [ionName ' ^{' repmat(sym,1,abs(chargeState)) '}']; else ionName = [ionName repmat(sym,1,abs(chargeState))]; end end end varargout{1} = strtrim(ionName); end %% conversion from name to table if isstring(varargin{1}) % string to char array if needed varargin{1} = char(varargin{1}); end if ischar(varargin{1}) ionName = varargin{1}; %check for chargestate if any(ionName == '+') chargeState = sum(ionName == '+'); ionName(ionName == '+') = []; elseif any(ionName == '-') chargeState = uminus(sum(ionName == '-')); ionName(ionName == '-') = []; else chargeState = NaN; end ionName = strtrim(ionName); % remove any whitespace % split individual elemental / isotopic parts parts = strsplit(ionName); numElements = length(parts); isotope = []; elementOut = categorical(); isotopeOut = []; for el = 1:numElements % find the chemical element element = parts{el}(isstrprop(parts{el},'alpha')); isDigit = isstrprop(parts{el},'digit'); % find the isotope if isDigit(1) == true isotope = str2num(parts{el}(1:find(~isDigit,1)-1)); else isotope = NaN; end % find the count if isDigit(end) == true count = str2num(parts{el}(find(~isDigit,1,'last')+1:end)); else count = 1; end for cnt = 1:count elementOut(end+1) = element; isotopeOut(end+1) = isotope; end end element = elementOut'; isotope = isotopeOut'; varargout{1} = table(element,isotope); varargout{2} = chargeState; end function group = sortedFindgroups(ionTable) % replace all NaN isotopes with 0, for findgroups command % this is hacky, but we get NaN outputs if any entry in the table is NaN if any(string(ionTable.Properties.VariableNames) == "isotope") ionTable.isotope(isnan(ionTable.isotope)) = 0; end isotopeGroup = findgroups(ionTable); % need to re-sort REALLY HOPE THAT WONT MAKE PROBLEMS groupIdx = unique(isotopeGroup,'stable'); [~, idx] = sort(groupIdx); for i = 1:length(isotopeGroup) isotopeGroup(i) = idx(isotopeGroup(i)); end % replace 0s with NaNs again if any(string(ionTable.Properties.VariableNames) == "isotope") ionTable.isotope(ionTable.isotope == 0) = NaN; end group = isotopeGroup;` | ionConvertName converts an ion name to a table variable and reverse. |
| `ionsCreateIsotopeList` | `[ions, abundance, weight] = ionsCreateIsotopeList(ion,isotopeTable) % takes an ion type, e.g. 'Cr2 O3' and gives all isotopic combinations, % based on the supplied isotopeTable % % [ions, abundance, weight] = ionsCreateIsotopeList(ion, isotopeTable); % % INPUT % ion: categorical or string array of the ion (e.g., 'Cr2 O3') % % isotopeTable: table with all the isotopes of various elements % % OUTPUT % ions: cell array with Mx2 tables, denoting the element and % isotope; M is the number of isotopic combinations % % abundance: array of abundance values corresponding to entries in 'ions' % % weight: array of weight values corresponding to entries in 'ions' % % NOTE: In case of a complex ion, there must be a space between the % different elements. % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% interpret ion name into a table [element count] ionTable = ionConvertName(ion); % calculate individual element count atoms = removecats(ionTable.element); % also removes potential unused atom categories element = categorical(categories(atoms)); count = countcats(atoms); atomList = table(element,count); %% create individual isotopic abundances numElements = height(atomList); % create seperate isotope combination lists for each element for el = 1:numElements isos = isotopeTable(isotopeTable.element == atomList.element(el),:); %isoList{el} = isos.isotope(nreplacek(height(isos),atomList.count(el))); isoList{el} = isos.isotope(unique(sort(permn(1:height(isos),atomList.count(el)),2),'rows')); idx{el} = 1:length(isoList{el}(:,1)); %used later for indexing into ion List end % get combinations of elemental ion combinations grid = cell(1,numel(idx)); [grid{:}] = ndgrid(idx{:}); combos = reshape(cat(numElements+1,grid{:}), [], numElements); numCombos = length(combos(:,1)); % calculate relative abundances and weights for c = 1:numCombos weight(c) = 0; abundance(c) = 1; ions{c} = table("",[0],'VariableNames',{'element','isotope'}); nucCount = 0; for el = 1:numElements isos = isoList{el}(combos(c,el),:); for iso = 1:length(isos) nucCount = nucCount + 1; weight(c) = weight(c) + isotopeTable.weight((isotopeTable.element == atomList.element(el)) & (isotopeTable.isotope == isos(iso))); abundance(c) = abundance(c) * isotopeTable.abundance((isotopeTable.element == atomList.element(el)) & (isotopeTable.isotope == isos(iso))) /100; warning('off'); ions{c}.element(nucCount) = char(atomList.element(el)); ions{c}.isotope(nucCount) = isos(iso); end end ions{c}.element = categorical(ions{c}.element); ions{c}.isotope = ions{c}.isotope; end abundance = abundance/sum(abundance); % normalize. Abundances wont sum up exactly to 1` | takes an ion type, e.g. 'Cr2 O3' and gives all isotopic combinations, |
| `ionsCreateComplex` | `ionList = ionsCreateComplex(elements,complexity,isotopeTable,chargeStates) % ionsCreateComplex creates a list of all complex ions that can be formed % by the given elements, based on the isotopeTable. % % ionList = ionsCreateComplex(elements,complexity,isotopeTable); % ionList = ionsCreateComplex(elements,complexity,isotopeTable,chargeStates); % % INPUT % elements: list of elements that form the complexes, either as cell, % string {'Fe','Cr','O',...} or as vector of atomic numbers % HINT: the cell can be extracted from the decomposed % pos file as elements = categories(pos.atom) % HINT: to use many elements, standard matlab linear vector % generation can be used, e.g. elements = 1:100 % % complexity: vector of ion complexities to be included, e.g. [1 2 3] % % isotopeTable: isotopeTable used for the analysis % % chargeStates: vector of charge states to be included, e.g. [1 2 3], % chargeStates are optional, default is +1 - +3 % % OUTPUT % ionList: table with fields: % ion, ionIsotopic: categorical with ion names % mc: mass-to-charge value of the individual isotopic % combinations in amu % % WARNING: the number of permutations of ions grows with the Gamma % function. Beware when creating very large complexities. For the entire % periodic system, anything above a complexity of 2 will lead to a very % long list. % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% input validation if isstring(elements) elements = cellstr(elements); end %% looking for input chargeStates if ~exist('chargeStates','var') chargeStates = [1, 2, 3]; end %% create individual permutations of atomic combinations % if input is cell string, convert to atomic numbers if iscell(elements) for el = 1:numel(elements) elementsTmp(el) = symbolConvertAtomicNumber(elements{el}); end elements = elementsTmp; end % for each complexity ionPerm = {}; for comp = 1:length(complexity) % create permutations of given elements with repetitions elementalPermutations = permn(elements,complexity(comp)); elementalPermutations = unique(sort(elementalPermutations,2),'rows'); numPerms = size(elementalPermutations,1); for elPerm = 1:numPerms ionPerm{end+1,1} = ionConvertName((elementalPermutations(elPerm,:)'),NaN,'plain',isotopeTable); end end %% create isotopic combinations from isotope table ion = {}; ionIsotopicNoCS = {}; weight = []; % include waitbar since this could take a while wb = waitbar(0,'building isotopic combinations'); for i = 1:length(ionPerm) ionIsotopicTmp = {}; % create isotope combination list with weights for each elemental permutation [isoCombos, ~, weightTmp] = ionsCreateIsotopeList(ionPerm{i}, isotopeTable); for it = 1:length(isoCombos) ionIsotopicTmp{it,1} = ionConvertName(isoCombos{it}); end ion = [ion; repmat(ionPerm(i),[length(isoCombos) 1])]; ionIsotopicNoCS = [ionIsotopicNoCS; ionIsotopicTmp]; weight = [weight; weightTmp']; % update waitbar waitbar(i/length(ionPerm),wb); end delete(wb); %% add charge states in the mix ion = repmat(ion,[length(chargeStates) 1]); mc = []; ionIsotopic = {}; for cs = 1:length(chargeStates) mc = [mc; weight/chargeStates(cs)]; ionIsotopic = [ionIsotopic; cellfun(@(x) [x ' ' repmat('+', [1, chargeStates(cs)])], ionIsotopicNoCS,'UniformOutput',false)]; end ion = categorical(ion); ionIsotopic = categorical(ionIsotopic); ionList = table(ion,ionIsotopic,mc); %ionList = unique(ionList); ionList = sortrows(ionList,3);` | ionsCreateComplex creates a list of all complex ions that can be formed |
| `ionsMergePeaks` | `[ionType, abundance, weight] = ionsMergePeaks(ionType, abundance, weight, mergeMargin) % ionsMergePeaks takes a list of isotopic combinations and merges peaks % that are closer than mergeMargin % % [ionType, abundance, weight] = ionsMergePeaks(ionType, abundance, weight, mergeMargin) % % INPUT % ionType: type of the ion for that peaks should % be merged % % abundance: relativ abundance of the peak in % the mass spectrum % % weight: weight of the ion % % mergeMargin: peaks within this range will be merged % % OUTPUT % [ionType, abundance, weight]: cell array of merged peaks % sorted by molecular weight % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg [weight, sortIdx] = sort(weight); abundance = abundance(sortIdx); ionType = ionType(sortIdx); % determine which peaks are closer than a margin and group them in % clusters diffs = weight(2:end) - weight(1:end-1); isClose = diffs < mergeMargin; peakCluster = 1; peakClusterIdx(1) = peakCluster; numCombos = numel(ionType); % number of isotopic combinations for i = 1:numCombos-1 if isClose(i) peakClusterIdx(i+1) = peakCluster; else peakCluster = peakCluster + 1; peakClusterIdx(i+1) = peakCluster; end end % merge individual peaks for i = 1:peakCluster weightTmp(i) = mean(weight(peakClusterIdx == i)); abundanceTmp(i) = sum(abundance(peakClusterIdx == i)); % ion type will be taken from the most abundant ion in the cluster ionTypePkClust = ionType(peakClusterIdx == i); ionTypeTmp{i} = ionTypePkClust{abundance(peakClusterIdx == i) == max(abundance(peakClusterIdx == i))}; end weight = weightTmp; abundance = abundanceTmp; ionType = ionTypeTmp;` | ionsMergePeaks takes a list of isotopic combinations and merges peaks |
| `rangeAdd` | `[h, txt] = rangeAdd(spec,colorScheme,manualName,rangeLimits) % adds a range to a mass spectrum using graphical input % output is the handle to the area plot and the corresponding text % % if multiple isotopic combinations of the same element are within the range, % automatically the one with the higher abundance (peak height) will be taken % % if various ions of different element species are within one range, % the user can choose the desired ion out of a list in a pop-up window; % default selection is set to the ion with higher natural abundance % % if the new range covers an existing range, the command gets aborted % % if the new range is entirely covered by an existing range, the command % gets aborted % % if the new range partially overlaps with an existing range, the new range % gets clipped to the adjacent range % % if no inserted ion is located within the range, the user can manually enter a % range name (must be an ion, which is included in colorScheme) in a pop-up window % % possible use without specific outputs: rangeAdd(spec,colorScheme) % generates only area (ans) but no handle or text in the workspace % % [h, txt] = rangeAdd(spec,colorScheme) % [h, txt] = rangeAdd(spec,colorScheme,manualName) % % % INPUT % spec: area plot that displays the mass spectrum (histogram of % m/c frequencies)either in raw counts or normalised to bin % width and total ion count % % colorScheme: table with elements assigned to color code % % manualName: name of range if no ion is defined, following keywords % are possible: 'background'. This defines a background range % If it is a valid ion name including charge state and % isotope information, e.g. 16O 1H2 +, the range table is % filled out analogous to a regular range % % rangeLimits: limits of the range without graphical input. Used for % building up a range figure e.g. from an HDF5 % % OUTPUT % h: handle to the area plot of the range % txt: corresponding text % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% set current axes ax = spec.Parent; axes(ax); %% user input if not(exist('rangeLimits','var')) % mbIdx defines mouse button (1: left, 2: middle, 3: right) [xLim, yLim, mbIdx] = ginput(2); if sum(mbIdx==3)>0 h = []; txt = ['']; return else lim = [xLim,yLim]; end isManualLimts = false; else lim = rangeLimits'; isManualLimits = true; end % check how many points were marked isValid = false; if ~isempty(lim) lim = lim(:,1); lim = sort(lim); isValid = length(lim) == 2; end if isValid %% check for manual range name input isManual = exist('manualName','var'); % is a manual name present? isBackground = false; isValidIonName = false; if isManual isBackground = strcmp(manualName,'background'); % is it a background range? end %% check for overlap with already existing peak range plots = spec.Parent.Children; idx = 1; for pl = 1:length(plots) % find all the ones that are ranges try type = plots(pl).UserData.plotType; catch type = "unknown"; end % case #1: new range is entirely part of existing range if type == "range" if lim(1) > plots(pl).XData(1) & lim(2) < plots(pl).XData(end) error 'Total overlap with existing range.' return end end % case #2: existing range is entirely covered by new range if type == "range" if lim(1) < plots(pl).XData(1) & lim(2) > plots(pl).XData(end) error 'Input range completely covers already existing range.' end end % case #3: new range partially overlaps with existing range % new range gets clipped to the adjacent range % case #3a: partial overlap on right side of existing range if type == "range" if lim(1) < plots(pl).XData(end) & lim(2) > plots(pl).XData(end) lim(1) = plots(pl).XData(end) + (spec.XData(end) - spec.XData(end-1)); f = msgbox({'Due to a partial overlap,'; 'the new range was clipped to the adjacent range.'},'Notification'); end end % case #3b: partial overlap on left side if type == "range" if lim(1) < plots(pl).XData(1) & lim(2) > plots(pl).XData(1) lim(2) = plots(pl).XData(1) - (spec.XData(end) - spec.XData(end-1)); f = msgbox({'Due to a partial overlap,'; 'the new range was clipped to the adjacent range.'},'Notification'); end end end %% if lim(1) == lim (2) error('manual input failed, try again') end isIn = (spec.XData > lim(1)) & (spec.XData < lim(2)); h = area(spec.XData(isIn),spec.YData(isIn)); h.FaceColor = [1 1 1]; h.UserData.plotType = "range"; % is overwritten for background ranges % take care of manual ranges if isManual & ~isBackground [ion, chargeState] = ionConvertName(manualName); if not(isnan(chargeState)) & not(any(isnan(ion.isotope))) isValidIonName = true; end if ~isnan(chargeState) h.UserData.ion = ion; h.UserData.chargeState = chargeState; h.DisplayName = ionConvertName(h.UserData.ion,h.UserData.chargeState); color = colorScheme.color(colorScheme.ion == ionConvertName(h.UserData.ion.element),:); else h.UserData.ion = manualName; h.UserData.chargeState = NaN; h.DisplayName = manualName; color = colorScheme.color(colorScheme.ion == manualName,:); end if isempty(color) name = h.DisplayName; delete(h); error(['color for atom/ion ' name ' undefined']); end h.FaceColor = color; elseif isManual & isBackground h.UserData.plotType = "background"; h.DisplayName = "background"; h.FaceColor = colorScheme.color(colorScheme.ion == 'background',:); end %% search for ions in mass spectrum plot plots = ax.Children; isIon = false(length(plots),1); for pl = 1:length(plots) try isIon(pl) = strcmp(plots(pl).UserData.plotType,"ion"); end end ionPlots = plots(isIon); % find ions in range (if there are any) potentialIon = {}; potentialIonChargeState = []; potentialIonPeakHeight = []; if ~isempty(ionPlots) for pl = 1:length(ionPlots) isIn = (ionPlots(pl).XData > lim(1)) & (ionPlots(pl).XData < lim(2)); if any(isIn) % if multiple isotopic combinations of the ion are within the range, % the most abundant one is automatically chosen isIn = (ionPlots(pl).YData == max(ionPlots(pl).YData(isIn))) & isIn; potentialIon{end+1} = ionPlots(pl).UserData.ion{isIn}; if isscalar(ionPlots(pl).UserData.chargeState) potentialIonChargeState(end+1) = ionPlots(pl).UserData.chargeState; else potentialIonChargeState(end+1) = ionPlots(pl).UserData.chargeState(isIn); end potentialIonPeakHeight(end+1) = ionPlots(pl).YData(isIn); end end end %% select which ion it is if necessary % manual input if isempty(potentialIon) & ~isManual error('no ion defined in this range: provide name manually'); % clear choice elseif length(potentialIon) == 1 & ~isManual h.UserData.ion = potentialIon{1}; h.UserData.chargeState = potentialIonChargeState(1); h.DisplayName = ionConvertName(h.UserData.ion,h.UserData.chargeState); % h.FaceColor = colorScheme.color(colorScheme.ion == ionConvertName(h.UserData.ion.element),:); elseif ~isManual % selection numPotIon = length(potentialIon); for i = 1:numPotIon names{i} = [ionConvertName(potentialIon{i}, potentialIonChargeState(i)) ' ' num2str(potentialIonPeakHeight(i))]; end % select the ion, defaulting to most abundant [~, maxIdx] = max(potentialIonPeakHeight); [idx, isSelection] = listdlg('ListString',names,'PromptString','Select ion species','SelectionMode','single',... 'InitialValue',maxIdx); if ~isSelection delete(h); return end h.UserData.ion = potentialIon{idx}; h.UserData.chargeState = potentialIonChargeState(idx); h.DisplayName = ionConvertName(h.UserData.ion,h.UserData.chargeState); % h.FaceColor = colorScheme.color(colorScheme.ion == ionConvertName(h.UserData.ion.element),:); end % check for manual name % check for color in the color Scheme if isManual == 1 && sum(colorScheme.ion == manualName) == 1 h.FaceColor = colorScheme.color(colorScheme.ion == manualName,:); elseif sum(colorScheme.ion == ionConvertName(h.UserData.ion.element)) == 1 h.FaceColor = colorScheme.color(colorScheme.ion == ionConvertName(h.UserData.ion.element),:); else delete(h); error('This ion does not exist in the colorScheme. Please add the ion with a color to the colorScheme with colorSchemeIonAdd()'); end % define for all hit multiplicities h.UserData.hitMultiplicities = [0 Inf]; % add text to denote range if it's not a background range if ~isBackground if isManual && not(isValidIonName) txt = text(h.XData(1),max(h.YData)*1.4,manualName,'clipping','on'); txt.DisplayName = manualName; else txt = text(h.XData(1),max(h.YData)*1.4,ionConvertName(h.UserData.ion,h.UserData.chargeState,'LaTeX'),'clipping','on'); txt.DisplayName = ionConvertName(h.UserData.ion,h.UserData.chargeState,'plain'); end txt.UserData.plotType = "text"; % delete function for ion text and corresponding range h.DeleteFcn = @(~,~) delete(txt); end else error('invalid number of range limits'); end` | adds a range to a mass spectrum using graphical input |
| `rangeAddAll` | `rangeAddAll(spec,colorScheme,rangeMargin,useMin) % rangeAddAll is a convenient function that guides the user through the % ranging process for all defined ionic peaks that currently have no range % associated with them. The focus in the figure is automatically given to % the current peak and the region around it. % When the peak is in focus, the user needs to range it manually. If the % peak should be skipped, enter must be pressed. % % rangeAddAll(spec,colorScheme,rangeMargin) % % INPUT % spec: figure, that holds the mass spectrum with the peaks which % will be ranged % % colorScheme: color scheme with colors for the ranges % % rangeMargin: is the number of Da before and after the peak that are % displayed % useMin: the user can choose between 'true' and 'false' % false: the user will be taken through every peak % true: the user can draw a line over the mass spectrum and % only the peaks higher than the line are taken into account % for the ranging % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg xPlotLimits = spec.Parent.XLim; % current plot limits yPlotLimits = spec.Parent.YLim; % current plot limits %% check for color of the ion in the color Scheme ionTable = ionsExtractFromMassSpec(spec); % find categories in ionTable and colorScheme testIonTable = categories(ionTable.ionName); testColorScheme = categories(colorScheme.ion); % check if ion is in colorScheme compIonColor = zeros(size(testIonTable)); for k = 1:height(testColorScheme) compIonColor(strncmp(testIonTable, testColorScheme(k,1), 15)) = k; end % find zeros = no ion defined posZeros = find(~compIonColor); if posZeros > 0 error('Ions in the mass spectra have no defined color in the colorScheme. Please add the ion to the colorScheme with colorSchemeIonAdd()'); end %% find individual peaks and determine if a range is defined % find individual peak locations ionLocations = []; peakHeights = []; plotHandles = spec.Parent.Children; for pl = 1:length(plotHandles) if plotHandles(pl).UserData.plotType == "ion" ionLocations = [ionLocations plotHandles(pl).XData]; peakHeights = [peakHeights plotHandles(pl).YData]; end end ionLocations = ionLocations'; peakHeights = peakHeights'; % compare with ranges rangeTable = rangesExtractFromMassSpec(spec); %check which ions currently have no range associated with them if ~isempty(rangeTable) % for any populated range table notInRange = not(any((ionLocations > rangeTable.mcbegin') & (ionLocations < rangeTable.mcend'),2)); else %if no ranges exist in the mass spectrum notInRange = true(size(ionLocations)); end %check which peaks are higher than the defined background isAboveLimit = true(size(ionLocations)); if useMin == true limPoints = ginput(); % prompts the user to input points below which peaks are not considered limPoints = sortrows(limPoints); % extrapolate to limits of mass spectrum as constant limPoints = [spec.XData(1) limPoints(1,2) ; limPoints; spec.XData(end) limPoints(end,2)]; limPlotHandle = line(spec.Parent,limPoints(:,1),limPoints(:,2),'Color',[1 0 0],'LineWidth',2); % line plot of the background selection % get limit y values for ion peak locations limVals = interp1(limPoints(:,1),limPoints(:,2),ionLocations,'linear'); % compare to peak heights isAboveLimit = peakHeights > limVals; end unrangedIonLocations = ionLocations(notInRange & isAboveLimit); unrangedPeakHeights = peakHeights(notInRange & isAboveLimit); %% cycle through ions that have no range associated for ion = 1:length(unrangedIonLocations) % put focus on peak spec.Parent.XLim = [unrangedIonLocations(ion) - rangeMargin, unrangedIonLocations(ion) + rangeMargin]; if unrangedPeakHeights(ion)*1.5 > yPlotLimits(1) % in case the upper plot y limit is lower than the lower y plot limit spec.Parent.YLim = [yPlotLimits(1), unrangedPeakHeights(ion)*1.5]; else spec.Parent.YLim = [unrangedPeakHeights(ion)/10, unrangedPeakHeights(ion)*1.5]; end % put a marker there % range the peak rngH = rangeAdd(spec,colorScheme); %if isempty(rngH) % return %end end spec.Parent.XLim = xPlotLimits; %revert to old plot limits. spec.Parent.YLim = yPlotLimits; %revert to old plot limits. delete(limPlotHandle); %deletes background line` | rangeAddAll is a convenient function that guides the user through the |
| `rangesFromPos` | `[rangeTable colorScheme] = rangesFromPos(pos, colorScheme, isotopeTable) %rangesFromPos extracts and creates the corresponding rangeTable to an allocated pos variable % % rangeTable = rangesFromPos(pos, colorScheme) % % INPUT % pos pos Variable with allocated ranges % colorScheme colorScheme of the toolbox/project % % OUTPUT % rangeTable Table variable with all the ranges in the pos variable % % % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% check if pos is in Raw format pos = posUnDecompose(pos); %% extract range file information % find unique ion and chargeState information rangeTable = table(); rangeTable = addvars(rangeTable, pos.ion, pos.chargeState, 'NewVariableNames',{'ion', 'chargeState'}); rangeTable = rmmissing(unique(rangeTable)); % Create rangeTable with zeros rangeTable.Properties.VariableNames(1) = "rangeName"; vec = zeros(height(rangeTable),1); test = cell(height(rangeTable),1); % rangeTable = addvars(rangeTable, zeros, zeros, zeros, zeros, [zeros zeros zeros], 'NewVariableNames',{'mcbegin', 'mcend', 'volume', 'ion', 'color'}); rangeTable = addvars(rangeTable, vec, vec, vec, test, [vec vec vec], 'NewVariableNames',{'mcbegin', 'mcend', 'volume', 'ion', 'color'}); %% find Data for i = 1 :height(ionsUnique) % find mcbegin and mcend posIon = pos(pos.ion == rangeTable.rangeName(i), :); posIon = posIon(posIon.chargeState == rangeTable.chargeState(i), :); rangeTable.mcbegin(i) = min(posIon.mc); rangeTable.mcend(i) = max(posIon.mc); % find ion %rangeTable.ion(i) = ionConvertName(string(rangeTable.rangeName(i))); outputTable = ionConvertName(string(rangeTable.rangeName(i))); % find isotope % find ion in ionList and extract chargeState and ion % potentialIons = ionList(ionList.ion == rangeName(isotopes),:); % if isempty(potentialIons) % ionName = rangeName(isotopes); % disp(['ion ' ionName ' is not on ion list. pls expand list to include ion']); % isIn = 0; % else % isIn = potentialIons.mc > mcbegin(isotopes) & potentialIons.mc < mcend(isotopes); % if any(isIn) % potentialIons = potentialIons(isIn,:); % ion{isotopes,:} = ionConvertName(string(potentialIons.ionIsotopic(1))); % chargeStateSingleIon = nnz(char(potentialIons.ionIsotopic(1)) == '+'); % chargeState(isotopes) = chargeStateSingleIon; % elseif isIn == 0 % mcbeginNew = (mcbegin(isotopes)-0.2); % mcendNew = (mcend(isotopes)+0.2); % % else % isIn = 0; % end % end rangeTable.ion{i} = outputTable; % find color if colorScheme.ion == rangeTable.rangeName(i) rangeTable.color(i,:) = colorScheme.color(colorScheme.ion == rangeTable.rangeName(i), :); else colorScheme = colorSchemeIonAdd(colorScheme,string(rangeTable.rangeName(i))); rangeTable.color(i,:) = colorScheme.color(colorScheme.ion == rangeTable.rangeName(i), :); end end end` | rangesFromPos extracts and creates the corresponding rangeTable to an allocated pos variable |
| `symbolConvertAtomicNumber` | `symnum = symbolConvertAtomicNumber(input) % symbolConvertAtomicNumber transforms the atomic number of an element to % his symbol and vice versa % % symnum = symbolConvertAtomicNumber(input) % % INPUT % input: number or char that is either the atomic number or the symbol of % the element (e.g., 26 or 'Fe' for iron) % % OUTPUT % symnum: symbol of the element or atomic number of the element % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg if exist('input','var') %% conversion from element symbol to atomic number if ischar(input)==1 switch input case 'H' symnum = 1; case 'D' symnum = 2; case 'Li' symnum = 3; case 'Be' symnum = 4; case 'B' symnum = 5; case 'C' symnum = 6; case 'N' symnum = 7; case 'O' symnum = 8; case 'F' symnum = 9; case 'Ne' symnum = 10; case 'Na' symnum = 11; case 'Mg' symnum = 12; case 'Al' symnum = 13; case 'Si' symnum = 14; case 'P' symnum = 15; case 'S' symnum = 16; case 'Cl' symnum = 17; case 'Ar' symnum = 18; case 'K' symnum = 19; case 'Ca' symnum = 20; case 'Sc' symnum = 21; case 'Ti' symnum = 22; case 'V' symnum = 23; case 'Cr' symnum = 24; case 'Mn' symnum = 25; case 'Fe' symnum = 26; case 'Co' symnum = 27; case 'Ni' symnum = 28; case 'Cu' symnum = 29; case 'Zn' symnum = 30; case 'Ga' symnum = 31; case 'Ge' symnum = 32; case 'As' symnum = 33; case 'Se' symnum = 34; case 'Br' symnum = 35; case 'Kr' symnum = 36; case 'Rb' symnum = 37; case 'Sr' symnum = 38; case 'Y' symnum = 39; case 'Zr' symnum = 40; case 'Nb' symnum = 41; case 'Mo' symnum = 42; case 'Tc' symnum = 43; case 'Ru' symnum = 44; case 'Rh' symnum = 45; case 'Pd' symnum = 46; case 'Ag' symnum = 47; case 'Cd' symnum = 48; case 'In' symnum = 49; case 'Sn' symnum = 50; case 'Sb' symnum = 51; case 'Te' symnum = 52; case 'I' symnum = 53; case 'Xe' symnum = 54; case 'Cs' symnum = 55; case 'Ba' symnum = 56; case 'La' symnum = 57; case 'Ce' symnum = 58; case 'Pr' symnum = 59; case 'Nd' symnum = 60; case 'Pm' symnum = 61; case 'Sm' symnum = 62; case 'Eu' symnum = 63; case 'Gd' symnum = 64; case 'Tb' symnum = 65; case 'Dy' symnum = 66; case 'Ho' symnum = 67; case 'Er' symnum = 68; case 'Tm' symnum = 69; case 'Yb' symnum = 70; case 'Lu' symnum = 71; case 'Hf' symnum = 72; case 'Ta' symnum = 73; case 'W' symnum = 74; case 'Re' symnum = 75; case 'Os' symnum = 76; case 'Ir' symnum = 77; case 'Pt' symnum = 78; case 'Au' symnum = 79; case 'Hg' symnum = 80; case 'Tl' symnum = 81; case 'Pb' symnum = 82; case 'Bi' symnum = 83; case 'Po' symnum = 84; case 'At' symnum = 85; case 'Rn' symnum = 86; case 'Fr' symnum = 87; case 'Ra' symnum = 88; case 'Ac' symnum = 89; case 'Th' symnum = 90; case 'Pa' symnum = 91; case 'U' symnum = 92; case 'Np' symnum = 93; case 'Pu' symnum = 94; case 'Am' symnum = 95; case 'Cm' symnum = 96; case 'Bk' symnum = 97; case 'Cf' symnum = 98; case 'Es' symnum = 99; case 'Fm' symnum = 100; case 'Md' symnum = 101; case 'No' symnum = 102; case 'Lr' symnum = 103; case 'Rf' symnum = 104; case 'Db' symnum = 105; case 'Sg' symnum = 106; case 'Bh' symnum = 107; case 'Hs' symnum = 108; case 'Mt' symnum = 109; case 'Ds' symnum = 110; case 'Rg' symnum = 111; case 'Uub' symnum = 112; case 'Uzt' symnum = 113; case 'Uuq' symnum = 114; case 'Uup' symnum = 115; case 'Uuh' symnum = 116; case 'Uus' symnum = 117; case 'Uuo' symnum = 118; otherwise symnum = NaN; end %% conversion from atomic number to element symbol elseif ischar(input)==0 switch input case 1 symnum = 'H'; case 2 symnum = 'D'; case 3 symnum = 'Li'; case 4 symnum = 'Be'; case 5 symnum = 'B'; case 6 symnum = 'C'; case 7 symnum = 'N'; case 8 symnum = 'O'; case 9 symnum = 'F'; case 10 symnum = 'Ne'; case 11 symnum = 'Na'; case 12 symnum = 'Mg'; case 13 symnum = 'Al'; case 14 symnum = 'Si'; case 15 symnum = 'P'; case 16 symnum = 'S'; case 17 symnum = 'Cl'; case 18 symnum = 'Ar'; case 19 symnum = 'K'; case 20 symnum = 'Ca'; case 21 symnum = 'Sc'; case 22 symnum = 'Ti'; case 23 symnum = 'V'; case 24 symnum = 'Cr'; case 25 symnum = 'Mn'; case 26 symnum = 'Fe'; case 27 symnum = 'Co'; case 28 symnum = 'Ni'; case 29 symnum = 'Cu'; case 30 symnum = 'Zn'; case 31 symnum = 'Ga'; case 32 symnum = 'Ge'; case 33 symnum = 'As'; case 34 symnum = 'Se'; case 35 symnum = 'Br'; case 36 symnum = 'Kr'; case 37 symnum = 'Rb'; case 38 symnum = 'Sr'; case 39 symnum = 'Y'; case 40 symnum = 'Zr'; case 41 symnum = 'Nb'; case 42 symnum = 'Mo'; case 43 symnum = 'Tc'; case 44 symnum = 'Ru'; case 45 symnum = 'Rh'; case 46 symnum = 'Pd'; case 47 symnum = 'Ag'; case 48 symnum = 'Cd'; case 49 symnum = 'In'; case 50 symnum = 'Sn'; case 51 symnum = 'Sb'; case 52 symnum = 'Te'; case 53 symnum = 'I'; case 54 symnum = 'Xe'; case 55 symnum = 'Cs'; case 56 symnum = 'Ba'; case 57 symnum = 'La'; case 58 symnum = 'Ce'; case 59 symnum = 'Pr'; case 60 symnum = 'Nd'; case 61 symnum = 'Pm'; case 62 symnum = 'Sm'; case 63 symnum = 'Eu'; case 64 symnum = 'Gd'; case 65 symnum = 'Tb'; case 66 symnum = 'Dy'; case 67 symnum = 'Ho'; case 68 symnum = 'Er'; case 69 symnum = 'Tm'; case 70 symnum = 'Yb'; case 71 symnum = 'Lu'; case 72 symnum = 'Hf'; case 73 symnum = 'Ta'; case 74 symnum = 'W'; case 75 symnum = 'Re'; case 76 symnum = 'Os'; case 77 symnum = 'Ir'; case 78 symnum = 'Pt'; case 79 symnum = 'Au'; case 80 symnum = 'Hg'; case 81 symnum = 'Tl'; case 82 symnum = 'Pb'; case 83 symnum = 'Bi'; case 84 symnum = 'Po'; case 85 symnum = 'At'; case 86 symnum = 'Rn'; case 87 symnum = 'Fr'; case 88 symnum = 'Ra'; case 89 symnum = 'Ac'; case 90 symnum = 'Th'; case 91 symnum = 'Pa'; case 92 symnum = 'U'; case 93 symnum = 'Np'; case 94 symnum = 'Pu'; case 95 symnum = 'Am'; case 96 symnum = 'Cm'; case 97 symnum = 'Bk'; case 98 symnum = 'Cf'; case 99 symnum = 'Es'; case 100 symnum = 'Fm'; case 101 symnum = 'Md'; case 102 symnum = 'No'; case 103 symnum = 'Lr'; case 104 symnum = 'Rf'; case 105 symnum = 'Db'; case 106 symnum = 'Sg'; case 107 symnum = 'Bh'; case 108 symnum = 'Hs'; case 109 symnum = 'Mt'; case 110 symnum = 'Ds'; case 111 symnum = 'Rg'; case 112 symnum = 'Uub'; case 113 symnum = 'Uut'; case 114 symnum = 'Uuq'; case 115 symnum = 'Uup'; case 116 symnum = 'Uuh'; case 117 symnum = 'Uus'; case 118 symnum = 'Uuo'; otherwise symnum = 'undefined'; end end else disp(' no input!'); end` | symbolConvertAtomicNumber transforms the atomic number of an element to |

---

## Mass Spectrum Analysis

| Function | Syntax | Description |
|----------|--------|-------------|
| `massSpecPlot` | `handle = massSpecPlot(mc, bin, mode) % massSpecPlot plots the data from pos to get a mass spectrum as a figure % % handle = plotMassSpec(mc, bin, mode) % handle = plotMassSpec(mc, bin) % % INPUT % mc: is the mass-to-charge(mc)-ratio [Da] of the events in the % APT measurement stored in pos, table % % bin: is the width of the steps in which the plot is performed % % mode: specifies the way the counts are applied % 'count' records the number of counts % 'normalised' records the number of counts if the bin was one Da % wide over the overall number of counts % default mode is 'count' % % OUTPUT % handle: handle to the plot that contains counts or % (counts/Dalton)/totalCounts over Dalton. Used in further % analysis to find new ions % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% % count is default mode if ~exist('mode','var') mode = 'count'; end if istable(mc) mc = mc.mc; end if length(mc(1,:)) > 1 mc = mc(:,4); end f = figure('Name','mass spectrum'); ax = axes(f); mcmax = max(mc); x = linspace(0,mcmax,round(mcmax/bin)); if strcmp(mode,'count') y = hist(mc,x); elseif strcmp(mode,'normalised') % calculate as counts/(Da * totalCts) so that mass spectra with different % count numbers are comparable y = hist(mc,x) / bin / length(mc); %med = median(y); else y = hist(mc,x); end % plot all mass spectrum handle = area(x,y,'FaceColor',[.9 .9 .9]); handle.UserData.plotType = "massSpectrum"; hold on; ax = get(handle,'Parent'); set(gca,'YScale','Log'); set(gcf, 'Name', 'Mass spectrum'); set(gcf, 'Color', [1 1 1]); set(get(gca,'XLabel'),'String','mass-to-charge-state ratio [Da]'); if strcmp(mode,'count') ylabel('frequency [counts]'); elseif strcmp(mode,'normalised') ylabel('frequency [cts / Da / totCts]'); end %% annotation with range stats t = annotation('textbox'); % determining the background at 4 Da upperLim = 4.5; % Da lowerLim = 3.5; % Da BG4 = sum(y((x >= lowerLim) & (x <= upperLim)))/(upperLim-lowerLim); BG4 = BG4/length(mc) * 1E6; t.String = {['bin width: ' num2str(bin) ' Da'], ['num atoms: ' num2str(length(mc)) ], ['backG @ 4 Da: ' num2str(BG4,3) ' ppm/Da']}; t.BackgroundColor = 'w'; t.FaceAlpha = 0.8; t.Position = [.15 .8 .27 .1]; t.FitBoxToText = 'on'; pan(handle, 'xon') zoom xon handle.DisplayName = 'mass spectrum';` | massSpecPlot plots the data from pos to get a mass spectrum as a figure |
| `massSpecAnalysis` | `results = massSpecAnalysis(mass, options) % MASSSPECANALYSIS Comprehensive mass spectrum analysis for APT data % % results = massSpecAnalysis(mass) % results = massSpecAnalysis(mass, 'binWidth', 0.01) % % Performs automated analysis of mass-to-charge spectrum including peak % detection, background fitting, mass resolution estimation, and optional % peak deconvolution. % % INPUT: % mass - Vector of mass-to-charge values (Da) % % OPTIONS: % 'binWidth' - Histogram bin width in Da (default: 0.01) % 'massRange' - [min, max] mass range to analyze (default: auto) % 'peakThreshold' - Minimum peak height as fraction of max (default: 0.001) % 'bgMethod' - Background method: 'moving', 'polynomial', 'exponential' % (default: 'moving') % 'bgWindow' - Window size for moving background (default: 100 bins) % 'bgPolyOrder' - Polynomial order for background (default: 3) % 'fitPeaks' - Fit Gaussian to peaks (default: true) % 'deconvolve' - Attempt peak deconvolution (default: false) % 'showPlot' - Display results plot (default: true) % % OUTPUT: % results - Structure containing: % .spectrum - Spectrum data % .edges - Bin edges % .centers - Bin centers (mass-to-charge) % .counts - Raw counts per bin % .countRate - Counts per Da % .background - Background estimation % .values - Background at each bin % .method - Method used % .corrected - Background-corrected counts % .peaks - Detected peaks table with columns: % .position - Peak center (Da) % .height - Peak height (counts) % .area - Integrated peak area % .fwhm - Full width at half maximum % .resolution - Mass resolution (M/dM) % .snr - Signal-to-noise ratio % .statistics - Overall spectrum statistics % .totalCounts - Total counts % .meanResolution - Mean mass resolution % .noiseLevel - Estimated noise level % % EXAMPLES: % % Basic analysis % results = massSpecAnalysis(posTable.mc); % % % With specific settings % results = massSpecAnalysis(mc, 'binWidth', 0.005, 'bgMethod', 'polynomial'); % % % Analyze specific range % results = massSpecAnalysis(mc, 'massRange', [20, 80], 'showPlot', true); % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments mass (:,1) double options.binWidth (1,1) double {mustBePositive} = 0.01 options.massRange (1,2) double = [] options.peakThreshold (1,1) double {mustBePositive} = 0.001 options.bgMethod (1,:) char {mustBeMember(options.bgMethod, {'moving', 'polynomial', 'exponential'})} = 'moving' options.bgWindow (1,1) double {mustBePositive} = 100 options.bgPolyOrder (1,1) double {mustBePositive, mustBeInteger} = 3 options.fitPeaks (1,1) logical = true options.deconvolve (1,1) logical = false options.showPlot (1,1) logical = true end % Determine mass range if isempty(options.massRange) options.massRange = [0, ceil(max(mass) * 1.05)]; end mass = mass(mass >= options.massRange(1) & mass <= options.massRange(2)); %% Create Histogram fprintf('Creating mass spectrum histogram...\n'); edges = options.massRange(1):options.binWidth:options.massRange(2); counts = histcounts(mass, edges); centers = edges(1:end-1) + options.binWidth/2; results = struct(); results.spectrum.edges = edges; results.spectrum.centers = centers; results.spectrum.counts = counts; results.spectrum.countRate = counts / options.binWidth; results.spectrum.binWidth = options.binWidth; %% Background Estimation fprintf('Estimating background...\n'); [background, bgMethod] = estimateBackground(counts, options); results.background.values = background; results.background.method = bgMethod; results.background.corrected = max(counts - background, 0); %% Peak Detection fprintf('Detecting peaks...\n'); peakTable = detectPeaks(centers, counts, background, options); results.peaks = peakTable; %% Peak Fitting if options.fitPeaks && ~isempty(peakTable) fprintf('Fitting peaks...\n'); results.peaks = fitPeaksGaussian(centers, counts, background, peakTable, options); end %% Statistics fprintf('Computing statistics...\n'); results.statistics.totalCounts = sum(counts); results.statistics.massRange = options.massRange; results.statistics.nPeaks = height(results.peaks); if ~isempty(results.peaks) results.statistics.meanResolution = mean(results.peaks.resolution(~isnan(results.peaks.resolution))); results.statistics.medianSNR = median(results.peaks.snr); else results.statistics.meanResolution = NaN; results.statistics.medianSNR = NaN; end % Noise level estimation noiseRegion = counts(counts < median(counts)); results.statistics.noiseLevel = std(noiseRegion); results.statistics.backgroundFraction = sum(background) / sum(counts); %% Optional Deconvolution if options.deconvolve && ~isempty(results.peaks) fprintf('Attempting peak deconvolution...\n'); results.deconvolution = deconvolvePeaks(centers, counts, background, results.peaks); end %% Plot Results if options.showPlot plotMassSpectrum(results, options); end fprintf('Mass spectrum analysis complete: %d peaks detected\n', results.statistics.nPeaks); end %% Background Estimation function [background, method] = estimateBackground(counts, options) nBins = length(counts); switch lower(options.bgMethod) case 'moving' % Moving minimum (robust against peaks) windowSize = min(options.bgWindow, nBins); background = movmin(counts, windowSize); % Smooth the result background = movmean(background, windowSize/2); method = sprintf('moving_min (window=%d)', windowSize); case 'polynomial' % Polynomial fit to local minima x = 1:nBins; % Find local minima for fitting localMin = islocalmin(counts, 'MinProminence', std(counts)*0.5); % Add edges localMin(1:min(10, nBins)) = true; localMin(max(1, nBins-10):nBins) = true; if sum(localMin) > options.bgPolyOrder + 1 p = polyfit(x(localMin), counts(localMin), options.bgPolyOrder); background = polyval(p, x); background = max(background, 0); else % Fall back to moving minimum background = movmin(counts, options.bgWindow); end method = sprintf('polynomial (order=%d)', options.bgPolyOrder); case 'exponential' % Exponential decay fit (common for APT thermal tails) x = (1:nBins)'; % Fit to local minima localMin = islocalmin(counts, 'MinProminence', std(counts)*0.5); localMin(1:min(10, nBins)) = true; if sum(localMin) > 3 try % Fit: bg = a * exp(-b*x) + c minCounts = counts(localMin); minX = x(localMin); fo = fitoptions('Method', 'NonlinearLeastSquares', ... 'Lower', [0, 0, 0], ... 'Upper', [max(counts), 1, max(counts)], ... 'StartPoint', [max(counts)/10, 0.01, min(counts)]); ft = fittype('a*exp(-b*x) + c', 'options', fo); fitResult = fit(minX, minCounts, ft); background = fitResult.a * exp(-fitResult.b * x) + fitResult.c; background = background'; catch % Fall back to moving minimum background = movmin(counts, options.bgWindow); end else background = movmin(counts, options.bgWindow); end method = 'exponential'; end % Ensure background doesn't exceed counts background = min(background, counts); end %% Peak Detection function peakTable = detectPeaks(centers, counts, background, options) % Detect peaks above threshold corrected = counts - background; threshold = options.peakThreshold * max(corrected); % Find local maxima [pks, locs, widths, proms] = findpeaks(corrected, ... 'MinPeakHeight', threshold, ... 'MinPeakDistance', 3, ... % Minimum 3 bins apart 'MinPeakProminence', threshold * 0.5); nPeaks = length(pks); if nPeaks == 0 peakTable = table(); return; end % Calculate properties for each peak position = centers(locs)'; height = pks'; prominence = proms'; % FWHM and area estimates fwhm = zeros(nPeaks, 1); area = zeros(nPeaks, 1); resolution = zeros(nPeaks, 1); snr = zeros(nPeaks, 1); binWidth = centers(2) - centers(1); for i = 1:nPeaks % Find FWHM halfMax = pks(i) / 2; peakIdx = locs(i); % Search left leftIdx = peakIdx; while leftIdx > 1 && corrected(leftIdx) > halfMax leftIdx = leftIdx - 1; end % Search right rightIdx = peakIdx; while rightIdx < length(corrected) && corrected(rightIdx) > halfMax rightIdx = rightIdx + 1; end % Interpolate for better precision if leftIdx > 1 && rightIdx < length(corrected) leftPos = interp1(corrected(leftIdx:leftIdx+1), centers(leftIdx:leftIdx+1), halfMax); rightPos = interp1(corrected(rightIdx-1:rightIdx), centers(rightIdx-1:rightIdx), halfMax); fwhm(i) = rightPos - leftPos; else fwhm(i) = widths(i) * binWidth; end % Resolution if fwhm(i) > 0 resolution(i) = position(i) / fwhm(i); else resolution(i) = NaN; end % Area (simple sum) peakRange = max(1, leftIdx):min(length(corrected), rightIdx); area(i) = sum(corrected(peakRange)) * binWidth; % SNR localBg = mean(background(peakRange)); localNoise = sqrt(localBg); % Poisson noise if localNoise > 0 snr(i) = pks(i) / localNoise; else snr(i) = pks(i); end end peakTable = table(position, height, area, fwhm, resolution, snr, prominence); peakTable = sortrows(peakTable, 'position'); end %% Gaussian Peak Fitting function peakTable = fitPeaksGaussian(centers, counts, background, peakTable, options) % Fit Gaussian to each peak for better parameters if isempty(peakTable) return; end nPeaks = height(peakTable); corrected = counts - background; binWidth = centers(2) - centers(1); % Add columns for fit parameters peakTable.fitCenter = peakTable.position; peakTable.fitHeight = peakTable.height; peakTable.fitSigma = peakTable.fwhm / 2.355; % FWHM = 2.355 * sigma peakTable.fitR2 = zeros(nPeaks, 1); for i = 1:nPeaks pos = peakTable.position(i); sigma_est = peakTable.fwhm(i) / 2.355; % Define fitting region (3 sigma each side) fitRange = abs(centers - pos) < 5 * sigma_est; if sum(fitRange) < 5 continue; end xFit = centers(fitRange); yFit = corrected(fitRange); try % Gaussian: a * exp(-((x-b)^2)/(2*c^2)) fo = fitoptions('Method', 'NonlinearLeastSquares', ... 'Lower', [0, pos-sigma_est, 0], ... 'Upper', [max(yFit)*2, pos+sigma_est, sigma_est*5], ... 'StartPoint', [peakTable.height(i), pos, sigma_est]); ft = fittype('a*exp(-((x-b)^2)/(2*c^2))', 'options', fo); [fitResult, gof] = fit(xFit', yFit', ft); peakTable.fitCenter(i) = fitResult.b; peakTable.fitHeight(i) = fitResult.a; peakTable.fitSigma(i) = fitResult.c; peakTable.fitR2(i) = gof.rsquare; % Update FWHM and resolution from fit peakTable.fwhm(i) = 2.355 * fitResult.c; if peakTable.fwhm(i) > 0 peakTable.resolution(i) = fitResult.b / peakTable.fwhm(i); end catch % Keep original values if fit fails peakTable.fitR2(i) = NaN; end end end %% Peak Deconvolution function deconv = deconvolvePeaks(centers, counts, background, peakTable) % Attempt to deconvolve overlapping peaks deconv = struct(); deconv.attempted = true; % Find potentially overlapping peaks nPeaks = height(peakTable); overlapGroups = {}; for i = 1:nPeaks pos_i = peakTable.position(i); fwhm_i = peakTable.fwhm(i); for j = i+1:nPeaks pos_j = peakTable.position(j); % Check if peaks overlap (within 2*FWHM) if abs(pos_i - pos_j) < (fwhm_i + peakTable.fwhm(j)) overlapGroups{end+1} = [i, j]; end end end deconv.overlapGroups = overlapGroups; deconv.nOverlapping = length(overlapGroups); % For each overlap group, fit multiple Gaussians deconv.fits = {}; for g = 1:length(overlapGroups) group = overlapGroups{g}; positions = peakTable.position(group); % Define fitting region minPos = min(positions) - 3*max(peakTable.fwhm(group)); maxPos = max(positions) + 3*max(peakTable.fwhm(group)); fitRange = centers >= minPos & centers <= maxPos; if sum(fitRange) < 10 continue; end xFit = centers(fitRange); yFit = (counts(fitRange) - background(fitRange))'; % Multi-Gaussian fit would go here % This is a placeholder for more sophisticated deconvolution deconv.fits{g} = struct('group', group, 'success', false, 'message', 'Not implemented'); end end %% Plotting function plotMassSpectrum(results, options) figure('Position', [100 100 1200 600], 'Name', 'Mass Spectrum Analysis'); % Main spectrum plot subplot(2,2,[1,3]); semilogy(results.spectrum.centers, results.spectrum.counts + 1, 'b-', 'LineWidth', 0.5); hold on; semilogy(results.spectrum.centers, results.background.values + 1, 'r-', 'LineWidth', 1); % Mark detected peaks if ~isempty(results.peaks) for i = 1:height(results.peaks) xline(results.peaks.position(i), 'g--', 'Alpha', 0.5); end end xlabel('Mass-to-charge (Da)'); ylabel('Counts (log scale)'); title(sprintf('Mass Spectrum (%d peaks detected)', results.statistics.nPeaks)); legend('Spectrum', 'Background', 'Location', 'northeast'); grid on; % Peak list subplot(2,2,2); if ~isempty(results.peaks) && height(results.peaks) > 0 % Show top peaks by height topPeaks = sortrows(results.peaks, 'height', 'descend'); topPeaks = topPeaks(1:min(15, height(topPeaks)), :); barh(1:height(topPeaks), topPeaks.height); yticks(1:height(topPeaks)); yticklabels(arrayfun(@(x) sprintf('%.2f', x), topPeaks.position, 'UniformOutput', false)); xlabel('Peak Height (counts)'); ylabel('Position (Da)'); title('Top 15 Peaks'); grid on; else text(0.5, 0.5, 'No peaks detected', 'HorizontalAlignment', 'center'); axis off; end % Statistics subplot(2,2,4); axis off; stats_text = { sprintf('Total counts: %d', results.statistics.totalCounts) sprintf('Number of peaks: %d', results.statistics.nPeaks) sprintf('Mean resolution: %.0f', results.statistics.meanResolution) sprintf('Median SNR: %.1f', results.statistics.medianSNR) sprintf('Background fraction: %.1f%%', results.statistics.backgroundFraction * 100) sprintf('Mass range: %.1f - %.1f Da', results.statistics.massRange(1), results.statistics.massRange(2)) sprintf('Bin width: %.3f Da', results.spectrum.binWidth) sprintf('Background method: %s', results.background.method) }; text(0.1, 0.9, 'Statistics', 'FontSize', 12, 'FontWeight', 'bold'); for i = 1:length(stats_text) text(0.1, 0.85 - i*0.1, stats_text{i}, 'FontSize', 10); end sgtitle('APT Mass Spectrum Analysis'); end` | MASSSPECANALYSIS Comprehensive mass spectrum analysis for APT data |
| `massSpecComparison` | `specComp = massSpecComparison(varargin) % massSpecComparison plots multiple massSpec in one figure % % specComp = massSpecComparison(pos1, pos2); % specComp = massSpecComparison(pos1, pos2, mode); % specComp = massSpecComparison(pos1, pos2, mode, posNames); % specComp = massSpecComparison(pos1, pos2, mode, posNames, binWidth, lineSize, colors); % % % INPUT % mode = 'normalised' or 'count' % pos = different pos variables up to a number of 7 (because the preset % colour vector has just 7 colors - if more needed please use the color % Vector) % posNames = Struct array with the name of the pos variables {'data1', % 'data2'} % bindWidth = number between 0 and 1 % lineSize = number starting from 1 % colors = if specific colors are needed, please parse colors as vectors [0 0.4470 0.7410; 0.8500 0.3250 % 0.0980] % % OUTPUT % specComp = with all the pos variables plotted % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% default mode = 'normalised'; binWidth = 0.01; lineSize = 1; t = 1; % Standard Matlab Colors edgeColorVec = [0 0.4470 0.7410; 0.8500 0.3250 0.0980; 0.9290 0.6940 0.1250;0.4940 0.1840 0.5560; 0.4660 0.6740 0.1880; 0.3010 0.7450 0.9330; 0.6350 0.0780 0.1840]; %% check input variables for k = 1:length(varargin) if ischar(varargin{k}) mode = varargin{k}; elseif iscell(varargin{k}) posNames = varargin{k}; elseif istable(varargin{k}) posVec{t,1} = varargin{k}; t = t+1; elseif isnumeric(varargin{k}) && length(varargin{k})==1 if varargin{k}>=1 lineSize = varargin{k}; elseif varargin{k}<1 binWidth = varargin{k}; end elseif isnumeric(varargin{k}) && length(varargin{k})==3 edgeColorVec = varargin{k}; end end % create pos names if variable doesn't exist if ~exist('posNames', 'var') for p = 1:length(posVec) posNames(1,p) = {"pos" + p}; end end %% check for Raw pos file input if length(posVec)<2 error('There is just one pos Variable parsed') end for i = 1:length(posVec) pos = posVec{i,1}; isTableCol = @(pos, atom) ismember(atom, pos.Properties.VariableNames); rawCheck = isTableCol(pos, 'atom'); if rawCheck == 1 pos = posUnDecompose(pos); end posVec{i,1} = pos; end %% calculate x and y for pos Variable for j = 1:length(posVec) pos = posVec{j,1}; mc = pos.mc; mcmax = max(mc); x = linspace(0,mcmax,round(mcmax/binWidth)); if strcmp(mode,'count') y = hist(mc,x); elseif strcmp(mode,'normalised') % calculate as counts/(Da * totalCts) so that mass spectra with different % count numbers are comparable y = hist(mc,x) / binWidth / length(mc); %med = median(y); else y = hist(mc,x); end xyVec{j,1} = x; xyVec{j,2} = y; end %% plot figure specComp = figure('Name','mass spectrum comparison'); ax = axes(specComp); for h = 1:length(posVec) % plot massSpec handleIn = area(xyVec{h,1},xyVec{h,2},'FaceAlpha',0, 'EdgeColor', edgeColorVec(h,:), 'EdgeAlpha', 0.5, 'DisplayName', posNames{h}, 'LineWidth', lineSize); hold on end set(ax,'YScale','Log'); %% legend for figure legend ax = get(handleIn,'Parent'); % make axis set(gcf, 'Color', [1 1 1]); set(get(gca,'XLabel'),'String','mass-to-charge-state ratio [Da]'); if strcmp(mode,'count') ylabel('frequency [counts]'); elseif strcmp(mode,'normalised') ylabel('frequency [cts / Da / totCts]'); end end` | massSpecComparison plots multiple massSpec in one figure |
| `peakBGCorrectedCount` | `[peakData] = peakBGCorrectedCount(pos, varargin) % peakBGCorrectedCount fits a linear background (least squares) to a peak in a mass spectrum % based on 'brushed' background bins. For this, the mass spectrum has to be % in the active axes, with the background bins marked. Also plots the % results. % % [peakData] = peakBGCorrectedCount(pos, rangeTable, ionName, boundary) % % [peakData] = peakBGCorrectedCount( pos, rangeTable, ionName) % [peakData] = peakBGCorrectedCount( pos, rangeTable, ionName, boundary) % [peakData] = peakBGCorrectedCount( pos, rangeTable, ionName, boundary, options) % % INPUT % massSpec a massSpec plot - created with massSpecPlot.m % pos pos file - in raw format % ionName ion Name in this form '14N 12C2 +' it is important to write the % specific isotopes % rangeTable if no range Table is parsed - the gcf has to be the massSpec % of the pos variable % boundary range in Da before and after the peak that should be used for % background correction either one value or two [3 3] are % allowed. If no value is parsed, the default value of 0.5 Da is used % figure true - figure window is created (default) % false - figure window is suppressed % offset if you want to have an offset between the range from the % rangeTable and the background correction range just possible % with boundaries % options 'r': add a fictional range and calculate the signal to background for that % range % 'a': same as 'r', but automatically created ranges by optimising the % ratio of missed atoms / background atoms = 1 % % OUTPUT % peakData struct array with the counts of the ions in the peak, the % percentage and the location of the peak % figure figure with the peak and the correction % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg rngLabelHeight = 0.65; % height of the stem plot delineating the range %% generelle Änderungen %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%% Ich hab das Massenspektrum entfernt. im einfachsten Fall parst %%%%%%%%%% man nur die pos variable - die funktion springt auf die gcf und %%%%%%%%%% man kann seine ranges anlegen. Wenn man einen bestimmtne peak %%%%%%%%%% mit range Table korrigieren mag - dann ist der default wert für %%%%%%%%%% die bin width vom massenspektrum 0.01 - soll ich den variabel %%%%%%%%%% machen ? - wenn ja müssen für boundary 2 werte eingegeben werden %%%%%%%%%% ansonsten kann man es ja nicht unterscheiden was für was ist. %% check for RAW pos file if ismember('atom',pos.Properties.VariableNames) pos = posUnDecompose(pos); end %% Check for variable input and divide it to ionNameTable, boundary and options % preset figOut = 1; t = 0; offset = 0; for k = 1:length(varargin) if istable(varargin{k}) rangeTable = varargin{k}; elseif ischar(varargin{k}) && length(varargin{k})>1 [ionNameTable, chargeState] = ionConvertName(varargin{k}); if isnan(chargeState) error('Please add the charge state'); end elseif ~ischar(varargin{k})&& length(varargin{k})>1 boundary = varargin{k}; t = 1; % count index - first numbers are for boundary second for offset elseif ~ischar(varargin{k})&& length(varargin{k})>1 && t == 1; offset = varargin{k}; elseif ischar(varargin{k}) && length(varargin{k})==1 options = varargin{k}; elseif islogical(varargin{k}) if varargin{k} == 1 figOut = 1; else figOut =0; end end end %% Check if manual input needed or if variable input with ranges is there if exist('boundary', 'var') && exist('ionNameTable', 'var') % find ranges From range Table if istable(ionNameTable) for i = 1:height(rangeTable) ionRow = ismember(rangeTable.ion{i}, ionNameTable); if sum(ionRow) == height(ionNameTable) && chargeState == rangeTable.chargeState(i) break elseif i == height(rangeTable) error('Check if the isotope of the desired ion is correct') end end mcBegin = rangeTable.mcbegin(i); mcEnd = rangeTable.mcend(i); end if exist('boundary', 'var') && length(boundary) == 1 boundary = [boundary boundary]; end if exist('offset', 'var') && length(offset) == 1 offset = [offset offset]; end % use boundary to get xLim if ~exist('boundary', 'var') % no boundary - use default value 1Da xLim = [mcBegin-0.5, mcBegin, mcEnd, mcEnd+0.5]; elseif length(boundary)== 2 % specific background calculation width before and after peak range xLim = [mcBegin-offset(1)-boundary(1), mcBegin-offset(1), mcEnd+offset(2), mcEnd+offset(2)+ boundary(2)]; end else % get baseline input % get the region before and after the peak [xLim, ~, ~] = ginput(4); xLim = sort(xLim); % sort it end %% get the X axis of the massSpec %%%%%%%%%%%%% ich mach das jetzt komplett anders - vorher hat man das %%%%%%%%%%%%% Massenspektrum gebraucht um den x vektor zu bekommen - der %%%%%%%%%%%%% war aber allerdings immer in der bin width in der das %%%%%%%%%%%%% massenspektrum erstellt wurde - ich würde einen default value %%%%%%%%%%%%% von 0.01 nehmen für alle massenspektren %%%%%%%%%%%%% Ich würde auch das massenspektrum komplett rausnehmen %%%%%%%%%%%%% und einfach wenn dann nur den rangeTable für die %%%%%%%%%%%%% Funktion nehmen % calculates mcScale x vector for interesting range mcScale = linspace(xLim(1), xLim(4), round((xLim(4)-xLim(1))/0.01)+1); %% Calculate lines for background % Line before peak inBefore = mcScale>xLim(1) & mcScale<xLim(2); % Line after peak inAfter = mcScale>xLim(3) & mcScale<xLim(4); % Creates a logical - 1 - in range for background correction - 0 not in % range for the entire dataset in = or(inBefore,inAfter); % just the range for the background correction mcData = mcScale(in); %% get the counts per bin % neues Count - wie viele ionen hab ich pro bin? % counts = hist(pos.mc,mcScale); counts = histcounts(pos.mc,mcScale); %brauch ich vllt nicht wegen entire range cntData = counts(in); % just select the bins that are in the range % calculation Range - range based for the calculation with the adjacent % counts of each bin calcRange = table(mcData', cntData', 'VariableNames', {'mcRange' 'counts'}); % find the start and end point of the range for background correction of the entire data set idxBeg = find(mcScale == min(calcRange.mcRange)); idxEnd = find(mcScale == max(calcRange.mcRange)); % get the entire range for background correction + peak in between both entireRange = table ((mcScale(idxBeg:idxEnd))', (counts(idxBeg:idxEnd))', in(idxBeg:idxEnd)', 'VariableNames', {'mcRange', 'counts', 'corrRange'}); % Peak location - find Peak position pkloc = entireRange.mcRange(entireRange.counts == max(entireRange.counts)); %% calculate linear fit of baseline lin_reg = polyfit(entireRange.mcRange(entireRange.corrRange == 1),entireRange.counts(entireRange.corrRange == 1),1); a1 = lin_reg(1); b1 = lin_reg(2); fitCts = a1*entireRange.mcRange+b1; sumFitCnt = sum(fitCts); sumCnt = sum(entireRange.counts); pkcnt = sumCnt - sumFitCnt; %% plotting of results numAtoms = max(pos.atomNum); %ions(isundefined(ions))='0'; numIons = height(pos(:,1)); pctAtoms = pkcnt/numAtoms * 100; pctIons = pkcnt/numAtoms * 100; sym = ' %'; if pctAtoms < 0.1 pctAtoms = pctAtoms/100 * 1E6; sym = ' ppm'; end if figOut == 1 f = figure(); plot(entireRange.mcRange,entireRange.counts); hold on plot(entireRange.mcRange,fitCts,'r','LineWidth',2); set(gcf, 'Color', [1 1 1]); set(gcf, 'Name', 'Background fit for peak'); set(get(gca,'XLabel'),'String','mass-to-chargestate [Da]'); set(get(gca,'YLabel'),'String','frequency'); legend('mc spectrum','bg fit'); xLim = get(gca,'XLim'); yLim = get(gca,'YLim'); txtPos = [xLim(1) + 0.02 * (xLim(2) - xLim(1)); ... yLim(1) + 0.8 * (yLim(2) - yLim(1))]; txt = {['ions in peak: ' num2str(round(pkcnt))],... ['pct of all ions: ' num2str(pctIons,3) sym],... ['peak location: ' num2str(pkloc) ' Da']}; %%%%%%%%%%%%%%%%% ab hier eigentlich nach 'r' und 'a' und vor OUtput %%%%%%%%%%%%%%%%% table % plotting numerical results text(txtPos(1),txtPos(2),txt); % exports the figure to the clipboard on Windows if ispc hgexport(f,'-clipboard'); end end %% executing optional commands if exist('options','var') switch options case 'a' % auto range optimisation. moves borders of range until the % peak background matches the amount of ions missed. % pkloc = peak location % cnt = counts per bin % mc = mass to charge center of bin % divide into before and after peak % Counts before Peak % mc enspricht mcScale pkloc - peak location %% check if fitCts and mcScale have the same size if length(mcScale) > length(fitCts) mcScale(1)=[]; mcScale(end) = []; end % Before peak ctsBeforePk = counts(mcScale<pkloc); mcBeforePk = mcScale(mcScale<pkloc); fitCtsBeforePk = fitCts(mcScale<pkloc); % Sum before the peak of the normal counts and the fitted rngCtsPk = cumsum(ctsBeforePk); rngCtsBg = cumsum(fitCtsBeforePk); BGincluded = rngCtsBg(end) - rngCtsBg; missedAtoms = rngCtsPk' - rngCtsBg; bal = BGincluded - missedAtoms; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% mit Peter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% absprechen!!!!!!!!!!!!!!!!!!!!!!!!! if sum(bal<0) == 0 bal = BGincluded + missedAtoms; end mcBegin = min(mcBeforePk(bal<0)); % mcBefore Pk - sind alle werte bevor der Peak losgeht - also % die mc die x achse % bal = %after ctsAfterPk = counts(mcScale>=pkloc); ctsAfterPk = fliplr(ctsAfterPk); mcAfterPk = mcScale(mcScale>=pkloc); mcAfterPk = fliplr(mcAfterPk); fitCtsAfterPk = fitCts(mcScale>=pkloc); fitCtsAfterPk = fliplr(fitCtsAfterPk); rngCtsPk = cumsum(ctsAfterPk); rngCtsBg = cumsum(fitCtsAfterPk); BGincluded = rngCtsBg(end) - rngCtsBg; missedAtoms = rngCtsPk' - rngCtsBg; bal = BGincluded - missedAtoms; mcEnd = min(mcAfterPk(bal>0)); % determination of mislabeled atoms mcmin = mcBegin; mcmax = mcEnd; mc = mcScale; rngCtsPk = sum(counts((mc>mcmin) & (mc<mcmax))); rngCtsBg = sum(fitCts((mc>mcmin) & (mc<mcmax))); BGfraction = rngCtsBg/(rngCtsPk+rngCtsBg)*100; rngBgGlobal = rngCtsBg/(numAtoms * (mcmax - mcmin)); peakData.mcbegin = mcBegin; peakData.mcend = mcEnd; % calculation of the amount of hydrogen of all ions ctsPk = rngCtsPk - rngCtsBg; corrPct = ctsPk/height(pos) * 100; ppm = corrPct/100 * 1E6; peakData.countsNew = ctsPk; peakData.ppmNew = ppm; peakData.pctNew = corrPct; sym = ' %'; if BGfraction < 0.1 BGfraction = pct/100 * 1E6; sym = ' ppm'; end if figOut ==1 txt{end+1} = ' '; txt{end+1} = ['range: ' num2str(mcmin) ' - ' num2str(mcmax) ' Da']; txt{end+1} = ['range background: ' num2str(BGfraction,3) sym]; txt{end+1} = ['range background: ' num2str(rngBgGlobal*1E6,3) ' ppm/Da']; missedAt = 100 - (rngCtsPk - rngCtsBg)/pkcnt *100; txt{end+1} = ['missed atoms: ' num2str(missedAt) ' %']; stem([mcmin mcmax],[yLim(2)*rngLabelHeight yLim(2)*rngLabelHeight],'k','Marker','none','LineWidth',1, 'DisplayName', 'optimised range' ); end end end %% Output Table peakData.counts = round(pkcnt); peakData.pct = pctIons; peakData.loc = pkloc; end` | peakBGCorrectedCount fits a linear background (least squares) to a peak in a mass spectrum |
| `chargeStateRatioCalculate` | `chargeStateRatioTable = chargeStateRatioCalculate(element,pos,chargeStates) % chargeStateRatioTable = chargeStateRatioCalculate(element,pos,chargeStates) % calculates the chargeStateratio of an element and his chargeStates in the % pos % % chargeStateRatioTable = chargeStateRatioCalculate(element,pos,chargeStates) % % INPUT % % element: character with the name of the element of interesst % % pos: decomposed pos file that contains ion and charge state of % the individual atoms % % chargeStates: double withe the chargeStates of interest % % OUTPUT % chargeStateRatioTable: % table with total counts of chargeStates and the ratio to % the chargeStates % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg % total counts of elements with the right charge state elementTotalNumber = size(pos(pos.ion == element,:),1); chargeStatesOverviewDouble = cell(2,size(chargeStates,2)); % get peak ratios for i = 1:size(chargeStates,2) chargeStateNumber = size(pos(pos.ion == element & ismember(pos.chargeState,chargeStates(i)),:),1); chargeStatesOverviewDouble{1,i} = chargeStateNumber; chargeStatesOverviewDouble{2,i} = chargeStateNumber./elementTotalNumber; end chargeStatesOverviewTable = array2table(chargeStatesOverviewDouble); % save results in table % variable names newNames = append("ChargeState +",string(chargeStates)); chargeStatesOverviewTable = renamevars(chargeStatesOverviewTable,1:width(chargeStates),newNames); % start tables with columns containing ion name and units sz = [2 2]; varNames = ["Element","format"]; varTypes = ["string","string"]; chargeStatesRatio = table('Size',sz,'VariableTypes',varTypes,'VariableNames',varNames); chargeStatesRatio.Element = categorical({element; element;}); chargeStatesRatio.format = categorical({'count'; 'ratio'}); % add results (chargeStatesOverviewTable) chargeStateRatioTable = [chargeStatesRatio chargeStatesOverviewTable]; end` | chargeStateRatioTable = chargeStateRatioCalculate(element,pos,chargeStates) |

---

## Visualization

| Function | Syntax | Description |
|----------|--------|-------------|
| `scatterPlotPosData` | `[p, ax] = scatterPlotPosData(pos,species,sample,colorScheme,size,plotAxis) % scatterPlotPosData plots APT data in the typical APT style. % % [p, ax] = scatterPlotPosData(pos,species,sample,colorScheme,size,plotAxis) % [p, ax] = scatterPlotPosData(pos,species,sample,colorScheme,size) % [p, ax] = scatterPlotPosData(pos,species,sample,colorScheme) % % INPUT % pos: decomposed or allocated pos file with pos.ion column % % species: Which ion/atom species should be plotted % one single ion {'C'} % more ions {'H','C','N'} % if multiple species are given and no plotAxis, array of % axes is plotted with synched axis movement. % Otherwise they all go into the same axis. % % sample: allows the specification of a subset to plot. % If sample <1, it is a fraction of the overall number of % atoms, if >1, it is a fixed number. Can be a scalar or a % vector with same length as species. % % colorScheme: a colorScheme can be parsed or a RGB color vector % % size: size of the single atoms in the plot % can be a scalar or a vector with same length as species. % % plotAxis: an axis for the plot can be parsed. If no plotAxis is % parsed, a new axis is created. If you want to plot % mulitple Ions in one plot write axes(figure()) for % plotAxis. % % OUTPUT % p: plot handle % % ax: axis from the plot, important for tiled plot % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% % find how many plots need to be done if iscell(species) numPlots = length(species); else numPlots = 1; species = {species}; % convert to cell array to be consistant with input of multiple species end % default size is 15, if size is not given if ~exist('size','var') size = 15; end % check if the pos file is decomposed isDecomposed = any(string(pos.Properties.VariableNames) == "atom"); %% set up the sample and size variables for multiple plots, if needed also color if numPlots > 1 if isscalar(sample); sample = repmat(sample,numPlots,1); end if isscalar(size); size = repmat(size,numPlots,1); end if ~istable(colorScheme) if size(colorScheme,1) == 1 color = repmat(colorScheme,numPlots,1); end end end %% set up plot figure and axis isTilePlot = false; if exist('plotAxis','var'); isExistingAxis = true; % so that all plots go in existing axis else % plots in new axis/figure fig = figure(); fig.Color = 'w'; isExistingAxis = false; if numPlots > 1 isTilePlot = true; % if multiple plots are made in a new figure, we use tiles tileLayoutHandle = tiledlayout(fig,'flow','TileSpacing','normal'); fig.Name = 'atom maps'; else fig.Name = [species{1} ' atom map']; end end %% loop through plots for pl = 1:numPlots % number of species % check if color already exist in colorScheme, if not, an error will % appear % iT = ionConvertName(species{1,pl}); % iN = ionConvertName(iT); % iC = cellstr(iN); % iCat = categorical(iC); % colorExist = (colorScheme.ion==iCat); % if sum(colorExist)==0 % error('color of the molecule is not in the colorScheme. Please add color to your colorScheme with colorSchemeIonAdd.m') % end % finding the atoms in the pos file % element: 'Fe' % elemental isotope: '56Fe' % ion: 'Fe+' or 'Fe' if pos variable is not decomposed [ionTable, ionChargeState] = ionConvertName(species{pl}); displayName = ionConvertName(ionTable, ionChargeState, 'LaTeX'); % finds chemical elements if any(isnan(ionTable.isotope)) && isDecomposed && isnan(ionChargeState) && height(ionTable) == 1 % use atoms speciesIdx = find(pos.atom == species{pl}); color = colorScheme.color(colorScheme.ion == species{pl},:); % finds isotopes (only single atom basis) elseif ~any(isnan(ionTable.isotope)) && isDecomposed && isnan(ionChargeState) if height(ionTable) > 1 error('plotting of ions based on isotopic information not currently supported'); end if ionTable.element == 'Da' color = colorScheme.color(colorScheme.ion == species{pl},:); speciesIdx = find(pos.ion == species{pl}); else speciesIdx = find(pos.atom == ionConvertName(ionTable.element) & pos.isotope == ionTable.isotope); color = colorScheme.color(colorScheme.ion == ionConvertName(ionTable.element),:); end elseif ~any(isnan(ionTable.isotope)) && ~isnan(ionChargeState) error('plotting of ions based on isotopic information not currently supported'); % finds specific ions with charge state elseif ~isnan(ionChargeState) speciesIdx = find(pos.ion == ionConvertName(ionTable.element) & pos.chargeState == ionChargeState); color = colorScheme.color(colorScheme.ion == ionConvertName(ionTable.element),:); % finds specific ions without chargestate elseif sum(colorScheme.ion == species{pl}) == 1 color = colorScheme.color(colorScheme.ion == species{pl},:); speciesIdx = find(pos.ion == species{pl}); else % check if ion is in colorScheme if sum(colorScheme.ion == ionTable.element)< 1 error('ion is not defined in the colorScheme') end speciesIdx = find(pos.ion == ionConvertName(ionTable.element)); if height(ionTable) == 1 displayName = [displayName ' (ion)']; end color = colorScheme.color(colorScheme.ion == ionConvertName(ionTable.element),:); end numAtoms = length(speciesIdx); % checking if number of atoms/ions requested is greater than number % available if sample(pl) > numAtoms sample(pl) = numAtoms; warning(['number of requested ' species{pl}... ' atoms/ions greater than number of atoms in dataset. All atoms plotted']); elseif sample(pl) <= 1 sample(pl) = round(numAtoms * sample(pl)); end % calculating sample indices plotIndices = speciesIdx(randsample(numAtoms,sample(pl))); % set up axis for plotting if required if isExistingAxis ax(pl) = plotAxis; hold on else if isTilePlot ax(pl) = nexttile(tileLayoutHandle); else % new plot in new axis ax(pl) = axes(fig); end end axisSpatialAptify; % displayName = species{pl}; % marker setup depending on marker size if size(pl) > 35 edgeColor = [0 0 0]; fillColor = color; markerStyle = 'o'; else edgeColor = color; fillColor = color; markerStyle = '.'; end % actual scatter plot p(pl) = scatter3(pos.x(plotIndices),pos.y(plotIndices),pos.z(plotIndices),... markerStyle,... 'MarkerEdgeColor',edgeColor,... 'MarkerFaceColor',fillColor,... 'SizeData',size(pl),... 'DisplayName',displayName,... 'Parent',ax(pl)); if ~isExistingAxis % condition new axes ax(pl).Box = 'on'; ax(pl).BoxStyle = 'full'; ax(pl).XColor = [1 0 0]; ax(pl).YColor = [0 1 0]; ax(pl).ZColor = [0 0 1]; ax(pl).ZDir = 'reverse'; if isTilePlot; title(ax(pl),displayName); end axis equal; end end %% link rotation between axes if isTilePlot rotLink = linkprop(ax,{'CameraUpVector', 'CameraPosition',... 'CameraTarget','XLim','YLim','ZLim'}); % links rotation setappdata(fig, 'StoreTheLink', rotLink); end rotate3d on; ax = ax'; pl = pl';` | scatterPlotPosData plots APT data in the typical APT style. |
| `colorSchemeCreate` | `colorScheme = colorSchemeCreate(ionTable) % colorSchemeCreate creates a table with RGB color codes for each ion; % the colors are generated in a way, that no two colors are perceived as similar % % INPUT: % ionTable: table with variable ion (ionTable.ionName) % example: ionTable = table(categorical({'Fe'; 'C'; 'H'; 'N'})); % ionTable.Properties.VariableNames{1} = 'ionName'; % % OUTPUT: % colorScheme: table with ion field and corresponding color field % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% Check for ions that are twice in the ionTable because of their charge state Tnew = unique(ionTable.ionName); ionTable = table(Tnew); ionTable.Properties.VariableNames{1} = 'ionName'; %% determine value for Value (V) of the HSV color code V = 1.0; % Value, value between 0 and 1 [1 means 100 %] %% generate evenly spaced values for H lsH = table(linspace(0, 0.8, height(ionTable))); % value of 0 is equivalent to value of 1, therefore upper limit is set to 0.8 lsH.Properties.VariableNames{1} = 'Hue'; %% generate evenly spaced values for S lsS = table(linspace(0.2, 1, height(ionTable))); % start value set to 0.2 so the color 'white' cannot be generated lsS.Properties.VariableNames{1} = 'Saturation'; %% generate colorScheme table colorScheme = table('Size',[height(ionTable) 2],'VariableTypes',{'categorical','double'}); colorScheme.Properties.VariableNames{1} = 'ion'; colorScheme.Properties.VariableNames{2} = 'color'; %% fill colorScheme table with HSV values for i = 1:height(ionTable); colorScheme.ion(i) = ionTable.ionName(i); colorScheme.color(i,1) = lsH.Hue(1,i); colorScheme.color(i,2) = lsS.Saturation(1,i); colorScheme.color(i,3) = V; end %% create colorScheme table with RGB values cst = table(colorScheme.color); HSV = table2array(cst); % insert HSV values in array % convert HSV color code to RGB color code RGB = hsv2rgb(HSV); colorScheme.color = RGB; end` | colorSchemeCreate creates a table with RGB color codes for each ion; |
| `colorSchemeIonAdd` | `colorScheme = colorSchemeIonAdd(colorScheme, newIon, selection) % colorSchemeIonAdd adds new ions to the colorScheme table and adds a new % color which was not used before. % % colorScheme = colorSchemeIonAdd(colorScheme, newIon, select) % colorScheme = colorSchemeIonAdd(colorScheme, newIon) % % INPUT % colorScheme: The existing colorScheme % newIon: Name of the newIon, if the ion already exists, the function will % end and the command window shows "ion already exists in % colorScheme" % selection: 'select' if you want to choose the color % if nothing is parsed, the color is randomly generated % 'create' a new color by picking the one that is the farthest % from all existing colors % % OUTPUT % colorScheme: the new colorScheme with the new ion added at the end of % the table % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% number of random colors to be generated for farthest point sampling NCOLS = 10000; %% Check for ion name ionTable = ionConvertName(newIon); % Convert the name in the table format ionName = ionConvertName(ionTable); % make the correct name length = size(colorScheme.ion); ionAlreadyExist = false; %% Check if ion already exists in colorScheme for j = 1:length(1,1) if colorScheme.ion(j,1) == ionName(1,:) disp ('ion already exists in colorScheme') return % don't start the color searching loop else match = true; ionAlreadyExist = false; end end %% check if color already exists for another ion, if the color already exists, % you need to choose a new color n = false; while match == true % add a color to the new ion if ~exist('selection','var') selection = 'create'; end if strcmp(selection,'select') && ionAlreadyExist == false if n == false color = uisetcolor(); n = true; else title = 'color already exists'; color = uisetcolor(title); end elseif strcmp(selection,'create') % generate new color from NCOLS number of randomly generated colors, % by picking the one that is the farthest from all existing colors cols = rand(NCOLS,3); dist = pdist2(colorScheme.color,cols,"euclidean"); md = min(dist,[],1); [~, idx] = max(md); color = cols(idx,:); end % check if color already exists and change the match variable for i = 1:length(1,1) if colorScheme.color(i,1) == color(1,1) && colorScheme.color(i,2) == color(1,2) && colorScheme.color(i,3) == color(1,3) match = true; % color already exist in colorScheme n = true; % countnumber for the second round of choosing a color i = length(1,1); else match = false; % color does not exist in colorScheme end end end %% write ionName and color in the colorScheme if ionAlreadyExist == false newIonRow = {ionName, color}; colorScheme(end+1,:) = newIonRow; end end` | colorSchemeIonAdd adds new ions to the colorScheme table and adds a new |
| `valueToColor` | `[vertColors colBar] = valueToColor(values,colorMap, limits) % NEEDS DOCUMENTATION % valueToColor maps a range of values to a colormap. This is needed for % visualisations of property maps on mesh objects % translates the values in vals (1 x N matrix) into vertex colors using the % colormap 'cmap'. Default is jet. Also outputs the colorbar colorBar, % which is a clolrmapped patch that can be used in the actual visualisation % program. % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg if max(values) < 0 values = uminus(values); end normalisedValues = (values - min(limits))/(max(limits) - min(limits)); cLevels = length(colorMap) -1; % 8 bit color is fully sampled idx = uint8( round( normalisedValues * cLevels ))+1; vertColors = colorMap(idx,:); % creating colorbar D = 1; %width of colorbar H = 10; %height of colorbar z = linspace(0,H,cLevels)'; fv.vertices = [zeros(size(z)), zeros(size(z)), z; ones(size(z))*D, zeros(size(z)), z]; fv.faces = delaunay(fv.vertices(:,1),fv.vertices(:,3)); %choice = questdlg('Export color bar to *.ply?','ply export','yes','no','no'); if false name = ['colorbar_' num2str(min(values),3) '_to_' num2str(max(values),3) '.ply']; [file path] = uiputfile('*.ply','save colorbar to:',name); patch2ply(fv,[colorMap; colorMap;],[path file]); end colBar.fv = fv; colBar.colorValues = [colorMap; colorMap];` | NEEDS DOCUMENTATION |
| `movieCreateTurntableAnimation` | `mov = movieCreateTurntableAnimation(deg,frameRate,fileName) % movieCreateTurntableAnimation creates a turntable animation of the current % figure and returns movie variable. The movie is saved in an *.avi format. % % mov = movieCreateTurntableAnimation(deg,frameRate,fileName) % mov = movieCreateTurntableAnimation(deg,frameRate) % mov = movieCreateTurntableAnimation(deg) % % INPUTS % deg: step size in degree in which the animation rotates. determines % the length and speed of the film. % % frameRate: frame rate of the movie in frames per second % % fileName: name under which the film is saved. % % % % OUTPUT % mov: movie of the turning atom probe tip % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg if ~exist('frameRate','var') frameRate = 30; % default value set to 30 end if ~exist('fileName','var') [file path] = uiputfile('*.avi','export movie'); fileName = [path file]; end set(gcf,'Color','w'); axis vis3d nFrames = 360/deg; for f = 1:nFrames frame = getframe(gcf); mov(f) = frame; camorbit(deg,0); end myVideo = VideoWriter(fileName); myVideo.FrameRate = frameRate; myVideo.Quality = 100; % default set to 100 open(myVideo); writeVideo(myVideo, mov); close(myVideo);` | movieCreateTurntableAnimation creates a turntable animation of the current |

---

## Region of Interest

| Function | Syntax | Description |
|----------|--------|-------------|
| `roiCreateBox` | `bh = roiCreateBox(dimensions,location,ax) % roiCreateBox creates a box in the current or parsed axis with specified % width and height at the location. % Output is handle to the object for later manipulation. % % bh = roiCreateBox() % bh = roiCreateBox(dimensions) % bh = roiCreateBox(dimensions,location) % bh = roiCreateBox(dimensions,location,ax) % % INPUT % dimensions: the length, width and height (x,y,z) of the ROI given as % [x y z], default is [10 10 10] % % location: the start coordinates of the ROI given as [x y z], % default is [0 0 0] % % ax: axes in which the ROI is orientated % % OUTPUT % bh: handle to the ROIbox % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% sets default dimensions to [10 10 10] if not(exist('dimensions','var')) dimensions = [10 10 10]; end %% default location is [0 0 0] if not(exist('location','var')) location = [0 0 0]; end %% gets axis if not(exist('ax','var')) ax = gca; end %% builds vertices vertices = [... 0 0 0;... idx 1 for x axis coloring 1 0 0;... idx 2 1 1 0;... idx 3 0 1 0;... idx 4 for y axis coloring 0 0 1;... idx 5 for z axis coloring 1 0 1;... idx 6 1 1 1;... idx 7 0 1 1]; % idx 8 vertices = vertices - 1/2; % centering cube vertices(:,1) = vertices(:,1) * dimensions(1); % scale xx vertices(:,2) = vertices(:,2) * dimensions(2); % scale yy vertices(:,3) = vertices(:,3) * dimensions(3); % scale zz vertices = vertices + repmat(location,8,1); %% builds and colors faces faces = [... order is such that rgb coloring of axis is correct 1 2 3 4;... 8 4 3 7;... 1 2 6 5;... 8 5 6 7;... 6 7 3 2;... 4 1 5 8;... ]; %% plotting of patch object bh = patch(ax,'Vertices',vertices,'Faces',faces); bh.FaceColor = [.5 , .5 , .5]; bh.FaceAlpha = 0.5; bh.DisplayName = 'ROI box'; %% defining reference coordinate system bh.UserData.ROIzaxis = [location ; location + [0,0,dimensions(1)]]; bh.UserData.ROIyaxis = [location ; location + [0,dimensions(2),0]]; bh.UserData.ROIxaxis = [location ; location + [dimensions(3),0,0]]; %% coloring of vertices cols = [... 1, 0, 0;... x axis coloring 0, 0, 0;... 0, 0, 0;... 0, 1, 0;... y axis coloring 0, 0, 1;... z axis coloring 0, 0, 0;... 0, 0, 0;... 0, 0, 0;]; bh.FaceVertexCData = cols; bh.EdgeColor = 'flat'; bh.LineWidth = 2;` | roiCreateBox creates a box in the current or parsed axis with specified |
| `roiCreateCylinder` | `ch = roiCreateCylinder(radius,height,location,numSegments,ax) % roiCreateCylinder creates cylinder in current or parsed axis with % specified radius and height. % Output is handle to the object for later manipulation. % % ch = roiCreateCylinder() % ch = roiCreateCylinder(radius) % ch = roiCreateCylinder(radius,height) % ch = roiCreateCylinder(radius,height,location) % ch = roiCreateCylinder(radius,height,location,numSegments) % ch = roiCreateCylinder(radius,height,location,numSegments,ax) % % INPUT % radius: radius of the cylinder, default is 5 % % height: height of the cylinder, default is 10 % % location: start coordinates of the cylinder, default is [0 0 0] % % numSegments: number of segments of the cylinder, default is 32 % % ax: axes in which the ROI is orientated % % OUTPUT % ch: handle to the ROIcylinder % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% sets default radius to 5 if not(exist('radius','var')) radius = 5; end %% sets default height to 10 if not(exist('height','var')) height = 10; end %% sets default location to [0, 0, 0] if not(exist('location','var')) location = [0 0 0]; end %% sets default numSegments to 32 if not(exist('numSegments','var')) numSegments = 32; end %% gets axis if not(exist('ax','var')) ax = gca; end %% creates the cylinder [x, y, z] = cylinder(radius,numSegments); z = z * height - height/2; x = x'; y = y'; z = z'; x = x(:); y = y(:); z = z(:); x0 = location(:,1); % getting x coordinate of location y0 = location(:,2); % getting y coordinate of location z0 = location(:,3); % getting z coordinate of location x = x + x0; % calculate shifted x coordinates y = y + y0; % calculate shifted y coordinates z = z + z0; % calculate shifted z coordinates fv.vertices = [x,y,z]; faces = convhull(x,y,z); fv.faces = faces; %% plotting the patch object ch = patch(ax,'Vertices',fv.vertices,'Faces',fv.faces); ch.FaceColor = [.5 , .5 , .5]; ch.FaceAlpha = 0.5; ch.DisplayName = 'ROI cylinder'; %% defining reference coordinate system ch.UserData.ROIzaxis = [location ; location + [0,0,height]]; ch.UserData.ROIyaxis = [location ; location + [0,radius,0]]; ch.UserData.ROIxaxis = [location ; location + [radius,0,0]];` | roiCreateCylinder creates cylinder in current or parsed axis with |
| `roiCreateSphere` | `sh = roiCreateSphere(radius,subDivisions,location,ax) % roiCreateSphere creates sphere in current or parsed axis with specified % radius. Output is handle to the object for later manipulation. % % sh = roiCreateSphere() % sh = roiCreateSphere(radius) % sh = roiCreateSphere(radius,subDivisions) % sh = roiCreateSphere(radius,subDivisions,location) % sh = roiCreateSphere(radius,subDivisions,location,ax) % % INPUT % radius: the radius of the ROI, default is 10 % % subDivisions: fineness of the grid, default is 2 % % location: the start coordinates of the ROI given as [x y z] % default is [0 0 0] % % ax: axes in which the ROI is orientated % % OUTPUT % sh: handle to the ROIsphere % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg if not(exist('radius','var')) radius = 10; end if not(exist('subDivisons','var')) subDivisions = 2; end if not(exist('location','var')) location = [0 0 0]; end if not(exist('ax','var')) ax = gca; end [fv.vertices fv.faces] = icosphere(subDivisions); fv.vertices = fv.vertices * radius; sh = patch(ax,'Vertices',fv.vertices,'Faces',fv.faces); sh.FaceColor = [.5 , .5 , .5]; sh.FaceAlpha = 0.5; sh.Vertices(:,1) = sh.Vertices(:,1) + location(:,1);%shifts x coordinates sh.Vertices(:,2) = sh.Vertices(:,2) + location(:,2);%shifts y coordinates sh.Vertices(:,3) = sh.Vertices(:,3) + location(:,3);%shifts z coordinates %% defining reference coordinate system sh.UserData.ROIzaxis = [location ; location + [0,0,radius]]; sh.UserData.ROIyaxis = [location ; location + [0,radius,0]]; sh.UserData.ROIxaxis = [location ; location + [radius,0,0]]; end function [vv,ff] = icosphere(varargin) % ICOSPHERE Generate icosphere. % Create a unit geodesic sphere created by subdividing a regular % icosahedron with normalised vertices. % % [V,F] = ICOSPHERE(N) generates two matrices containing vertex and face % data so that patch('Faces',F,'Vertices',V) produces a unit icosphere % with N subdivisions. % % FV = ICOSPHERE(N) generates an FV structure for using with patch. % % ICOSPHERE(N) and just ICOSPHERE display the icosphere as a patch on the % current axes and does not return anything. % % ICOSPHERE uses N = 3. % % ICOSPHERE(AX,...) plots into AX instead of GCA. % % See also SPHERE. % % Based on C# code by Andres Kahler % http://blog.andreaskahler.com/2009/06/creating-icosphere-mech-in-code.html % % Wil O.C. Ward 19/03/2015 % University of Nottingham, UK % Parse possible axes input if nargin > 2 error('Too many input variables, must be 0, 1 or 2.'); end [cax,args,nargs] = axescheck(varargin{:}); n = 3; % default number of subdivisions if nargs > 0, n = args{1}; end % override based on input % generate regular unit icosahedron (20 faced polyhedron) [v,f] = icosahedron(); % size(v) = [12,3]; size(f) = [20,3]; % recursively subdivide triangle faces for gen = 1:n f_ = zeros(size(f,1)*4,3); for i = 1:size(f,1) % for each triangle tri = f(i,:); % calculate mid points (add new points to v) [a,v] = getMidPoint(tri(1),tri(2),v); [b,v] = getMidPoint(tri(2),tri(3),v); [c,v] = getMidPoint(tri(3),tri(1),v); % generate new subdivision triangles nfc = [tri(1),a,c; tri(2),b,a; tri(3),c,b; a,b,c]; % replace triangle with subdivision idx = 4*(i-1)+1:4*i; f_(idx,:) = nfc; end f = f_; % update end % remove duplicate vertices [v,b,ix] = unique(v,'rows'); clear b % b dummy / compatibility % reassign faces to trimmed vertex list and remove any duplicate faces f = unique(ix(f),'rows'); switch(nargout) case 0 % no output cax = newplot(cax); % draw to given axis (or gca) chowSphere(cax,f,v); case 1 % return fv structure for patch vv = struct('Vertices',v,'Faces',f,... 'VertexNormals',v,'FaceVertexCData',v(:,3)); case 2 % return vertices and faces vv = v; ff = f; otherwise error('Too many output variables, must be 0, 1 or 2.'); end end function [i,v] = getMidPoint(t1,t2,v) % GETMIDPOINT calculates point between two vertices % Calculate new vertex in subdivision aex % % Wil O.C. Ward 19/03/2015 % University of Nottingham, UK % get vertice positions p1 = v(t1,:); p2 = v(t2,:); % calculate mid point (on unit sphere) pm = (p1 + p2) ./ 2; pm = pm./norm(pm); % add to vertices list, return index i = size(v,1) + 1; v = [v;pm]; end function [v,f] = icosahedron() % ICOSAHEDRON creates unit regular icosahedron % Returns 12 vertex and 20 face values. % % Wil O.C. Ward 19/03/2015 % University of Nottingham, UK t = (1+sqrt(5)) / 2; % create vertices v = [-1, t, 0; % v1 1, t, 0; % v2 -1,-t, 0; % v3 1,-t, 0; % v4 0,-1, t; % v5 0, 1, t; % v6 0,-1,-t; % v7 0, 1,-t; % v8 t, 0,-1; % v9 t, 0, 1; % v10 -t, 0,-1; % v11 -t, 0, 1];% v12 % normalise vertices to unit size v = v./norm(v(1,:)); % create faces f = [ 1,12, 6; % f1 1, 6, 2; % f2 1, 2, 8; % f3 1, 8,11; % f4 1,11,12; % f5 2, 6,10; % f6 6,12, 5; % f7 12,11, 3; % f8 11, 8, 7; % f9 8, 2, 9; % f10 4,10, 5; % f11 4, 5, 3; % f12 4, 3, 7; % f13 4, 7, 9; % f14 4, 9,10; % f15 5,10, 6; % f16 3, 5,12; % f17 7, 3,11; % f18 9, 7, 8; % f19 10, 9, 2];% f20 end function chowSphere(cax,f,v) % chOWSPHERE displays icosphere given faces and vertices. % Displays a patch surface on the axes, cax, and sets the view. % % Properties: % - vertex normals == vertex vectors % - no backface lighting % - colour data matches z value of vertex % - material properties match default SURF % % Wil O.C. Ward 19/03/2015 % University of Nottingham, UK % set some axes properties if not held if ~ichold(cax) az = -37.5; el = 30; view(az,el) grid end % create patch object on cax patch('Faces',f,'Vertices',v,... 'VertexNormals',v,... 'LineWidth',0.5,'FaceLighting','phong',... 'BackFaceLighting','unlit',... 'AmbientStrength',0.3,'DiffuseStrength',0.6,... 'SpecularExponent',10,'SpecularStrength',0.9,... 'FaceColor','flat','CData',v(:,3),... 'Parent',cax,'Tag','Icosphere'); end` | roiCreateSphere creates sphere in current or parsed axis with specified |
| `roiCreatePlane` | `ph = roiCreatePlane(dimensions,spacing,location,ax) % roiCreatePlane creates a plane in the current or parsed axis with % specified width and height at location. % spacing gives the approximate spacing between vertices for later analysis % purposes. leave at 0 for simple plane object with no subdivision. % Output is handle to the object for later manipulation. % % ph = roiCreatePlane(dimensions,spacing) % ph = roiCreatePlane(dimensions,spacing,location) % ph = roiCreatePlane(dimensions,spacing,location,ax) % % INPUT % dimensions: 1x2 array with x and y dimensions of the plane % % spacing: 1x2 array with the spacing value in x and y direction % % location: coordinates of the ROI's center given as [x y] % default is [0 0] % % ax: axes in which the ROI is orientated % % OUTPUT % ph: handle to the ROIplane % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg % get axis if necessary if not(exist('ax','var')) ax = gca; end % default location is [0, 0, 0] if ~exist('location','var') location = [0, 0, 0]; end % x and y coordinates of the vertices xLocs = (0:spacing(:,1):dimensions(:,1)) - dimensions(:,1)/2; yLocs = (0:spacing(:,2):dimensions(:,2)) - dimensions(:,2)/2; [tx, ty] = meshgrid(xLocs,yLocs); numVerts = length(tx(:)); vertices = [tx(:), ty(:)]; vertices(:,3) = 0; vertices = vertices + repmat(location,numVerts,1); % delaunay triangulation of vertices faces = delaunay(vertices(:,1),vertices(:,2)); % plotting of patch object ph = patch(ax,'Vertices',vertices,'Faces',faces); ph.FaceColor = [.5 , .5 , .5]; ph.FaceAlpha = 0.5; ph.DisplayName = 'ROI plane'; % defining reference coordinate system ph.UserData.ROIzaxis = [location ; location + [0,0,dimensions(1)]]; ph.UserData.ROIyaxis = [location ; location + [0,dimensions(2),0]]; ph.UserData.ROIxaxis = [location ; location + [mean(dimensions),0,0]];` | roiCreatePlane creates a plane in the current or parsed axis with |
| `roiFromObj` | `roi_Obj = roiFromObj(obj) % roiFromObj loads any .obj-data and forms it into a roi % % roi_Obj = roiFromObj(obj) % % INPUT % % obj = obj that was exportet from e.g. Blender % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% loads obj obj = objToPatch(); %% makes patch from obj roi_Obj = patch (gca,'Vertices',obj.vertices,'Faces',obj.objects.faces) %% changes color and name roi_Obj.FaceColor = [.5 , .5 , .5]; roi_Obj.FaceAlpha = 0.5; roi_Obj.DisplayName = 'ROI from Obj'; %% coloring of vertices cols = [... 1, 0, 0;... x axis coloring 0, 0, 0;... 0, 0, 0;... 0, 1, 0;... y axis coloring 0, 0, 1;... z axis coloring 0, 0, 0;... 0, 0, 0;... 0, 0, 0;]; roi_Obj.FaceVertexCData = cols; roi_Obj.EdgeColor = 'flat'; roi_Obj.LineWidth = 2;` | roiFromObj loads any .obj-data and forms it into a roi |
| `posInConvexHull` | `in = posInConvexHull(pos,xyz,tess,tol) % posInConvexHull: tests if a set of points is inside a convex hull % % in = posInConvexHull(pos,xyz) % in = posInConvexHull(pos,xyz,tess) % in = posInConvexHull(pos,xyz,tess,tol) % % INPUT % pos: n*p array to test, n data points, in p dimensions % If you have many points to test, it is most efficient to % call this function once with the entire set. % % xyz: m*p array of vertices of the convex hull, as used by % convhulln. % % tess: tessellation (or triangulation) generated by convhulln % If tess is left empty or not supplied, then it will be % generated. % % tol: (OPTIONAL) tolerance on the tests for inclusion in the % convex hull. You can think of tol as the distance a point % may possibly lie outside the hull, and still be perceived % as on the surface of the hull. Because of numerical slop % nothing can ever be done exactly here. I might guess a % semi-intelligent value of tol to be % % tol = 1.e-13*mean(abs(xyz(:))) % % In higher dimensions, the numerical issues of floating % point arithmetic will probably suggest a larger value % of tol. % % DEFAULT: tol = 0 % % OUTPUT % in: nx1 logical vector % in(i) == 1 --> the i'th point was inside the convex hull. % % Example usage: The first point should be inside, the second out % % xy = randn(20,2); % tess = convhulln(xy); % testpoints = [ 0 0; 10 10]; % in = inhull(testpoints,xy,tess) % % in = % 1 % 0 % % A non-zero count of the number of degenerate simplexes in the hull % will generate a warning (in 4 or more dimensions.) This warning % may be disabled off with the command: % % warning('off','inhull:degeneracy') % % See also: convhull, convhulln, delaunay, delaunayn, tsearch, tsearchn % % Author: John D'Errico % e-mail: woodchips@rochester.rr.com % Release: 3.0 % Release date: 10/26/06 % edited by benedict.ott@fau.de @ 06/10/2020 %% Limits pos to the right dimensions if exist ('pos','var') if size(xyz,2)==2 posDimensions = [pos.x pos.y]; else posDimensions = [pos.x pos.y pos.z]; end end %% get array sizes % m points, p dimensions p = size(xyz,2); [n,c] = size(posDimensions); if p ~= c error 'posDimensions and xyz must have the same number of columns' end if p < 2 error 'posDimensions must lie in at least a 2-d space.' end %% was the convex hull supplied? if (nargin<3) || isempty(tess) tess = convhulln(xyz); end [nt,c] = size(tess); if c ~= p error 'tess array is incompatible with a dimension p space' end %% was tol supplied? if (nargin<4) || isempty(tol) tol = 0; end %% build normal vectors switch p case 2 % really simple for 2-d nrmls = (xyz(tess(:,1),:) - xyz(tess(:,2),:)) * [0 1;-1 0]; % Any degenerate edges? del = sqrt(sum(nrmls.^2,2)); degenflag = (del<(max(del)*10*eps)); if sum(degenflag)>0 warning('inhull:degeneracy',[num2str(sum(degenflag)), ... ' degenerate edges identified in the convex hull']) % we need to delete those degenerate normal vectors nrmls(degenflag,:) = []; nt = size(nrmls,1); end case 3 % use vectorized cross product for 3-d ab = xyz(tess(:,1),:) - xyz(tess(:,2),:); ac = xyz(tess(:,1),:) - xyz(tess(:,3),:); nrmls = cross(ab,ac,2); degenflag = false(nt,1); otherwise % slightly more work in higher dimensions, nrmls = zeros(nt,p); degenflag = false(nt,1); for i = 1:nt % just in case of a degeneracy % Note that bsxfun COULD be used in this line, but I have chosen to % not do so to maintain compatibility. This code is still used by % users of older releases. % nullsp = null(bsxfun(@minus,xyz(tess(i,2:end),:),xyz(tess(i,1),:)))'; nullsp = null(xyz(tess(i,2:end),:) - repmat(xyz(tess(i,1),:),p-1,1))'; if size(nullsp,1)>1 degenflag(i) = true; nrmls(i,:) = NaN; else nrmls(i,:) = nullsp; end end if sum(degenflag)>0 warning('inhull:degeneracy',[num2str(sum(degenflag)), ... ' degenerate simplexes identified in the convex hull']) % we need to delete those degenerate normal vectors nrmls(degenflag,:) = []; nt = size(nrmls,1); end end %% scale normal vectors to unit length nrmllen = sqrt(sum(nrmls.^2,2)); % again, bsxfun COULD be employed here... % nrmls = bsxfun(@times,nrmls,1./nrmllen); nrmls = nrmls.*repmat(1./nrmllen,1,p); %% center point in the hull center = mean(xyz,1); %% any point in the plane of each simplex in the convex hull a = xyz(tess(~degenflag,1),:); %% ensure the normals are pointing inwards % this line too could employ bsxfun... % dp = sum(bsxfun(@minus,center,a).*nrmls,2); dp = sum((repmat(center,nt,1) - a).*nrmls,2); k = dp<0; nrmls(k,:) = -nrmls(k,:); %% We want to test if: dot((x - a),N) >= 0 % If so for all faces of the hull, then x is inside % the hull. Change this to dot(x,N) >= dot(a,N) aN = sum(nrmls.*a,2); %% test, be careful in case there are many points in = false(n,1); %% if n is too large, we need to worry about the % dot product grabbing huge chunks of memory. memblock = 1e6; blocks = max(1,floor(n/(memblock/nt))); aNr = repmat(aN,1,length(1:blocks:n)); for i = 1:blocks j = i:blocks:n; if size(aNr,2) ~= length(j), aNr = repmat(aN,1,length(j)); end in(j) = all((nrmls*posDimensions(j,:)' - aNr) >= -tol,1)'; end` | posInConvexHull: tests if a set of points is inside a convex hull |

---

## Concentration Analysis

| Function | Syntax | Description |
|----------|--------|-------------|
| `posCalculateConcentrationSimple` | `conc = posCalculateConcentrationSimple(pos,detEff,excludeList,volumeName) % posCalculateConcentrationSimple calculates the concentration of a % categorical list of atoms or ions % % conc = posCalculateConcentrationSimple(pos, detEff, excludeList,volumeName); % conc = posCalculateConcentrationSimple(pos, detEff, excludeList) % conc = posCalculateConcentrationSimple(pos, detEff) % % INPUT % pos: decomposed pos file that contains ion and charge state of % the individual atoms % % detEff: detector efficiency of the atom probe, can be parsed as % or as a fraction (for a LEAP 4000X HR it is 0.37) % % excludeList: cell array that contains as character the individual % ions that shall not be considered for the concentration % calculation, unranged atoms appear as 'unranged', if not % parsed, no atoms will be excluded % % volumeName: name of the volume, parsed as character array, if not parsed, % the volume will be named after pos % % OUTPUT % conc: is a table that contains the count, concentration, and % variance for each atom/ion that is not on the excludeList. % statistical deviation calculated after Danoix et al., % https://doi.org/10.1016/j.ultramic.2007.02.005 % variance(conc) = conc*(1-conc)/numAtomsDetected * (1 - detEff) % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% detector efficiency if detEff > 1 detEff = detEff/100; end %% check if atomic or ionic concentration is calculated if any(ismember(pos.Properties.VariableNames,'atom')) type = 'atomic'; columnType = 'atom'; atoms = pos.atom; else type = 'ionic'; columnType = 'ion'; atoms = pos.ion; end if ~exist('volumeName','var') volumeName = inputname(1); end % need to assign, otherwise not counted in countcats atoms(isundefined(atoms)) = 'unranged'; %% check for excluded types cats = categories(atoms); if exist('excludeList','var') isExcluded = ismember(cats,excludeList); else isExcluded = false(size(cats)); end isExcluded = isExcluded'; %% calculate concentrations for not excluded variables counts = countcats(atoms); if iscolumn(counts) counts = counts'; end counts(2,:) = counts./sum(counts(~isExcluded)); counts(2,isExcluded) = 0; counts(3,:) = counts(2,:).*(1- counts(2,:))./counts(1,:) * (1-detEff); %% creating output table conc = array2table(counts,'VariableNames',cats'); conc.Properties.VariableDescriptions = repmat({columnType},size(cats')); conc = [table(categorical({volumeName;volumeName;volumeName}),'VariableNames',{'volume'})... table([0;0;0],'VariableNames',{'distance'} )... table(categorical({type;type;type}),'VariableNames',{'type'}),... table(categorical({'count'; 'concentration';'variance'}),'VariableNames',{'format'}),... conc];` | posCalculateConcentrationSimple calculates the concentration of a |
| `concentrationUncertainty` | `[uncertainty, details] = concentrationUncertainty(counts, options) % CONCENTRATIONUNCERTAINTY Calculate concentration uncertainty from counting statistics % % [uncertainty, details] = concentrationUncertainty(counts) % [uncertainty, details] = concentrationUncertainty(counts, 'method', 'binomial') % % Calculates the uncertainty in composition measurements based on counting % statistics. Several methods are available depending on the analysis context. % % INPUT: % counts - Vector or matrix of atom counts per element/ion % Each row represents a measurement, columns are elements % OR a table with ion counts % % OPTIONS: % 'method' - Uncertainty calculation method (default: 'binomial') % 'poisson' - sqrt(N) counting statistics % 'binomial' - Full binomial uncertainty (recommended) % 'clopper' - Clopper-Pearson exact confidence interval % 'confidence' - Confidence level for intervals (default: 0.95) % 'detectionEfficiency' - Detector efficiency for correction (default: 1) % 'background' - Background counts to subtract (default: 0) % % OUTPUT: % uncertainty - Structure containing: % .concentration - Calculated concentrations (atomic fraction) % .sigma - Standard deviation of concentration % .ciLower - Lower confidence interval % .ciUpper - Upper confidence interval % .totalAtoms - Total atom count per measurement % % details - Additional calculation details % % THEORY: % For binomial statistics, the variance of concentration c = n/N is: % Var(c) = c(1-c)/N % % This accounts for the constraint that concentrations must sum to 1. % % EXAMPLES: % % Single measurement with 3 elements % counts = [150, 40, 10]; % Fe, Cr, C atoms % unc = concentrationUncertainty(counts); % % % Multiple measurements % counts = [150 40 10; 148 42 10; 152 38 10]; % unc = concentrationUncertainty(counts, 'confidence', 0.99); % % REFERENCES: % Danoix, F. et al. (2007) Microscopy and Microanalysis % Miller, M.K. (2000) Atom Probe Tomography % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments counts {mustBeNumeric} options.method (1,:) char {mustBeMember(options.method, {'poisson', 'binomial', 'clopper'})} = 'binomial' options.confidence (1,1) double {mustBeInRange(options.confidence, 0, 1)} = 0.95 options.detectionEfficiency (1,1) double {mustBePositive} = 1 options.background = 0 end % Handle table input if istable(counts) counts = table2array(counts); end % Ensure counts is 2D (rows = measurements, columns = elements) if isvector(counts) counts = counts(:)'; % Row vector end [nMeasurements, nElements] = size(counts); % Subtract background if provided if ~isscalar(options.background) || options.background ~= 0 if isscalar(options.background) counts = counts - options.background; else counts = counts - options.background(:)'; end counts = max(counts, 0); % Ensure non-negative end % Calculate total atoms per measurement totalAtoms = sum(counts, 2); % Correct for detection efficiency correctedCounts = counts / options.detectionEfficiency; correctedTotal = totalAtoms / options.detectionEfficiency; % Calculate concentrations concentration = counts ./ totalAtoms; concentration(isnan(concentration)) = 0; % Initialize output uncertainty = struct(); uncertainty.concentration = concentration; uncertainty.totalAtoms = totalAtoms; % Calculate uncertainty based on method switch lower(options.method) case 'poisson' % Simple Poisson counting statistics % sigma(c) = sqrt(n) / N sigma = sqrt(counts) ./ totalAtoms; sigma(totalAtoms == 0, :) = 0; uncertainty.sigma = sigma; % Confidence interval using normal approximation z = norminv((1 + options.confidence) / 2); uncertainty.ciLower = max(0, concentration - z * sigma); uncertainty.ciUpper = min(1, concentration + z * sigma); case 'binomial' % Binomial uncertainty (recommended for APT) % Var(c) = c(1-c)/N variance = concentration .* (1 - concentration) ./ totalAtoms; variance(totalAtoms == 0, :) = 0; sigma = sqrt(variance); uncertainty.sigma = sigma; % Confidence interval using normal approximation z = norminv((1 + options.confidence) / 2); uncertainty.ciLower = max(0, concentration - z * sigma); uncertainty.ciUpper = min(1, concentration + z * sigma); case 'clopper' % Clopper-Pearson exact confidence interval % More accurate for small counts alpha = 1 - options.confidence; ciLower = zeros(nMeasurements, nElements); ciUpper = zeros(nMeasurements, nElements); for m = 1:nMeasurements N = totalAtoms(m); for e = 1:nElements n = counts(m, e); if N == 0 ciLower(m, e) = 0; ciUpper(m, e) = 0; elseif n == 0 ciLower(m, e) = 0; ciUpper(m, e) = 1 - (alpha/2)^(1/N); elseif n == N ciLower(m, e) = (alpha/2)^(1/N); ciUpper(m, e) = 1; else ciLower(m, e) = betaincinv(alpha/2, n, N-n+1); ciUpper(m, e) = betaincinv(1-alpha/2, n+1, N-n); end end end uncertainty.ciLower = ciLower; uncertainty.ciUpper = ciUpper; uncertainty.sigma = (ciUpper - ciLower) / (2 * norminv((1 + options.confidence) / 2)); end % Additional details details = struct(); details.method = options.method; details.confidence = options.confidence; details.detectionEfficiency = options.detectionEfficiency; details.nMeasurements = nMeasurements; details.nElements = nElements; details.effectiveCounts = correctedCounts; % If single measurement, simplify output if nMeasurements == 1 uncertainty.concentration = uncertainty.concentration(:)'; uncertainty.sigma = uncertainty.sigma(:)'; uncertainty.ciLower = uncertainty.ciLower(:)'; uncertainty.ciUpper = uncertainty.ciUpper(:)'; end end function mustBeInRange(x, lo, hi) if x < lo || x > hi error('Value must be in range [%g, %g]', lo, hi); end end` | CONCENTRATIONUNCERTAINTY Calculate concentration uncertainty from counting statistics |
| `binApplyConcentrationKernel` | `conc = binApplyConcentrationKernel(vox,binCenters,concentrationKernel,distanceUnits) % binApplyConcentrationKernel takes a voxelisation and applies a % concentration function to it the binCenters are put into the % concentration values for plotting % % conc = binApplyConcentrationKernel(vox,binCenters, concentrationKernel, distanceUnits) % % INPUT % vox: pos file in voxel % % binCenters: binCenters of the voxel, calculated with the % binVectorsFromDistance function % % concentrationKernel: concentration function that will calculate the % concentration for each voxel % % distanceUnits: Units to measure the distance e.g. {'nm'} % % OUTPUT % conc: cocentration % for 1D, output is a table % for more dimenstions, output is a cell array of concentration % tables % % To DO: implement distance variable assignement for numDim > 1 % maybe rename distance to location as it fits better with numDim > 1 % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% concentration calculation per voxel conc = cellfun(concentrationKernel, vox, 'UniformOutput',false); numDim = length(binCenters); dist = cell(size(conc)); % allocation of distance vector % conc = cellfun(@(conc, dist) allocateDistanceVector(conc, dist),conc, dist, 'UniformOutput',false); % create list for 1D if isvector(vox) conc{1}.distance(:) = binCenters{1}(1); concOut = conc{1}; for i = 2:numel(conc) conc{i}.distance(:) = binCenters{1}(i); concOut = [concOut; conc{i}]; end conc = concOut; %conc.Properties.VariableUnits{strcmp(conc.Properties.VariableNames,'distance')} = distanceUnits{1}; end end function conc = allocateDistanceVector(conc, dist) conc.distance(:) = repmat(dist,[3,1]); end` | binApplyConcentrationKernel takes a voxelisation and applies a |
| `calculate1Dprofile` | `[profile, binVec] = calculate1Dprofile(axis,bin,solutes,allAtoms) %calculates a 1D concentration profile along the axis given. allAtoms is %optional, if not given, profile will be counts. solutes = [solutes.x, solutes.y, solutes.z]; numSol = height(solutes(:,1)); origin = axis(1,:); axis = axis(2,:) - axis(1,:); solutes = table2array(solutes); solutes = solutes - repmat(origin,[numSol,1]); axis = axis/norm(axis); %make axis unit length distSol = sum(solutes.*repmat(axis,[numSol,1]),2);% dot product with scale axis for projected length minDist = min(distSol); maxDist = max(distSol); if exist('allAtoms','var') allAtoms = allAtoms(:,1:3); numAtoms = length(allAtoms(:,1)); allAtoms = allAtoms - repmat(origin,[numAtoms,1]); distAll = sum(allAtoms.*repmat(axis,[numAtoms,1]),2);% dot product with scale axis for projected length minDist = min(distAll); maxDist = max(distAll); end % calculating bin centers binVec = linspace(0,10000*bin,10001); binVec = [fliplr(uminus(binVec(2:end))) binVec]; binVec(binVec<minDist | binVec>maxDist) = []; histSol = hist(distSol,binVec); if exist('allAtoms','var') histAll = hist(distAll,binVec); profile = histSol./histAll; else profile = histSol; end` | calculates a 1D concentration profile along the axis given. allAtoms is |
| `calculate2Dprofile` | `calculate2Dprofile(normalAxis, xAxis ,bin,crop,atoms,allAtoms) %calculates 2D concentration profile of 'atoms' compared to 'allAtoms'. If %'allAtoms' is not parsed, raw counts will be used. 'crop' is a [min max] %limit for the 2D profile. The 'normalAxis' also defines the origin of the %2D concentration profile. % transform atoms into the coordinate system of the 2D conc profile` | calculates 2D concentration profile of 'atoms' compared to 'allAtoms'. If |

---

## Proxigram Analysis

| Function | Syntax | Description |
|----------|--------|-------------|
| `pointCreateProxigram` | `[proxi, binVector] = pointCreateProxigram(posSpecies,pos,vertices,bin) % pointCreateProxigram calculates a proxigram for the input 'vertices' % for the atoms in 'posSpecies', which are a subset of the atoms in 'pos' % with a bin width of 'bin'. % % INPUT % posSpecies: pos of the desired species, subset of initial pos % % pos: initial pos file with pos.x, pos.y, and pos.z % % vertices: vertices, m-by-n matrix, with m>3 % % bin: bin width in nm % % OUTPUT % proxi: concentration values of the desired species; y-values of % the proxigram % % binVector: corresponding distance values; x-values of the proxigram % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg vertices = vertices(:,1:3); %% tessellation and distance calculation % for overall pos file % finding closest point for each atomic position closest = dsearchn(vertices,delaunayn(vertices),[pos.x, pos.y, pos.z]); % vector from atom to closest vertex vec = [pos.x, pos.y, pos.z] - vertices(closest,1:3); dist = sqrt(sum(vec.^2,2)); % calculating bin centers binVector = linspace(0,10000*bin,10001); binVector = [fliplr(uminus(binVector(2:end))) binVector]; binVector(binVector<min(dist) | binVector>max(dist)) = []; % number of atoms per bin posHist = hist(dist,binVector); %% for element pos files closestS = dsearchn(vertices,delaunayn(vertices),[posSpecies.x, posSpecies.y, posSpecies.z]); distVecS = [posSpecies.x, posSpecies.y, posSpecies.z] - vertices(closestS,:); % vector from atom to closest vertex vecS = [posSpecies.x, posSpecies.y, posSpecies.z] - vertices(closestS,1:3); distS = sqrt(sum(distVecS.^2,2)); % number of atoms per bin proxi = hist(distS,binVector)./posHist; %% plotting f = figure; hold all; plot(binVector,proxi*100); set(gcf,'Name','proximity histogram'); set(gcf,'Color',[1 1 1]); set(get(gca,'XLabel'),'String','distance [nm]'); set(get(gca,'YLabel'),'String','concentration [%]');` | pointCreateProxigram calculates a proxigram for the input 'vertices' |
| `lineCreateProxigram` | `[proxi, binVector] = lineCreateProxigram(posSpecies,pos,line,bin) % lineCreateProxigram calculates a proxigram for the line object 'line' for % the atoms in 'posSpecies', which are a subset of the atoms in 'pos' with % a bin width of 'bin'. % % line is parsed as a struct with line.vertices (Nx3) and line.edges (Mx2) % % INPUT % posSpecies: pos of the desired species, subset of initial pos % % pos: initial pos file with pos.x, pos.y, and pos.z % % line: structure, with fields of vertices (Nx3) and edges (Mx2) % % bin: bin width in nm % % OUTPUT % proxi: concentration values of the desired species; y-values of % the proxigram % % binVector: corresponding distance values; x-values of the proxigram % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg % distances are calculated perpendicular to the line elements. lineVector = lineVectors(line.vertices,line.edges); %% tessellation and distance calculation % for overall pos file % finding closest point for each atomic position closest = dsearchn(line.vertices,delaunayn(line.vertices),[pos.x, pos.y, pos.z]); % vector from atom to closest vertex vec = [pos.x, pos.y, pos.z] - line.vertices(closest,1:3); vecLen = sqrt(sum(vec.^2,2)); %distance along line vector distLV = dot(vec, lineVector(closest,:), 2); %distance normal to line vector dist = sqrt(vecLen.^2 - distLV.^2); % calculating bin centers binVector = linspace(0,10000*bin,10001); binVector = [fliplr(uminus(binVector(2:end))) binVector]; binVector(binVector<min(dist) | binVector>max(dist)) = []; % number of atoms per bin posHist = hist(dist,binVector); %% for element pos files closestS = dsearchn(line.vertices,delaunayn(line.vertices),[posSpecies.x, posSpecies.y, posSpecies.z]); distVecS = [posSpecies.x, posSpecies.y, posSpecies.z] - line.vertices(closestS,:); % vector from atom to closest vertex vecS = [posSpecies.x, posSpecies.y, posSpecies.z] - line.vertices(closestS,1:3); vecLenS = sqrt(sum(vecS.^2,2)); %distance along line vector distLVS = dot(vecS, lineVector(closestS,:), 2); %distance normal to line vector distS = sqrt(vecLenS.^2 - distLVS.^2); % number of atoms per bin proxi = hist(distS,binVector)./posHist; %% plotting f = figure; hold all; plot(binVector,proxi*100); set(gcf,'Name','proximity histogram'); set(gcf,'Color',[1 1 1]); set(get(gca,'XLabel'),'String','distance [nm]'); set(get(gca,'YLabel'),'String','concentration [%]');` | lineCreateProxigram calculates a proxigram for the line object 'line' for |
| `patchCreateProxigram` | `[proxi, binVector] = patchCreateProxigram(posSpecies,pos,interface,bin) % patchCreateProxigram calculates a proxigram for the patch 'interface' % for the atoms in 'posSpecies', which are a subset of the atoms in 'pos' % with a bin width of 'bin'. % % [proxi, binVector] = patchCreateProxigram(posSpecies,pos,interface,bin) % % INPUT % posSpecies: pos of the desired species, subset of initial pos % % pos: initial pos file with pos.x, pos.y, and pos.z % % interface: structure with faces and vertices of the interface % % bin: bin width in nm % % OUTPUT % proxi: concentration values of the desired species; y-values of % the proxigram % % binVector: corresponding distance values; x-values of the proxigram % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg % distances are calculated along vertex normals. normals = patchnormals(interface); %% tessellation and distance calculation % for overall pos file % finding closest point for each atomic position closest = dsearchn(interface.vertices,delaunayn(interface.vertices),[pos.x, pos.y, pos.z]); distVec = [pos.x, pos.y, pos.z] - interface.vertices(closest,:); % distance through dot product dist = sum(normals(closest,:) .* distVec,2); % calculating bin centers binVector = linspace(0,10000*bin,10001); binVector = [fliplr(uminus(binVector(2:end))) binVector]; binVector(binVector<min(dist) | binVector>max(dist)) = []; % number of atoms per bin posHist = hist(dist,binVector); %% for element pos files closestS = dsearchn(interface.vertices,delaunayn(interface.vertices),[posSpecies.x, posSpecies.y, posSpecies.z]); distVecS = [posSpecies.x, posSpecies.y, posSpecies.z] - interface.vertices(closestS,:); % distance through dot product distS = sum(normals(closestS,:) .* distVecS,2); % number of atoms per bin proxi = hist(distS,binVector)./posHist; %% plotting f = figure; hold all; plot(binVector,proxi*100); set(gcf,'Name','proximity histogram'); set(gcf,'Color',[1 1 1]); set(get(gca,'XLabel'),'String','distance [nm]'); set(get(gca,'YLabel'),'String','concentration [%]'); end` | patchCreateProxigram calculates a proxigram for the patch 'interface' |
| `patchCreateInterfacialExcessMap` | `IEmap = patchCreateInterfacialExcessMap(pos,interface,lim,deloc) % NEEDS REWORK AND DOCUMENTATION % INPLEMENT BACKGROUND PICKING, INDIVIDUAL BACKGROUNDS % calculates an IE map for the patch 'interface' for the atoms in 'pos' % within 'lim' nm of the interface % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg DEBUG = false; %%reads a pos file [x,y,z] converted to a Matlab variable and a vertex file %%[x,y,z] and assigns every atom to the closest vertex. %vap: m y z mc vert# disttovert distalongnormal( or to line element) %shiftdistance %vertex: x y z obj# nx ny nz d A(or l) addpath('patch_normals'); %addpath('./general/resources/pos_tools'); addpath('dualMesh'); %addpath('resources'); normals = patchnormals(interface); %% tessellation and distance clipping numAtom = length(pos(:,1)); numVerts = length(interface.vertices); % finding closest point for each atomic position closest = dsearchn(interface.vertices,delaunayn(interface.vertices),pos(:,1:3)); distVec = pos(:,1:3) - interface.vertices(closest,:); %distance through dot product dist = sum(normals(closest,:) .* distVec,2); dist = abs(dist); %pos = pos(dist <= lim); closest = closest(dist<=lim); if DEBUG hist(dist,20); end IEcount = zeros(numVerts,1); for v = 1:numVerts % raw count of IE atoms per vertex IEcount(v) = sum(closest == v); end %% calculation of vertex area [cp,ce,pv,ev] = makedual2(interface.vertices,interface.faces); [pc,area] = geomdual2(cp,ce,pv,ev); IEmap = IEcount./area; %% delocalisation step if exist('deloc','var') for d = 1:deloc IEmap = delocalizeProperty(interface,IEmap); end end %IEmap = IEmap'; %% export to *.ply? %property gets normalized minIE = min(IEmap); maxIE = max(IEmap); limits = ['comment interfacial excess map ranges: ' num2str(minIE,3) ' at/nm2 to ' num2str(maxIE,3) ' at/nm2']; IEmapPly = IEmap - minIE; IEmapPly = IEmapPly/(maxIE-minIE); [file path] = uiputfile('*.ply','save quick IE map as ply','IEmap'); if file patch2ply(interface,[IEmapPly, IEmapPly, IEmapPly],[path file], limits); end %% visualising the results interface.facevertexcdata = IEmap; f = figure('Name','Interfacial excess map'); trisurf(interface.faces,interface.vertices(:,2),interface.vertices(:,1),interface.vertices(:,3),IEmap); axis equal; rotate3d on; shading interp; colorbar; end` | NEEDS REWORK AND DOCUMENTATION |
| `patchCreateExcessValue` | `patchCreateExcessValue(pos,parentPos,interface,vertices) % patchCreateExcessValue calculates the average interfacial excess for an % interface with an interactive interface for the interfacial excess % determination % reads a pos file (with x, y, and z) and a vertex file % with x, y, and z) and assigns every atom to the closest vertex % % patchCreateExcessValue(pos,parentPos,interface) % patchCreateExcessValue(pos,parentPos,interface,vertices) % % INPUT % pos: table, pos file of the atom species, of which an interfacial excess % should be calculated % % parentPos: table, pos file of all atom species; optimally all unranged % atoms are excluded % % interface: structure with fields of faces (f) and vertices (v) % % vertices: optional, if the interfacial excess of a specific region is % wanted % % (c) by Prof. Peter Felfer Group @FAU Erlangen-N�rnberg addpath('utilities_dualMesh'); addpath('utilities_patch_normals'); addpath('utilities'); normals = patchnormals(interface); numVerts = length(interface.vertices); %% tessellation and distance clipping % finding closest point for each atomic position closest = dsearchn(interface.vertices,delaunayn(interface.vertices),[parentPos.x, parentPos.y, parentPos.z]); % calculation of vertex area [cp,ce,pv,ev] = makedual2(interface.vertices,interface.faces); [pc,area] = geomdual2(cp,ce,pv,ev); % if local IE values are calculated, only atomic positions associated with % the vertices on the vertex list are used (if they are not empty) if nargin > 3 && ~isempty(vertices) isLocal = ismember(closest,vertices); parentPos = parentPos(isLocal,:); closest = closest(isLocal,:); area = area(vertices); end distVec = [parentPos.x, parentPos.y, parentPos.z] - interface.vertices(closest,:); % distance through dot product dist = sum(normals(closest,:) .* distVec,2); area = sum(area); %% calculating cumulative diagram % indices of atoms that are part of the species in question idx = ismember([parentPos.x, parentPos.y, parentPos.z],[pos.x, pos.y, pos.z],'rows'); [useless, sortIdx] = sort(dist); idx = idx(sortIdx); cumulative = cumsum(idx); %% index of interface location interfaceLoc = median(find(abs(dist(sortIdx)) == min(abs(dist)))); excessGUI(cumulative,area,interfaceLoc); end` | patchCreateExcessValue calculates the average interfacial excess for an |

---

## Cluster Analysis

| Function | Syntax | Description |
|----------|--------|-------------|
| `clusterDBSCAN` | `[clusterIdx, clusterInfo] = clusterDBSCAN(pos, epsilon, minPts, options) % CLUSTERDBSCAN Density-based spatial clustering for APT data % % [clusterIdx, clusterInfo] = clusterDBSCAN(pos, epsilon, minPts) % [clusterIdx, clusterInfo] = clusterDBSCAN(pos, epsilon, minPts, 'useGPU', true) % % Performs DBSCAN (Density-Based Spatial Clustering of Applications with % Noise) clustering on atom probe position data. Automatically uses GPU % acceleration when available with CPU fallback. % % INPUT: % pos - Nx3 array of atom positions [x, y, z] in nm % OR position table with x, y, z columns % epsilon - Neighborhood radius in nm (typical: 0.3-1.0 nm for APT) % minPts - Minimum points to form a cluster (typical: 5-20) % % OPTIONS: % 'useGPU' - Try to use GPU acceleration (default: true) % 'useParallel' - Use parallel processing for CPU (default: true) % 'soluteIdx' - Logical or index vector of solute atoms to cluster % (default: all atoms) % 'chunkSize' - Points per chunk for large datasets (default: 50000) % 'showProgress'- Show progress indicator (default: true) % 'algorithm' - 'kdtree' or 'bruteforce' (default: 'kdtree') % % OUTPUT: % clusterIdx - Nx1 array of cluster assignments % -1 = noise, 0 = not analyzed, 1,2,3... = cluster ID % clusterInfo - Structure with cluster statistics: % .nClusters - Number of clusters found % .nNoise - Number of noise points % .nClustered - Number of clustered points % .clusterSizes - Number of atoms per cluster % .clusterCenters - Centroid of each cluster [nClusters x 3] % .clusterRadii - Radius of gyration per cluster % .computeTime - Time taken for clustering % .method - 'GPU' or 'CPU' % % ALGORITHM: % DBSCAN groups points that are closely packed together, marking points % in low-density regions as outliers. Unlike k-means, it doesn't require % specifying the number of clusters and can find arbitrarily shaped clusters. % % EXAMPLES: % % Basic clustering of solute atoms % [idx, info] = clusterDBSCAN(pos, 0.5, 10); % % % Cluster only specific solute atoms (e.g., Cu in Fe matrix) % soluteIdx = strcmp(posTable.ion, 'Cu'); % [idx, info] = clusterDBSCAN(posTable, 0.6, 5, 'soluteIdx', soluteIdx); % % REFERENCES: % Ester et al. (1996) "A density-based algorithm for discovering clusters" % Marquis & Hyde (2010) "Applications of atom-probe tomography to the % characterisation of solute behaviours" % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments pos epsilon (1,1) double {mustBePositive} minPts (1,1) double {mustBePositive, mustBeInteger} options.useGPU (1,1) logical = true options.useParallel (1,1) logical = true options.soluteIdx = [] options.chunkSize (1,1) double {mustBePositive} = 50000 options.showProgress (1,1) logical = true options.algorithm (1,:) char {mustBeMember(options.algorithm, {'kdtree', 'bruteforce'})} = 'kdtree' end startTime = tic; % Handle table input if istable(pos) posArray = [pos.x, pos.y, pos.z]; else posArray = pos; end nPoints = size(posArray, 1); % Handle solute selection if ~isempty(options.soluteIdx) if islogical(options.soluteIdx) soluteIdx = options.soluteIdx; else soluteIdx = false(nPoints, 1); soluteIdx(options.soluteIdx) = true; end analyzeIdx = find(soluteIdx); posAnalyze = posArray(soluteIdx, :); else analyzeIdx = (1:nPoints)'; posAnalyze = posArray; end nAnalyze = size(posAnalyze, 1); % Initialize output clusterIdx = zeros(nPoints, 1); % 0 = not analyzed % Check GPU availability useGPU = options.useGPU && isGPUAvailable(); if useGPU try [labels, method] = dbscanGPU(posAnalyze, epsilon, minPts, options); catch ME warning('clusterDBSCAN:gpuFailed', ... 'GPU clustering failed: %s. Falling back to CPU.', ME.message); useGPU = false; end end if ~useGPU [labels, method] = dbscanCPU(posAnalyze, epsilon, minPts, options); end % Map results back to full position array clusterIdx(analyzeIdx) = labels; % Calculate cluster statistics computeTime = toc(startTime); clusterInfo = calculateClusterStats(posArray, clusterIdx, computeTime, method); if options.showProgress fprintf('DBSCAN complete: %d clusters found, %d noise points (%.2f s, %s)\n', ... clusterInfo.nClusters, clusterInfo.nNoise, computeTime, method); end end %% GPU Implementation function [labels, method] = dbscanGPU(pos, epsilon, minPts, options) % GPU-accelerated DBSCAN using distance matrix computation method = 'GPU'; nPoints = size(pos, 1); % Transfer to GPU posGPU = gpuArray(single(pos)); % For large datasets, process in chunks if nPoints > options.chunkSize labels = dbscanChunkedGPU(posGPU, epsilon, minPts, options); else % Compute distance matrix on GPU D = pdist2GPU(posGPU, posGPU); % Find neighbors within epsilon neighbors = D <= epsilon; % Perform DBSCAN on GPU labels = gather(dbscanCore(neighbors, minPts)); end end function D = pdist2GPU(X, Y) % Compute pairwise Euclidean distance on GPU % D(i,j) = ||X(i,:) - Y(j,:)|| X2 = sum(X.^2, 2); Y2 = sum(Y.^2, 2)'; D = sqrt(max(X2 + Y2 - 2 * (X * Y'), 0)); end function labels = dbscanChunkedGPU(posGPU, epsilon, minPts, options) % Process large datasets in chunks on GPU nPoints = size(posGPU, 1); nChunks = ceil(nPoints / options.chunkSize); % First pass: find core points using chunked distance computation corePoints = false(nPoints, 1); if options.showProgress fprintf('Pass 1: Identifying core points...\n'); end for i = 1:nChunks startIdx = (i-1) * options.chunkSize + 1; endIdx = min(i * options.chunkSize, nPoints); chunkPos = posGPU(startIdx:endIdx, :); % Count neighbors for this chunk against all points neighborCount = zeros(endIdx - startIdx + 1, 1, 'gpuArray'); for j = 1:nChunks jStart = (j-1) * options.chunkSize + 1; jEnd = min(j * options.chunkSize, nPoints); D = pdist2GPU(chunkPos, posGPU(jStart:jEnd, :)); neighborCount = neighborCount + sum(D <= epsilon, 2); end corePoints(startIdx:endIdx) = gather(neighborCount) >= minPts; end % Fall back to CPU for cluster assignment (complex graph operation) labels = assignClustersCPU(gather(posGPU), epsilon, corePoints, options); end %% CPU Implementation function [labels, method] = dbscanCPU(pos, epsilon, minPts, options) method = 'CPU'; nPoints = size(pos, 1); % Use MATLAB's built-in dbscan if available (R2019a+) if exist('dbscan', 'file') == 2 labels = dbscan(pos, epsilon, minPts); return; end % Custom implementation using k-d tree if strcmp(options.algorithm, 'kdtree') && nPoints > 1000 labels = dbscanKDTree(pos, epsilon, minPts, options); else labels = dbscanBruteForce(pos, epsilon, minPts, options); end end function labels = dbscanKDTree(pos, epsilon, minPts, options) % DBSCAN using k-d tree for efficient neighbor queries nPoints = size(pos, 1); % Build k-d tree tree = KDTreeSearcher(pos); % Find neighbors for all points neighborIdx = rangesearch(tree, pos, epsilon); % Identify core points neighborCounts = cellfun(@length, neighborIdx); corePoints = neighborCounts >= minPts; % Assign clusters labels = assignClustersCPU(pos, epsilon, corePoints, options, neighborIdx); end function labels = dbscanBruteForce(pos, epsilon, minPts, options) % Brute force DBSCAN for small datasets nPoints = size(pos, 1); % Compute full distance matrix D = pdist2(pos, pos); % Find neighbors neighbors = D <= epsilon; neighborCounts = sum(neighbors, 2); % Core points corePoints = neighborCounts >= minPts; % Initialize labels labels = zeros(nPoints, 1); clusterID = 0; visited = false(nPoints, 1); for i = 1:nPoints if visited(i) || ~corePoints(i) continue; end clusterID = clusterID + 1; [labels, visited] = expandCluster(i, neighbors, corePoints, labels, visited, clusterID); end % Mark remaining unvisited points as noise labels(~visited & labels == 0) = -1; end function labels = assignClustersCPU(pos, epsilon, corePoints, options, neighborIdx) % Assign clusters using pre-computed core points nPoints = size(pos, 1); if nargin < 5 % Need to compute neighbors tree = KDTreeSearcher(pos); neighborIdx = rangesearch(tree, pos, epsilon); end % Initialize labels = zeros(nPoints, 1); clusterID = 0; visited = false(nPoints, 1); corePointsIdx = find(corePoints); if options.showProgress && length(corePointsIdx) > 1000 prog = ProgressTracker(length(corePointsIdx), 'Assigning clusters'); end processedCores = 0; for i = corePointsIdx' if visited(i) continue; end clusterID = clusterID + 1; % BFS to find all connected points queue = i; visited(i) = true; labels(i) = clusterID; while ~isempty(queue) current = queue(1); queue(1) = []; currentNeighbors = neighborIdx{current}; for j = currentNeighbors if ~visited(j) visited(j) = true; labels(j) = clusterID; if corePoints(j) queue(end+1) = j; end end end end processedCores = processedCores + 1; if options.showProgress && length(corePointsIdx) > 1000 && mod(processedCores, 100) == 0 prog.update(processedCores); end end if options.showProgress && length(corePointsIdx) > 1000 prog.finish(); end % Mark noise labels(labels == 0) = -1; end function [labels, visited] = expandCluster(pointIdx, neighbors, corePoints, labels, visited, clusterID) % Expand cluster from a core point queue = pointIdx; visited(pointIdx) = true; labels(pointIdx) = clusterID; while ~isempty(queue) current = queue(1); queue(1) = []; currentNeighbors = find(neighbors(current, :)); for j = currentNeighbors if ~visited(j) visited(j) = true; labels(j) = clusterID; if corePoints(j) queue(end+1) = j; end end end end end function labels = dbscanCore(neighbors, minPts) % Core DBSCAN algorithm for GPU arrays nPoints = size(neighbors, 1); % Count neighbors neighborCounts = sum(neighbors, 2); corePoints = neighborCounts >= minPts; % Initialize labels on GPU labels = zeros(nPoints, 1, 'gpuArray'); clusterID = 0; visited = false(nPoints, 1, 'gpuArray'); for i = 1:nPoints if visited(i) || ~corePoints(i) continue; end clusterID = clusterID + 1; % Simple expansion (not optimal for GPU but works) stack = i; while ~isempty(stack) current = stack(end); stack(end) = []; if visited(current) continue; end visited(current) = true; labels(current) = clusterID; if corePoints(current) newNeighbors = find(gather(neighbors(current, :)) & ~gather(visited')); stack = [stack; newNeighbors(:)]; end end end labels(~visited) = -1; end %% Helper Functions function tf = isGPUAvailable() % Check if GPU is available for computation tf = false; try if exist('gpuDeviceCount', 'file') && gpuDeviceCount > 0 gpu = gpuDevice; % Check for sufficient memory (at least 1 GB) if gpu.AvailableMemory > 1e9 tf = true; end end catch tf = false; end end function clusterInfo = calculateClusterStats(pos, clusterIdx, computeTime, method) % Calculate cluster statistics clusterInfo = struct(); clusterInfo.computeTime = computeTime; clusterInfo.method = method; % Basic counts uniqueClusters = unique(clusterIdx); uniqueClusters = uniqueClusters(uniqueClusters > 0); % Exclude noise (-1) and unanalyzed (0) clusterInfo.nClusters = length(uniqueClusters); clusterInfo.nNoise = sum(clusterIdx == -1); clusterInfo.nClustered = sum(clusterIdx > 0); clusterInfo.nUnanalyzed = sum(clusterIdx == 0); % Per-cluster statistics if clusterInfo.nClusters > 0 clusterInfo.clusterSizes = zeros(clusterInfo.nClusters, 1); clusterInfo.clusterCenters = zeros(clusterInfo.nClusters, 3); clusterInfo.clusterRadii = zeros(clusterInfo.nClusters, 1); for i = 1:clusterInfo.nClusters cID = uniqueClusters(i); mask = clusterIdx == cID; clusterPos = pos(mask, :); clusterInfo.clusterSizes(i) = sum(mask); clusterInfo.clusterCenters(i, :) = mean(clusterPos, 1); % Radius of gyration centered = clusterPos - clusterInfo.clusterCenters(i, :); clusterInfo.clusterRadii(i) = sqrt(mean(sum(centered.^2, 2))); end else clusterInfo.clusterSizes = []; clusterInfo.clusterCenters = []; clusterInfo.clusterRadii = []; end end` | CLUSTERDBSCAN Density-based spatial clustering for APT data |
| `clusterDetermination` | `[clusterParameter, clusteredAtoms, clusterPosVol, randomVolumes] = clusterDetermination(clusterPos,pos,Nmin) %clusterDetermination calculates with the Voronoi tesselation and the %Delaunay triangulation the cluster of the given dataset % % [pass, Nmin, clusterCutoff, clusteredAtoms] = % clusterDetermination(clusterPos,pos,Nmin); % [pass, Nmin, clusterCutoff, clusteredAtoms] = % clusterDetermination(clusterPos,pos); % % INPUT % % clusterPos: pos file that contains the atoms that are in the clusters % pos: pos file of the entire dataset % Nmin: at this value, the cluster has a higher probability that it % it is clustered non-randomly than it's probability to be a random cluster % % OUTPUT % clusterParameter: table that contains the genereal cluster Parameter % the KolSmirTest (1 = passed that means that the voronoi volume distribution deviates from % random , 0 = failed), % the clusterPercentage, % Nmin (at this value, the cluster has a higher probability that it % it is clustered non-randomly than it's probability to be a % random cluster) and the % clusterCutOff Volume (max volume of the voronoi cell of the clustered atoms) % clusteredAtoms: pos file of the clustered atoms % clusterPosVol: clusterPos with an additional row that contain the % calculated VornoiVolumes of each cell % randomVolumes the randomly calculated Dataset and the corresponding % random Volume % % For more information read the paper: % Detecting and extracting clusters in atom probe data: A simple, automated % method using Voronoi cells, P. Felfer et al, Ultramicroscopy 150 (2015) % 30-36 %% check if Nmin is a given value if exist('Nmin','var') NminTmp = Nmin; end %% actual Voronoi cluster analysis figName = []; figName = ['Voronoi volume analysis of ' figName]; [numClustered, clusterCutOff, ~, experimentalVolumes, randomVolumes] = ... voronoiVolumeAnalysis(clusterPos, pos,true); figure; %% analysis of cluster sizes % experimental [clusterIdx, numClusters] = clusterIdentification(clusterPos,clusterCutOff,experimentalVolumes.expVol); % random [randomClusterIdx, randomNumClusters] = clusterIdentification(randomVolumes, clusterCutOff, randomVolumes.randVol); clusterSizes = histcounts(clusterIdx, numClusters); randomClusterSizes = histcounts(randomClusterIdx, randomNumClusters); Nmin = clusterSizeAnalyse(clusterSizes, randomClusterSizes); if exist('NminTmp','var') disp('Nmin override'); Nmin = NminTmp; end %% Kolmogorov - Smirnov test: significanceLimit = 1.92 / sqrt(height(clusterPos)) ; % *100 Martina: ich glaube das sollte weg sein sonst passt pass nicht mehr pass = (numClustered/height(clusterPos)) > significanceLimit; clusterPct = (numClustered/height(clusterPos)) * 100; if pass == 0 disp('the dataset FAILED the Kolmogorov-Smirnov test') else disp('the dataset PASSED the Kolmogorov-Smirnov test') end % significanceLimit; %% identifying clustered atoms significantClusterIdx = find(clusterSizes >= Nmin); % actually creating the atomic positions isClustered = ismember(clusterIdx,significantClusterIdx); isClusteredTable = table(clusterIdx(isClustered)', 'VariableNames', {'clusterIdx'}); clusteredAtoms = [clusterPos(isClustered,:), isClusteredTable]; clusterPosVol = addvars(clusterPos, experimentalVolumes.expVol); clusterParameter = table(pass, clusterPct, Nmin, clusterCutOff, 'VariableNames', {'KolSmir Test', 'clusterPct', 'Nmin', 'clusterCutOff'}); end` | clusterDetermination calculates with the Voronoi tesselation and the |
| `voronoiVolumeAnalysis` | `[numClustered, clusterCutoff, histCounts, experimentalVolumes, randomVolumes] = voronoiVolumeAnalysis(clusterPos, pos,vis,bins, Vmax) % voronoivolumeAnalysis calculates the Voronoi Volume for a given data set % % [numClustered clusterCutoff histCounts experimentalVolumes randomVolumes] % = voronoiVolumeAnalysisNEW(clusterPos, pos,vis,bins,Vmax); % [numClustered clusterCutoff histCounts experimentalVolumes randomVolumes] % = voronoiVolumeAnalysisNEW(clusterPos, pos,vis,bins); % [numClustered clusterCutoff histCounts experimentalVolumes randomVolumes] % = voronoiVolumeAnalysisNEW(clusterPos, pos,vis); %[numClustered clusterCutoff histCounts experimentalVolumes randomVolumes] % = voronoiVolumeAnalysisNEW(clusterPos, pos); % % INPUT % clusterPos: a pos file with the atoms that are in the cluster % pos: the parent pos file with all ions of the dataset % vis: true logical value for visualisation output % Vmax: maximum volume of % bins: the bin size for the histogram default 50 % % OUTPUT % numClustered: number of the cluster with max volume of clusterCutoff % clusterCutoff: max volume of the voronoi cell of the clustered atoms % experimental: histcounts of the experimental dataset % random: histcounts of the random dataset % experimentalVolumes: the voronoi volume of each atom of the experimental % dataset % randomVolumes: the voronoi volume of each atom of the random dataset % randpos: pos file of the random dataset %% check for a given bin number if ~exist('bins','var') bins = 50; end %% calculating the volume of the Voronoi cell of each atom vol = vertexVolume(clusterPos); for i = 1:2 if i == 1 % check if clusterCutoff is zero, if so, create a new random dataset %% calculating the volume of the Voronoi cells of a random sample of atoms randpos = pos(randsample(height(pos),height(clusterPos)),2:4); % random atoms from the dataset randVol = vertexVolume(randpos); %% determine maximum volume to plot to if ~exist('Vmax','var') VmaxE = median(vol); VmaxR = median(randVol); Vmax = max(VmaxE,VmaxR) * 3; end volHis = histcounts(vol(vol<Vmax),bins); % blue line volHisRand = histcounts(randVol(randVol<Vmax),bins); % green line emr = volHis - volHisRand; % emr is the difference between the random histogram and the experimental, red line cs = cumsum(emr); % cummulated sum of emr % beim random datensatz kann es passieren dass er größer ist als volHis % damit ist die kummulative Summe immer negativ und als numClustered kommt % zum Beispiel -7 raus wenn das an erster Stelle in der Tabelle steht, % dann wird ja die 1 von x gneommen und die ist immer null... % vllt verbot die eins zu nehmen von x? oder auswurf argument dass man die % zufälligen ionen neu berechnen soll ? %% determining the clustering parameters numClustered = max(cs); % find the max of the histogram mx = find(cs == numClustered,1); % calculate in which field of the histogram is the max value x = linspace(0,Vmax,bins); % create an x vector from 0 to the max value with the bins clusterCutoff = x(mx); end if clusterCutoff == 0 || clusterCutoff < min(randVol) i = 1; else i = 2; end end %% plotting if exist('vis','var') %plotting results figure plot(x,volHis,'LineWidth',2,'DisplayName','experimental','XDataSource','x','YDataSource','volHis'); hold on; plot(x,volHisRand,'g','LineWidth',2,'DisplayName','random','XDataSource','x','YDataSource','volHisRand'); %experimental - random hold on; plot(x,emr,'r','LineWidth',2,'DisplayName','experimental - random','XDataSource','x','YDataSource','emr'); legend('experimental','random','experimental - random'); xlabel('Voronoi volume of atom [nm3]'); ylabel('frequency [cts]'); %set(gca,'XLabel','Voronoi volume of atom [nm3]','YLabel','frequency [cts]'); set(gca,'YGrid','on'); set(gcf,'Color','w'); %clstTxt = ['clustering level: ' num2str(numClustered/length(clusterPos)*100,3) '%']; %text(0,0,clstTxt); end %% set outputs histCounts = table(volHis', volHisRand'); histCounts.Properties.VariableNames = {'experimental', 'random'}; experimentalVolumes = table(vol',clusterPos.x, clusterPos.y, clusterPos.z); experimentalVolumes.Properties.VariableNames = {'expVol', 'x', 'y', 'z'}; randomVolumes = table(randVol', randpos.x, randpos.y, randpos.z); randomVolumes.Properties.VariableNames = {'randVol', 'x', 'y', 'z'}; end` | voronoivolumeAnalysis calculates the Voronoi Volume for a given data set |
| `clusterIdentification` | `[clusterIdx, numClusters] = clusterIdentification(clusterPos,volThreshORpos,volVoronoi,posDelaunay) % clusterIdentification calculates the number of clusters and their % corresponding cluster Index after Voronoi Tesselation and Dealaunay % triangulation % % [clusterIdx, numClusters] = % clusterIdentification(clusterPos,volThreshORpos,volVoronoi,posDelaunay); % [clusterIdx, numClusters] = % clusterIdentification(clusterPos,volThreshORpos,volVoronoi); % [clusterIdx, numClusters] = % clusterIdentification(clusterPos,volThreshORpos); % % INPUT % clusterPos: a pos file with the atoms that are in the cluster % volThreshORpos: is the clusterCutoff calculated by the voronoiVolume % Analysis or a pos file containing the entire data set; % volVoronoi: the voronoi volume of the atoms from clusterPos % posDelaunay: delaunay triangulation of the clusterPos data set, is a mx4 % matrix that defines the tetrahedron % % OUTPUT % clusterIdx: is a vector with the corresponding cluster number for % each clustered atom % numClusters: total number of clusters %% check for inputs if ~exist('volVoronoi','var') volVoronoi = vertexVolume(clusterPos); end if~exist('posDelaunay','var') posDelaunay = delaunay([clusterPos.x clusterPos.y clusterPos.z]); end % patchDelaunay = tetramesh(posDelaunay,[clusterPos.x clusterPos.y % clusterPos.z]); % visualisation of the triangles %% checking if the volume threshold is defined. If not, it is calculated if size(volThreshORpos) == [1,1] volThresh = volThreshORpos; else [~, volThresh] = voronoiVolumeAnalysis(clusterPos,volThreshORpos); end clear volThreshORpos; %% defining the clustered atoms and calculating the Delaunay triangulation clusteredAtomsIndices = find(volVoronoi<=volThresh); %% determining in the delaunay triangulation which atoms are clustered and to which cluster they belong delAdjacency = delaunayToAdjacencyMat(posDelaunay,clusteredAtomsIndices); %[numClusters clusterIdx] = graphconncomp(delAdjacency,'Directed',false); [numClusters, clusterIdx] = conncomp(delAdjacency); end` | clusterIdentification calculates the number of clusters and their |
| `clusterSizeAnalyse` | `Nmin = clusterSizeAnalyse(expClusterSizes,ranClusterSizes) % clusterSizeAnalyse plotts the cluster sizes as a histogram % the y axis is the 'concentration' the occurences. This is the invertse of % the 1d voronoi tessellation of the occurences, or N for N occurences % of the same value. % % % % INPUT % expClusterSizes: experimental cluster sizes % ranClustersizes: random cluster sizes % % OUTPUT % Nmin: at this value, the cluster has a higher probability that it % it is clustered non-randomly than it's probability to be a % random cluster %% experimental cluster sizes expClusterSizes = sort(expClusterSizes); uniqueSizes = unique(expClusterSizes); for idx = 1:length(uniqueSizes) multiplicity(idx) = sum(expClusterSizes == uniqueSizes(idx)); end dist = uniqueSizes(2:end) - uniqueSizes(1:end-1); domainSize = [dist(1) (dist(1:end-1)+dist(2:end))/2 dist(end)]; y = multiplicity./domainSize; %% random cluster sizes ranClusterSizes = sort(ranClusterSizes); r_uniqueSizes = unique(ranClusterSizes); for idx = 1:length(r_uniqueSizes) r_multiplicity(idx) = sum(ranClusterSizes == r_uniqueSizes(idx)); end r_dist = r_uniqueSizes(2:end) - r_uniqueSizes(1:end-1); r_domainSize = [r_dist(1) (r_dist(1:end-1)+r_dist(2:end))/2 r_dist(end)]; r_y = r_multiplicity./r_domainSize; %% plot levels at which 50% of all clusters are non-random. plot_limit = 0.5; % the sum of both curves, starting at N = 2: for N = 2: max(max(uniqueSizes),max(r_uniqueSizes)) ex = y(uniqueSizes == N); if isempty(ex) ex = 0; end rand = r_y(r_uniqueSizes == N); if isempty(rand) rand =0; end ex_curve(N) = ex * N; rand_curve(N) = rand * N; end rand_cumulative = cumsum(rand_curve); ex_cumulative = cumsum(ex_curve); ratio = ex_curve./rand_curve; ratio(1) = 1; %% definfing Nmin as 50% threshold pct = 1/(1 - plot_limit); t_lim = find(ratio > pct); if ~isempty(t_lim) plot_limits_N = min(t_lim); else plot_limits_N = 1; end max_y = max(max(y(2:end)),max(r_y(2:end))); %since we were starting at N = 2: plot_limits_N = plot_limits_N + 1; Nmin = plot_limits_N; %% classification errors % classification error for clustered atoms: %classErr_clust = (ex_cumulative(Nmin)-rand_cumulative(Nmin))/ex_cumulative(end); % classification error for unclustered atoms %classErr_rand = (rand_cumulative(end)-rand_cumulative(Nmin))/ex_cumulative(end); %% plotting plot(uniqueSizes(2:end),y(2:end).*uniqueSizes(2:end),'-k','LineWidth',2,'Marker','o'); hold on plot(r_uniqueSizes(2:end),r_y(2:end).*r_uniqueSizes(2:end),':k','LineWidth',2); set(gca,'YScale','log'); set(gca,'XScale','log'); set(gcf,'Color','w'); xlabel('cluster size [atoms]'); ylabel('frequency [cts]'); leg = "Nmin = " + string(Nmin); stem(plot_limits_N,max_y,'-r','LineWidth',2,'Marker','none'); legend('cluster size distribution','cluster size distribution (randomized)', leg);` | clusterSizeAnalyse plotts the cluster sizes as a histogram |

---

## Spatial Statistics

| Function | Syntax | Description |
|----------|--------|-------------|
| `spatialStatistics` | `stats = spatialStatistics(pos, options) % SPATIALSTATISTICS Compute spatial distribution statistics for APT data % % stats = spatialStatistics(pos) % stats = spatialStatistics(pos, 'rdfMaxR', 5) % % Calculates various spatial statistics including radial distribution % function (RDF/pair correlation), nearest neighbor distribution, and % K-function (Ripley's K) for analyzing clustering and ordering. % % INPUT: % pos - Nx3 array of atom positions [x, y, z] in nm % OR position table with x, y, z columns % % OPTIONS: % 'rdfMaxR' - Maximum radius for RDF in nm (default: 3) % 'rdfBinWidth' - Bin width for RDF in nm (default: 0.05) % 'nnMaxK' - Maximum k for k-th nearest neighbor (default: 10) % 'sampleSize' - Points to sample for large datasets (default: 50000) % 'reference' - Reference positions for cross-RDF (default: same as pos) % 'edgeCorrection' - Apply edge correction (default: true) % 'showProgress' - Show progress bar (default: true) % 'computeRDF' - Compute RDF (default: true) % 'computeNN' - Compute nearest neighbor (default: true) % 'computeK' - Compute Ripley's K (default: true) % % OUTPUT: % stats - Structure containing: % .rdf - Radial distribution function % .r - Radii (bin centers) % .g - g(r) values % .gError - Standard error of g(r) % .nPairs - Number of pairs per bin % .nn - Nearest neighbor statistics % .k - Neighbor order (1st, 2nd, ..., k-th) % .meanDist - Mean distance to k-th neighbor % .stdDist - Standard deviation % .histogram - Distribution of distances for each k % .ripley - Ripley's K function % .r - Radii % .K - K(r) values % .L - L(r) = sqrt(K(r)/pi) - r (linearized) % .Ktheory - Theoretical K for random (CSR) % .density - Local density estimate % .nPoints - Number of points analyzed % % THEORY: % RDF g(r): Probability of finding an atom at distance r relative to % a uniform random distribution. g(r) = 1 for random, >1 for clustering, % <1 for ordering/repulsion. % % Nearest neighbor: In a random (Poisson) distribution, the mean % nearest neighbor distance is d_nn = 0.554 * rho^(-1/3) % % EXAMPLES: % % Basic analysis % stats = spatialStatistics(pos); % plot(stats.rdf.r, stats.rdf.g); % % % Cross-RDF between two species % stats = spatialStatistics(posFe, 'reference', posCu); % % REFERENCES: % Moody et al. (2009) Ultramicroscopy % Philippe et al. (2009) Ultramicroscopy % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments pos options.rdfMaxR (1,1) double {mustBePositive} = 3 options.rdfBinWidth (1,1) double {mustBePositive} = 0.05 options.nnMaxK (1,1) double {mustBePositive, mustBeInteger} = 10 options.sampleSize (1,1) double {mustBePositive} = 50000 options.reference = [] options.edgeCorrection (1,1) logical = true options.showProgress (1,1) logical = true options.computeRDF (1,1) logical = true options.computeNN (1,1) logical = true options.computeK (1,1) logical = true end % Handle table input if istable(pos) posArray = [pos.x, pos.y, pos.z]; else posArray = pos; end nPoints = size(posArray, 1); % Handle reference positions (for cross-RDF) if isempty(options.reference) refArray = posArray; crossCorrelation = false; else if istable(options.reference) refArray = [options.reference.x, options.reference.y, options.reference.z]; else refArray = options.reference; end crossCorrelation = true; end % Sample if dataset is large if nPoints > options.sampleSize sampleIdx = randperm(nPoints, options.sampleSize); posAnalyze = posArray(sampleIdx, :); if options.showProgress fprintf('Sampling %d of %d points for analysis\n', options.sampleSize, nPoints); end else posAnalyze = posArray; end nAnalyze = size(posAnalyze, 1); % Calculate bounding box and density minPos = min(posArray, [], 1); maxPos = max(posArray, [], 1); boxSize = maxPos - minPos; volume = prod(boxSize); density = nPoints / volume; % Initialize output stats = struct(); stats.nPoints = nPoints; stats.density = density; stats.volume = volume; stats.boxSize = boxSize; % Radial Distribution Function if options.computeRDF if options.showProgress fprintf('Computing radial distribution function...\n'); end stats.rdf = computeRDF(posAnalyze, refArray, density, options); end % Nearest Neighbor Distribution if options.computeNN if options.showProgress fprintf('Computing nearest neighbor statistics...\n'); end stats.nn = computeNearestNeighbor(posAnalyze, options); end % Ripley's K Function if options.computeK if options.showProgress fprintf('Computing Ripley''s K function...\n'); end stats.ripley = computeRipleyK(posAnalyze, density, volume, boxSize, options); end if options.showProgress fprintf('Spatial statistics complete.\n'); end end %% Radial Distribution Function function rdf = computeRDF(pos, ref, density, options) % Compute g(r) using histogram of pairwise distances nPos = size(pos, 1); nRef = size(ref, 1); % Define bins edges = 0:options.rdfBinWidth:options.rdfMaxR; r = edges(1:end-1) + options.rdfBinWidth/2; % Bin centers nBins = length(r); % Compute pairwise distances in chunks to manage memory chunkSize = min(1000, nPos); nChunks = ceil(nPos / chunkSize); counts = zeros(1, nBins); nPairsTotal = 0; for i = 1:nChunks startIdx = (i-1)*chunkSize + 1; endIdx = min(i*chunkSize, nPos); chunkPos = pos(startIdx:endIdx, :); % Distance to reference points D = pdist2(chunkPos, ref); % Exclude self-distances if same dataset if isequal(pos, ref) selfIdx = startIdx:endIdx; for j = 1:size(chunkPos, 1) D(j, selfIdx(j)) = NaN; end end % Apply maximum distance cutoff D(D > options.rdfMaxR) = NaN; % Histogram validD = D(~isnan(D)); counts = counts + histcounts(validD, edges); nPairsTotal = nPairsTotal + numel(validD); end % Normalize to get g(r) % Expected count in shell: N * rho * 4*pi*r^2*dr shellVolumes = 4/3 * pi * (edges(2:end).^3 - edges(1:end-1).^3); expectedCounts = nPos * density * shellVolumes; g = counts ./ expectedCounts; % Edge correction (simple approach - reduce by fraction of shell inside box) if options.edgeCorrection % Approximate correction factor for i = 1:nBins % Fraction of shell that might be outside edgeFrac = min(1, min(options.boxSize) / (2*r(i))); g(i) = g(i) / edgeFrac; end end % Standard error (assuming Poisson statistics) gError = g ./ sqrt(max(counts, 1)); rdf = struct(); rdf.r = r; rdf.g = g; rdf.gError = gError; rdf.nPairs = counts; rdf.binWidth = options.rdfBinWidth; end %% Nearest Neighbor Statistics function nn = computeNearestNeighbor(pos, options) % Compute k-th nearest neighbor distances nPos = size(pos, 1); maxK = min(options.nnMaxK, nPos - 1); % Use k-d tree for efficient neighbor search tree = KDTreeSearcher(pos); % Find k+1 nearest neighbors (includes self) [~, D] = knnsearch(tree, pos, 'K', maxK + 1); % Remove self-distance (first column) D = D(:, 2:end); % Statistics for each k nn = struct(); nn.k = (1:maxK)'; nn.meanDist = mean(D, 1)'; nn.stdDist = std(D, 0, 1)'; nn.medianDist = median(D, 1)'; nn.minDist = min(D, [], 1)'; nn.maxDist = max(D, [], 1)'; % Distribution histograms for first few neighbors nn.histogram = struct(); for k = 1:min(5, maxK) edges = linspace(0, max(D(:,k))*1.1, 50); nn.histogram(k).edges = edges; nn.histogram(k).counts = histcounts(D(:,k), edges); nn.histogram(k).k = k; end % Theoretical values for random (Poisson) distribution % Mean k-th NN distance: Gamma(k+1/3) / (Gamma(k) * (4*pi*rho/3)^(1/3)) density = nPos / prod(range(pos)); nn.theoretical = struct(); nn.theoretical.density = density; nn.theoretical.meanFirst = 0.554 * density^(-1/3); % Mean 1st NN for random % Compare to random nn.clusteringIndex = nn.theoretical.meanFirst ./ nn.meanDist(1); % >1 suggests clustering, <1 suggests ordering end %% Ripley's K Function function ripley = computeRipleyK(pos, density, volume, boxSize, options) % Compute Ripley's K function nPos = size(pos, 1); % Radii to evaluate r = linspace(0.1, options.rdfMaxR, 30); K = zeros(size(r)); % Build k-d tree tree = KDTreeSearcher(pos); % Count neighbors within each radius for i = 1:length(r) [~, D] = rangesearch(tree, pos, r(i)); neighborCounts = cellfun(@length, D) - 1; % Subtract self % Edge correction (Ripley's isotropic correction approximation) if options.edgeCorrection % Simple correction: weight by fraction inside box weights = edgeCorrectionWeights(pos, r(i), boxSize); K(i) = sum(neighborCounts ./ weights) / nPos / density; else K(i) = mean(neighborCounts) / density; end end % Theoretical K for Complete Spatial Randomness (CSR) Ktheory = 4/3 * pi * r.^3; % L function (variance-stabilized) L = (3 * K / (4*pi)).^(1/3) - r; ripley = struct(); ripley.r = r; ripley.K = K; ripley.L = L; ripley.Ktheory = Ktheory; % Deviation from CSR ripley.Lmax = max(abs(L)); ripley.clusteringDetected = ripley.Lmax > 0.5; % Rule of thumb threshold end function weights = edgeCorrectionWeights(pos, r, boxSize) % Compute edge correction weights for each point % Weight = 1 / (fraction of sphere inside box) nPos = size(pos, 1); weights = ones(nPos, 1); for i = 1:nPos % Distance to each face distToMin = pos(i, :); distToMax = boxSize - pos(i, :); % Minimum distance to any edge minDist = min([distToMin, distToMax]); if minDist < r % Approximate: fraction of sphere inside % Simple approximation using cap formula frac = 1; for d = 1:3 if distToMin(d) < r h = r - distToMin(d); capFrac = (h^2 * (3*r - h)) / (4*r^3); frac = frac * (1 - capFrac); end if distToMax(d) < r h = r - distToMax(d); capFrac = (h^2 * (3*r - h)) / (4*r^3); frac = frac * (1 - capFrac); end end weights(i) = max(frac, 0.1); % Avoid division by very small numbers end end end function r = range(x) r = max(x) - min(x); end` | SPATIALSTATISTICS Compute spatial distribution statistics for APT data |
| `spatialDistributionMap` | `sdm = spatialDistributionMap(points,binSize,radius) %calculates a 3d spatial distribution map for the 'points', with a bin size of % 'binSize'. After Geiser et al. DOI: 10.1017/S1431927607070948 %%unfinished %% overlay all 3d distributions all = repmat(points(:,1:3),1,1,length(points)); offset = repmat(reshape(points(:,1:3),1,3,length(points)),length(points),1,1); sdmPoints = all - offset; sdm = reshape(sdmPoints,length(points)^2,3,1);` | calculates a 3d spatial distribution map for the 'points', with a bin size of |
| `dataQualityMetrics` | `metrics = dataQualityMetrics(pos, options) % DATAQUALITYMETRICS Assess reconstruction quality and data integrity % % metrics = dataQualityMetrics(pos) % metrics = dataQualityMetrics(pos, 'mass', mass) % % Computes various metrics to assess the quality of APT data and % reconstruction, including spatial resolution estimates, density % variations, and detection artifacts. % % INPUT: % pos - Nx3 array of atom positions [x, y, z] in nm % OR position table with x, y, z columns (and optionally mass, tof) % % OPTIONS: % 'mass' - Mass-to-charge values (for mass spectrum quality) % 'tof' - Time-of-flight values % 'detectionEfficiency' - Known detection efficiency (default: estimate) % 'voxelSize' - Voxel size for density analysis in nm (default: 1) % 'showPlots' - Generate diagnostic plots (default: false) % 'atomicVolume' - Expected atomic volume in nm^3 (default: 0.012) % % OUTPUT: % metrics - Structure containing: % .summary - Overall quality assessment string % .resolution - Spatial resolution estimates % .lateral - Estimated lateral resolution (nm) % .depth - Estimated depth resolution (nm) % .method - Method used for estimation % .density - Density analysis % .mean - Mean atomic density (atoms/nm^3) % .std - Standard deviation of local density % .cv - Coefficient of variation % .expected - Expected density based on atomic volume % .efficiency - Estimated detection efficiency % .geometry - Specimen geometry % .boundingBox - [minX minY minZ; maxX maxY maxZ] % .dimensions - [lengthX lengthY lengthZ] % .volume - Analyzed volume (nm^3) % .aspectRatio - Aspect ratios % .artifacts - Artifact detection % .densityHoles - Suspected low-density regions % .densitySpikes - Suspected high-density artifacts % .trajectoryOverlap - Detected trajectory overlap % .massSpectrum - Mass spectrum quality (if mass provided) % .peakToBackground - Peak to background ratio % .massResolution - Estimated mass resolution % .thermalTails - Thermal tail assessment % % EXAMPLES: % % Basic quality check % metrics = dataQualityMetrics(pos); % disp(metrics.summary); % % % With mass spectrum analysis % metrics = dataQualityMetrics(posTable, 'mass', posTable.mc, 'showPlots', true); % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments pos options.mass = [] options.tof = [] options.detectionEfficiency = [] options.voxelSize (1,1) double {mustBePositive} = 1 options.showPlots (1,1) logical = false options.atomicVolume (1,1) double {mustBePositive} = 0.012 end % Handle table input if istable(pos) posArray = [pos.x, pos.y, pos.z]; if isempty(options.mass) && ismember('mc', pos.Properties.VariableNames) options.mass = pos.mc; end else posArray = pos; end nAtoms = size(posArray, 1); % Initialize metrics structure metrics = struct(); metrics.nAtoms = nAtoms; %% Geometry Analysis fprintf('Analyzing geometry...\n'); metrics.geometry = analyzeGeometry(posArray); %% Density Analysis fprintf('Analyzing density distribution...\n'); metrics.density = analyzeDensity(posArray, options); %% Resolution Estimation fprintf('Estimating spatial resolution...\n'); metrics.resolution = estimateResolution(posArray, metrics.density); %% Artifact Detection fprintf('Checking for artifacts...\n'); metrics.artifacts = detectArtifacts(posArray, metrics.density, options); %% Mass Spectrum Quality (if available) if ~isempty(options.mass) fprintf('Analyzing mass spectrum quality...\n'); metrics.massSpectrum = analyzeMassSpectrum(options.mass); end %% Generate Summary metrics.summary = generateSummary(metrics); %% Optional Plots if options.showPlots generateDiagnosticPlots(posArray, metrics, options); end end %% Geometry Analysis function geom = analyzeGeometry(pos) geom = struct(); % Bounding box minPos = min(pos, [], 1); maxPos = max(pos, [], 1); geom.boundingBox = [minPos; maxPos]; geom.dimensions = maxPos - minPos; geom.center = (minPos + maxPos) / 2; % Volume (convex hull for better estimate) try [~, geom.convexHullVolume] = convhull(pos); catch geom.convexHullVolume = prod(geom.dimensions); end geom.boundingBoxVolume = prod(geom.dimensions); % Aspect ratios sortedDims = sort(geom.dimensions, 'descend'); geom.aspectRatio = sortedDims(1) / sortedDims(3); geom.xyAspectRatio = geom.dimensions(1) / geom.dimensions(2); % Estimate tip radius (assuming conical specimen) % Typical APT specimen is conical, widening with depth (z) zLevels = linspace(minPos(3), maxPos(3), 20); radii = zeros(length(zLevels)-1, 1); for i = 1:length(zLevels)-1 mask = pos(:,3) >= zLevels(i) & pos(:,3) < zLevels(i+1); if sum(mask) > 10 xyPos = pos(mask, 1:2); radii(i) = sqrt(mean(sum((xyPos - mean(xyPos)).^2, 2))); end end geom.estimatedTipRadius = mean(radii(radii > 0)); geom.radiusVariation = std(radii(radii > 0)) / mean(radii(radii > 0)); end %% Density Analysis function dens = analyzeDensity(pos, options) dens = struct(); % Calculate local density using 3D histogram voxelSize = options.voxelSize; minPos = min(pos, [], 1); maxPos = max(pos, [], 1); % Create voxel grid nVoxels = ceil((maxPos - minPos) / voxelSize); nVoxels = max(nVoxels, 1); edges = cell(3, 1); for d = 1:3 edges{d} = linspace(minPos(d), maxPos(d), nVoxels(d)+1); end % Count atoms per voxel [counts, ~] = histcounts2(pos(:,1), pos(:,2), edges{1}, edges{2}); voxelVolume = voxelSize^3; % 3D density map density3D = zeros(nVoxels); for i = 1:nVoxels(1) for j = 1:nVoxels(2) zMask = pos(:,1) >= edges{1}(i) & pos(:,1) < edges{1}(i+1) & ... pos(:,2) >= edges{2}(j) & pos(:,2) < edges{2}(j+1); for k = 1:nVoxels(3) mask = zMask & pos(:,3) >= edges{3}(k) & pos(:,3) < edges{3}(k+1); density3D(i,j,k) = sum(mask) / voxelVolume; end end end % Statistics (excluding empty edge voxels) validDensity = density3D(density3D > 0); dens.map3D = density3D; dens.voxelSize = voxelSize; dens.mean = mean(validDensity); dens.std = std(validDensity); dens.median = median(validDensity); dens.cv = dens.std / dens.mean; % Coefficient of variation % Expected density from atomic volume dens.expected = 1 / options.atomicVolume; % Estimate detection efficiency if isempty(options.detectionEfficiency) dens.estimatedEfficiency = dens.mean / dens.expected; else dens.estimatedEfficiency = options.detectionEfficiency; end % Density profile along z (depth) zBins = linspace(minPos(3), maxPos(3), 50); dens.depthProfile = struct(); dens.depthProfile.z = zBins(1:end-1) + diff(zBins)/2; dens.depthProfile.density = zeros(length(zBins)-1, 1); for i = 1:length(zBins)-1 mask = pos(:,3) >= zBins(i) & pos(:,3) < zBins(i+1); sliceVolume = (maxPos(1)-minPos(1)) * (maxPos(2)-minPos(2)) * (zBins(i+1)-zBins(i)); dens.depthProfile.density(i) = sum(mask) / sliceVolume; end end %% Resolution Estimation function res = estimateResolution(pos, density) res = struct(); % Method 1: From density and expected NN distance % In a perfect crystal, atoms are at regular spacing % Resolution ~ deviation from ideal positions % Nearest neighbor analysis nSample = min(size(pos, 1), 10000); sampleIdx = randperm(size(pos, 1), nSample); posSample = pos(sampleIdx, :); tree = KDTreeSearcher(posSample); [~, D] = knnsearch(tree, posSample, 'K', 2); nnDist = D(:, 2); % Expected NN distance for random distribution expectedNN = 0.554 * density.mean^(-1/3); % Lateral resolution estimate (from NN distribution width) res.lateral = std(nnDist); res.depth = res.lateral * 0.3; % Typically better depth resolution % Method 2: From density fluctuations res.fromDensityCV = density.cv * expectedNN; res.method = 'nearest_neighbor_statistics'; res.expectedNN = expectedNN; res.meanNN = mean(nnDist); res.stdNN = std(nnDist); % Quality indicator res.qualityIndex = res.meanNN / expectedNN; % ~1 for good reconstruction end %% Artifact Detection function art = detectArtifacts(pos, density, options) art = struct(); % Low density regions (potential holes/voids) lowThreshold = density.mean * 0.3; art.densityHoles = struct(); art.densityHoles.count = sum(density.map3D(:) < lowThreshold & density.map3D(:) > 0); art.densityHoles.fraction = art.densityHoles.count / numel(density.map3D); art.densityHoles.threshold = lowThreshold; % High density spikes (potential trajectory overlap) highThreshold = density.mean * 3; art.densitySpikes = struct(); art.densitySpikes.count = sum(density.map3D(:) > highThreshold); art.densitySpikes.fraction = art.densitySpikes.count / numel(density.map3D); art.densitySpikes.threshold = highThreshold; % Trajectory overlap detection (multiple hits) % Check for atoms with very small separation nSample = min(size(pos, 1), 20000); sampleIdx = randperm(size(pos, 1), nSample); posSample = pos(sampleIdx, :); tree = KDTreeSearcher(posSample); [~, D] = knnsearch(tree, posSample, 'K', 2); nnDist = D(:, 2); overlapThreshold = 0.05; % nm, very close atoms suggest overlap art.trajectoryOverlap = struct(); art.trajectoryOverlap.count = sum(nnDist < overlapThreshold); art.trajectoryOverlap.fraction = art.trajectoryOverlap.count / nSample; art.trajectoryOverlap.threshold = overlapThreshold; % Overall artifact score (0-1, lower is better) art.overallScore = (art.densityHoles.fraction * 0.3 + ... art.densitySpikes.fraction * 0.3 + ... art.trajectoryOverlap.fraction * 0.4); end %% Mass Spectrum Quality function ms = analyzeMassSpectrum(mass) ms = struct(); % Basic histogram edges = 0:0.01:max(mass)*1.1; counts = histcounts(mass, edges); centers = edges(1:end-1) + 0.005; % Find peaks [pks, locs] = findpeaks(counts, 'MinPeakHeight', max(counts)*0.01, ... 'MinPeakDistance', 10); ms.nPeaks = length(pks); ms.peakPositions = centers(locs); ms.peakHeights = pks; % Background estimation (moving minimum) windowSize = 100; background = movmin(counts, windowSize); % Peak to background ratio if ~isempty(pks) bgAtPeaks = background(locs); ms.peakToBackground = mean(pks ./ max(bgAtPeaks, 1)); else ms.peakToBackground = 0; end % Mass resolution estimate (FWHM of major peak) if ~isempty(pks) [~, maxPeakIdx] = max(pks); peakPos = locs(maxPeakIdx); % Find FWHM halfMax = pks(maxPeakIdx) / 2; leftIdx = find(counts(1:peakPos) < halfMax, 1, 'last'); rightIdx = peakPos + find(counts(peakPos:end) < halfMax, 1, 'first') - 1; if ~isempty(leftIdx) && ~isempty(rightIdx) fwhm = centers(rightIdx) - centers(leftIdx); ms.massResolution = centers(peakPos) / fwhm; ms.fwhm = fwhm; else ms.massResolution = NaN; ms.fwhm = NaN; end else ms.massResolution = NaN; ms.fwhm = NaN; end % Thermal tail assessment (asymmetry of peaks) ms.tailAssessment = 'Not implemented'; end %% Summary Generation function summary = generateSummary(metrics) issues = {}; quality = 'Good'; % Check density if metrics.density.cv > 0.5 issues{end+1} = 'High density variation (CV > 0.5)'; quality = 'Fair'; end % Check artifacts if metrics.artifacts.overallScore > 0.1 issues{end+1} = sprintf('Artifacts detected (score: %.2f)', metrics.artifacts.overallScore); quality = 'Fair'; end if metrics.artifacts.trajectoryOverlap.fraction > 0.01 issues{end+1} = 'Significant trajectory overlap detected'; quality = 'Poor'; end % Check resolution if metrics.resolution.lateral > 0.5 issues{end+1} = sprintf('Limited lateral resolution (~%.2f nm)', metrics.resolution.lateral); end % Check geometry if metrics.geometry.aspectRatio > 10 issues{end+1} = 'Highly elongated specimen geometry'; end % Build summary string summary = sprintf('=== Data Quality Assessment ===\n'); summary = [summary, sprintf('Overall Quality: %s\n', quality)]; summary = [summary, sprintf('Atoms: %d\n', metrics.nAtoms)]; summary = [summary, sprintf('Volume: %.0f nm^3\n', metrics.geometry.convexHullVolume)]; summary = [summary, sprintf('Mean density: %.1f atoms/nm^3\n', metrics.density.mean)]; summary = [summary, sprintf('Est. detection efficiency: %.0f%%\n', metrics.density.estimatedEfficiency * 100)]; summary = [summary, sprintf('Est. lateral resolution: %.2f nm\n', metrics.resolution.lateral)]; if ~isempty(issues) summary = [summary, sprintf('\nIssues detected:\n')]; for i = 1:length(issues) summary = [summary, sprintf(' - %s\n', issues{i})]; end else summary = [summary, sprintf('\nNo significant issues detected.\n')]; end end %% Diagnostic Plots function generateDiagnosticPlots(pos, metrics, options) figure('Position', [100 100 1200 800], 'Name', 'Data Quality Diagnostics'); % 1. Density histogram subplot(2,3,1); validDensity = metrics.density.map3D(metrics.density.map3D > 0); histogram(validDensity, 50, 'Normalization', 'pdf'); hold on; xline(metrics.density.mean, 'r-', 'LineWidth', 2); xline(metrics.density.expected, 'g--', 'LineWidth', 2); xlabel('Local density (atoms/nm^3)'); ylabel('Probability'); title('Density Distribution'); legend('Data', 'Mean', 'Expected', 'Location', 'best'); % 2. Density along depth subplot(2,3,2); plot(metrics.density.depthProfile.z, metrics.density.depthProfile.density, 'b-', 'LineWidth', 1.5); hold on; yline(metrics.density.mean, 'r--'); xlabel('Depth z (nm)'); ylabel('Density (atoms/nm^3)'); title('Density vs Depth'); % 3. XY projection with density subplot(2,3,3); nSample = min(size(pos,1), 50000); sampleIdx = randperm(size(pos,1), nSample); scatter(pos(sampleIdx,1), pos(sampleIdx,2), 1, pos(sampleIdx,3), '.'); axis equal; colorbar; xlabel('X (nm)'); ylabel('Y (nm)'); title('XY Projection (colored by Z)'); % 4. NN distance distribution subplot(2,3,4); nSample = min(size(pos,1), 10000); sampleIdx = randperm(size(pos,1), nSample); tree = KDTreeSearcher(pos(sampleIdx,:)); [~, D] = knnsearch(tree, pos(sampleIdx,:), 'K', 2); histogram(D(:,2), 50, 'Normalization', 'pdf'); hold on; xline(metrics.resolution.expectedNN, 'r--', 'LineWidth', 2); xlabel('Nearest neighbor distance (nm)'); ylabel('Probability'); title('NN Distance Distribution'); legend('Data', 'Expected (random)', 'Location', 'best'); % 5. XZ slice subplot(2,3,5); yMid = (max(pos(:,2)) + min(pos(:,2))) / 2; yWidth = 5; % nm mask = abs(pos(:,2) - yMid) < yWidth; scatter(pos(mask,1), pos(mask,3), 1, 'b.'); axis equal; xlabel('X (nm)'); ylabel('Z (nm)'); title(sprintf('XZ Slice (Y = %.0f +/- %.0f nm)', yMid, yWidth)); % 6. Summary text subplot(2,3,6); axis off; text(0.1, 0.9, 'Quality Metrics Summary', 'FontSize', 12, 'FontWeight', 'bold'); text(0.1, 0.75, sprintf('Atoms: %d', metrics.nAtoms), 'FontSize', 10); text(0.1, 0.65, sprintf('Mean density: %.1f atoms/nm^3', metrics.density.mean), 'FontSize', 10); text(0.1, 0.55, sprintf('Density CV: %.2f', metrics.density.cv), 'FontSize', 10); text(0.1, 0.45, sprintf('Est. efficiency: %.0f%%', metrics.density.estimatedEfficiency*100), 'FontSize', 10); text(0.1, 0.35, sprintf('Lateral resolution: %.2f nm', metrics.resolution.lateral), 'FontSize', 10); text(0.1, 0.25, sprintf('Artifact score: %.2f', metrics.artifacts.overallScore), 'FontSize', 10); sgtitle('APT Data Quality Diagnostics'); end` | DATAQUALITYMETRICS Assess reconstruction quality and data integrity |

---

## Crystallography

| Function | Syntax | Description |
|----------|--------|-------------|
| `crystalOrientation` | `obj = crystalOrientation(varargin) % CRYSTALORIENTATION Constructor % % ori = crystalOrientation(R, crystalSystem) % ori = crystalOrientation('euler', angles, crystalSystem) % ori = crystalOrientation('quaternion', q, crystalSystem) if nargin == 0 error('crystalOrientation requires at least orientation and crystal system inputs'); end % Parse first argument to determine input type firstArg = varargin{1}; if ischar(firstArg) || isstring(firstArg) % Input type specified: 'euler' or 'quaternion' inputType = lower(char(firstArg)); if nargin < 3 error('Usage: crystalOrientation(''%s'', values, crystalSystem)', inputType); end orientationData = varargin{2}; crystalSys = varargin{3}; extraArgs = varargin(4:end); elseif isnumeric(firstArg) && all(size(firstArg) == [3, 3]) % Rotation matrix input inputType = 'rotmat'; orientationData = firstArg; if nargin < 2 error('Usage: crystalOrientation(R, crystalSystem)'); end crystalSys = varargin{2}; extraArgs = varargin(3:end); else error('First argument must be a 3x3 rotation matrix or ''euler''/''quaternion'''); end % Parse optional arguments p = inputParser; addParameter(p, 'position', [0, 0, 0], @(x) isnumeric(x) && numel(x)==3); addParameter(p, 'latticeParams', [], @(x) isempty(x) || isstruct(x)); addParameter(p, 'source', 'manual', @(x) ischar(x) || isstring(x)); addParameter(p, 'spaceGroup', '', @(x) ischar(x) || isstring(x)); addParameter(p, 'atomPositions', [], @(x) isempty(x) || (isnumeric(x) && size(x,2)==3)); addParameter(p, 'atomTypes', {}, @iscell); addParameter(p, 'atomLabels', {}, @iscell); parse(p, extraArgs{:}); obj.position = p.Results.position(:)'; obj.source = char(p.Results.source); obj.spaceGroup = char(p.Results.spaceGroup); obj.atomPositions = p.Results.atomPositions; obj.atomTypes = p.Results.atomTypes; obj.atomLabels = p.Results.atomLabels; % Validate and set crystal system obj.crystalSystem = obj.validateCrystalSystem(crystalSys); % Set lattice parameters (defaults based on crystal system) obj.latticeParams = obj.setLatticeParams(p.Results.latticeParams); % Convert input to rotation matrix and compute all representations switch inputType case 'rotmat' R = orientationData; obj = obj.validateAndSetRotationMatrix(R); case 'euler' if numel(orientationData) ~= 3 error('Euler angles must be [phi1, Phi, phi2]'); end R = obj.euler2rotmat(orientationData(1), orientationData(2), orientationData(3)); obj = obj.validateAndSetRotationMatrix(R); case 'quaternion' if numel(orientationData) ~= 4 error('Quaternion must be [w, x, y, z]'); end R = obj.quat2rotmat(orientationData); obj = obj.validateAndSetRotationMatrix(R); otherwise error('Unknown input type: %s', inputType); end end function R = getRotationMatrix(obj) % GETROTATIONMATRIX Return the 3x3 rotation matrix R = obj.rotationMatrix; end function [phi1, Phi, phi2] = getEulerAngles(obj) % GETEULERANGLES Return Euler angles in degrees (Bunge ZXZ) phi1 = obj.eulerAngles(1); Phi = obj.eulerAngles(2); phi2 = obj.eulerAngles(3); end function q = getQuaternion(obj) % GETQUATERNION Return unit quaternion [w, x, y, z] q = obj.quaternion; end function obj = setPosition(obj, pos) % SETPOSITION Set the position if ~isnumeric(pos) || numel(pos) ~= 3 error('Position must be [x, y, z]'); end obj.position = pos(:)'; end function symOps = getSymmetryOperators(obj) % GETSYMMETRYOPERATORS Return symmetry operators for the crystal system % Returns cell array of 3x3 rotation matrices symOps = obj.computeSymmetryOperators(obj.crystalSystem); end function equivOri = getEquivalentOrientations(obj) % GETEQUIVALENTORIENTATIONS Return all symmetrically equivalent orientations % Returns array of crystalOrientation objects symOps = obj.getSymmetryOperators(); nOps = length(symOps); equivOri = repmat(obj, nOps, 1); for i = 1:nOps R_equiv = obj.rotationMatrix * symOps{i}; equivOri(i) = crystalOrientation(R_equiv, obj.crystalSystem, ... 'position', obj.position, ... 'latticeParams', obj.latticeParams, ... 'source', obj.source); end end function angle = misorientationAngle(obj, other) % MISORIENTATIONANGLE Calculate minimum misorientation angle (degrees) % angle = misorientationAngle(obj, other) % Accounts for crystal symmetry if ~isa(other, 'crystalOrientation') error('Input must be a crystalOrientation object'); end % Get symmetry operators symOps = obj.getSymmetryOperators(); % Misorientation: R_mis = R2^T * R1 R1 = obj.rotationMatrix; R2 = other.rotationMatrix; minAngle = 180; % Start with maximum possible % Check all symmetrically equivalent misorientations for i = 1:length(symOps) R_sym = symOps{i}; R_mis = R2' * R1 * R_sym; % Calculate rotation angle from trace traceR = trace(R_mis); traceR = max(-1, min(3, traceR)); % Clamp for numerical stability angleRad = acos((traceR - 1) / 2); angleDeg = rad2deg(angleRad); if angleDeg < minAngle minAngle = angleDeg; end end angle = minAngle; end function [axis, angle] = misorientationAxisAngle(obj, other) % MISORIENTATIONAXISANGLE Calculate misorientation axis and angle % [axis, angle] = misorientationAxisAngle(obj, other) if ~isa(other, 'crystalOrientation') error('Input must be a crystalOrientation object'); end % Get symmetry operators symOps = obj.getSymmetryOperators(); R1 = obj.rotationMatrix; R2 = other.rotationMatrix; minAngle = 180; minAxis = [0, 0, 1]; % Check all symmetrically equivalent misorientations for i = 1:length(symOps) R_sym = symOps{i}; R_mis = R2' * R1 * R_sym; % Calculate rotation angle from trace traceR = trace(R_mis); traceR = max(-1, min(3, traceR)); angleRad = acos((traceR - 1) / 2); angleDeg = rad2deg(angleRad); if angleDeg < minAngle minAngle = angleDeg; % Extract axis from rotation matrix if abs(angleRad) < 1e-10 minAxis = [0, 0, 1]; % Arbitrary axis for zero rotation else minAxis = [R_mis(3,2) - R_mis(2,3); R_mis(1,3) - R_mis(3,1); R_mis(2,1) - R_mis(1,2)] / (2 * sin(angleRad)); minAxis = minAxis' / norm(minAxis); end end end axis = minAxis; angle = minAngle; end function h = plotStereographic(obj, varargin) % PLOTSTEREOGRAPHIC Plot stereographic projection % h = plotStereographic(obj) % h = plotStereographic(obj, 'Name', Value, ...) % % Passes all arguments to stereoProj function h = stereoProj(obj.rotationMatrix, varargin{:}); end function h = plotCube(obj, varargin) % PLOTCUBE Plot orientation cube at position % h = plotCube(obj) % h = plotCube(obj, 'Name', Value, ...) % % Passes all arguments to plotOrientationCube function h = plotOrientationCube(obj.rotationMatrix, ... 'position', obj.position, varargin{:}); end function disp(obj) % DISP Display orientation information fprintf('crystalOrientation:\n'); fprintf(' Crystal System: %s\n', obj.crystalSystem); if ~isempty(obj.spaceGroup) fprintf(' Space Group: %s\n', obj.spaceGroup); end fprintf(' Position: [%.3f, %.3f, %.3f]\n', obj.position); fprintf(' Source: %s\n', obj.source); fprintf(' Euler Angles (Bunge ZXZ): [%.2f°, %.2f°, %.2f°]\n', ... obj.eulerAngles(1), obj.eulerAngles(2), obj.eulerAngles(3)); fprintf(' Quaternion: [%.4f, %.4f, %.4f, %.4f]\n', obj.quaternion); fprintf(' Rotation Matrix:\n'); fprintf(' [%7.4f %7.4f %7.4f]\n', obj.rotationMatrix(1,:)); fprintf(' [%7.4f %7.4f %7.4f]\n', obj.rotationMatrix(2,:)); fprintf(' [%7.4f %7.4f %7.4f]\n', obj.rotationMatrix(3,:)); if ~isempty(obj.latticeParams) fprintf(' Lattice Parameters:\n'); fprintf(' a=%.4f, b=%.4f, c=%.4f\n', ... obj.latticeParams.a, obj.latticeParams.b, obj.latticeParams.c); fprintf(' alpha=%.2f°, beta=%.2f°, gamma=%.2f°\n', ... obj.latticeParams.alpha, obj.latticeParams.beta, obj.latticeParams.gamma); end if ~isempty(obj.atomPositions) nAtoms = size(obj.atomPositions, 1); fprintf(' Atom Sites: %d\n', nAtoms); maxShow = min(5, nAtoms); for i = 1:maxShow if ~isempty(obj.atomLabels) && length(obj.atomLabels) >= i label = obj.atomLabels{i}; else label = sprintf('Site%d', i); end if ~isempty(obj.atomTypes) && length(obj.atomTypes) >= i elem = obj.atomTypes{i}; else elem = '?'; end fprintf(' %s (%s): [%.4f, %.4f, %.4f]\n', ... label, elem, obj.atomPositions(i,:)); end if nAtoms > maxShow fprintf(' ... and %d more atoms\n', nAtoms - maxShow); end end end function atoms = getAtomPositions(obj, varargin) % GETATOMPOSITIONS Get atom positions in world or fractional coordinates % atoms = getAtomPositions(obj) returns fractional coordinates % atoms = getAtomPositions(obj, 'cartesian', true) returns Cartesian % coordinates in the crystal frame % atoms = getAtomPositions(obj, 'world', true) returns Cartesian % coordinates in the world frame (applying rotation) p = inputParser; addParameter(p, 'cartesian', false, @islogical); addParameter(p, 'world', false, @islogical); parse(p, varargin{:}); if isempty(obj.atomPositions) atoms = []; return; end if ~p.Results.cartesian && ~p.Results.world % Return fractional coordinates atoms = obj.atomPositions; else % Convert to Cartesian (crystal frame) atoms = obj.fractionalToCartesian(obj.atomPositions); if p.Results.world % Transform to world coordinates atoms = (obj.rotationMatrix * atoms')'; end end end function cartesian = fractionalToCartesian(obj, fractional) % FRACTIONALTOCARTESIAN Convert fractional to Cartesian coordinates % Uses lattice parameters to build transformation matrix a = obj.latticeParams.a; b = obj.latticeParams.b; c = obj.latticeParams.c; alpha = deg2rad(obj.latticeParams.alpha); beta = deg2rad(obj.latticeParams.beta); gamma = deg2rad(obj.latticeParams.gamma); % Build transformation matrix (fractional to Cartesian) % Convention: a along x, b in xy plane cosAlpha = cos(alpha); cosBeta = cos(beta); cosGamma = cos(gamma); sinGamma = sin(gamma); omega = a * b * c * sqrt(1 - cosAlpha^2 - cosBeta^2 - cosGamma^2 + 2*cosAlpha*cosBeta*cosGamma); M = [a, b*cosGamma, c*cosBeta; 0, b*sinGamma, c*(cosAlpha - cosBeta*cosGamma)/sinGamma; 0, 0, omega/(a*b*sinGamma)]; cartesian = (M * fractional')'; end end methods (Static) function obj = fromCIF(filename, varargin) % FROMCIF Create crystalOrientation from a CIF file % % ORI = crystalOrientation.fromCIF(FILENAME) reads crystallographic % data from a CIF file and creates a crystalOrientation object with % identity orientation. % % ORI = crystalOrientation.fromCIF(FILENAME, 'Name', Value, ...) % allows specifying additional options. % % Optional Name-Value Pairs: % 'orientation' - Initial orientation as 3x3 rotation matrix % or 'euler' followed by [phi1, Phi, phi2] % (default: eye(3)) % 'position' - [x, y, z] position (default: [0,0,0]) % % Example: % ori = crystalOrientation.fromCIF('NaCl.cif'); % ori = crystalOrientation.fromCIF('Fe.cif', 'position', [10,20,30]); % Parse optional arguments p = inputParser; addRequired(p, 'filename', @(x) ischar(x) || isstring(x)); addParameter(p, 'orientation', eye(3), @(x) isnumeric(x) && all(size(x)==[3,3])); addParameter(p, 'position', [0, 0, 0], @(x) isnumeric(x) && numel(x)==3); parse(p, filename, varargin{:}); filename = char(p.Results.filename); R = p.Results.orientation; position = p.Results.position; % Parse the CIF file cifData = parseCIFFile(filename); % Create the crystalOrientation object obj = crystalOrientation(R, cifData.crystalSystem, ... 'position', position, ... 'source', 'CIF', ... 'latticeParams', cifData.latticeParams, ... 'spaceGroup', cifData.spaceGroup, ... 'atomPositions', cifData.atomPositions, ... 'atomTypes', cifData.atomTypes, ... 'atomLabels', cifData.atomLabels); end end methods (Access = private) function obj = validateAndSetRotationMatrix(obj, R) % Validate rotation matrix and compute all representations % Check orthogonality RtR = R' * R; if max(abs(RtR - eye(3)), [], 'all') > 1e-6 warning('Rotation matrix not perfectly orthogonal, orthogonalizing...'); [U, ~, V] = svd(R); R = U * V'; end % Check determinant if det(R) < 0 error('Rotation matrix has negative determinant (reflection)'); end obj.rotationMatrix = R; obj.eulerAngles = obj.rotmat2euler(R); obj.quaternion = obj.rotmat2quat(R); end function crystalSys = validateCrystalSystem(~, input) % Validate and normalize crystal system name validSystems = {'cubic', 'hexagonal', 'tetragonal', 'orthorhombic', ... 'monoclinic', 'triclinic'}; input = lower(char(input)); if ~ismember(input, validSystems) error('Invalid crystal system: %s. Valid options: %s', ... input, strjoin(validSystems, ', ')); end crystalSys = input; end function params = setLatticeParams(obj, inputParams) % Set lattice parameters with defaults based on crystal system % Default parameters by crystal system switch obj.crystalSystem case 'cubic' defaults = struct('a', 1, 'b', 1, 'c', 1, ... 'alpha', 90, 'beta', 90, 'gamma', 90); case 'hexagonal' defaults = struct('a', 1, 'b', 1, 'c', 1.633, ... 'alpha', 90, 'beta', 90, 'gamma', 120); case 'tetragonal' defaults = struct('a', 1, 'b', 1, 'c', 1.5, ... 'alpha', 90, 'beta', 90, 'gamma', 90); case 'orthorhombic' defaults = struct('a', 1, 'b', 1.2, 'c', 1.5, ... 'alpha', 90, 'beta', 90, 'gamma', 90); case 'monoclinic' defaults = struct('a', 1, 'b', 1.2, 'c', 1.5, ... 'alpha', 90, 'beta', 100, 'gamma', 90); case 'triclinic' defaults = struct('a', 1, 'b', 1.2, 'c', 1.5, ... 'alpha', 80, 'beta', 85, 'gamma', 70); end if isempty(inputParams) params = defaults; else % Merge input with defaults params = defaults; fields = fieldnames(inputParams); for i = 1:length(fields) params.(fields{i}) = inputParams.(fields{i}); end end end function symOps = computeSymmetryOperators(~, crystalSys) % Compute symmetry operators for the given crystal system % Returns cell array of 3x3 rotation matrices switch crystalSys case 'cubic' % 24 proper rotations of cubic symmetry (m-3m point group) symOps = cell(24, 1); idx = 1; % Identity symOps{idx} = eye(3); idx = idx + 1; % 90° rotations about <100> (6 total) axes = {[1,0,0], [0,1,0], [0,0,1]}; for a = 1:3 ax = axes{a}; for angle = [90, 180, 270] symOps{idx} = rotationMatrix3D(ax, angle); idx = idx + 1; end end % 120° and 240° rotations about <111> (8 total) diag_axes = {[1,1,1], [1,1,-1], [1,-1,1], [-1,1,1]}; for a = 1:4 ax = diag_axes{a} / norm(diag_axes{a}); for angle = [120, 240] symOps{idx} = rotationMatrix3D(ax, angle); idx = idx + 1; end end % 180° rotations about <110> (6 total) edge_axes = {[1,1,0], [1,-1,0], [1,0,1], [1,0,-1], [0,1,1], [0,1,-1]}; for a = 1:6 ax = edge_axes{a} / norm(edge_axes{a}); symOps{idx} = rotationMatrix3D(ax, 180); idx = idx + 1; end case 'hexagonal' % 12 proper rotations of hexagonal symmetry (6/mmm) symOps = cell(12, 1); % Rotations about c-axis (6-fold) for i = 0:5 angle = i * 60; symOps{i+1} = rotationMatrix3D([0,0,1], angle); end % 180° rotations about a-axes for i = 0:5 angle_rad = i * pi / 3; ax = [cos(angle_rad), sin(angle_rad), 0]; symOps{7+i} = rotationMatrix3D(ax, 180); end case 'tetragonal' % 8 proper rotations (4/mmm) symOps = cell(8, 1); % Rotations about c-axis (4-fold) for i = 0:3 angle = i * 90; symOps{i+1} = rotationMatrix3D([0,0,1], angle); end % 180° rotations about <100> and <110> symOps{5} = rotationMatrix3D([1,0,0], 180); symOps{6} = rotationMatrix3D([0,1,0], 180); symOps{7} = rotationMatrix3D([1,1,0]/sqrt(2), 180); symOps{8} = rotationMatrix3D([1,-1,0]/sqrt(2), 180); case 'orthorhombic' % 4 proper rotations (mmm) symOps = cell(4, 1); symOps{1} = eye(3); symOps{2} = rotationMatrix3D([1,0,0], 180); symOps{3} = rotationMatrix3D([0,1,0], 180); symOps{4} = rotationMatrix3D([0,0,1], 180); case 'monoclinic' % 2 proper rotations (2/m) symOps = cell(2, 1); symOps{1} = eye(3); symOps{2} = rotationMatrix3D([0,1,0], 180); % 2-fold about b case 'triclinic' % Only identity symOps = {eye(3)}; otherwise error('Unknown crystal system: %s', crystalSys); end end end methods (Static, Access = private) function euler = rotmat2euler(R) % Convert rotation matrix to Euler angles (Bunge ZXZ convention) % Returns [phi1, Phi, phi2] in degrees R = max(-1, min(1, R)); % Clamp for numerical stability Phi = acosd(R(3,3)); if abs(R(3,3)) > 0.9999 % Gimbal lock case phi1 = atan2d(-R(1,2), R(1,1)); phi2 = 0; if R(3,3) < 0 Phi = 180; else Phi = 0; end else phi1 = atan2d(R(3,1), -R(3,2)); phi2 = atan2d(R(1,3), R(2,3)); end % Normalize to [0, 360) phi1 = mod(phi1, 360); phi2 = mod(phi2, 360); euler = [phi1, Phi, phi2]; end function R = euler2rotmat(phi1, Phi, phi2) % Convert Euler angles to rotation matrix (Bunge ZXZ convention) % Input angles in degrees phi1 = deg2rad(phi1); Phi = deg2rad(Phi); phi2 = deg2rad(phi2); c1 = cos(phi1); s1 = sin(phi1); c = cos(Phi); s = sin(Phi); c2 = cos(phi2); s2 = sin(phi2); R = [c1*c2 - s1*c*s2, -c1*s2 - s1*c*c2, s1*s; s1*c2 + c1*c*s2, -s1*s2 + c1*c*c2, -c1*s; s*s2, s*c2, c]; end function q = rotmat2quat(R) % Convert rotation matrix to quaternion [w, x, y, z] tr = trace(R); if tr > 0 s = sqrt(tr + 1) * 2; w = s / 4; x = (R(3,2) - R(2,3)) / s; y = (R(1,3) - R(3,1)) / s; z = (R(2,1) - R(1,2)) / s; elseif R(1,1) > R(2,2) && R(1,1) > R(3,3) s = sqrt(1 + R(1,1) - R(2,2) - R(3,3)) * 2; w = (R(3,2) - R(2,3)) / s; x = s / 4; y = (R(1,2) + R(2,1)) / s; z = (R(1,3) + R(3,1)) / s; elseif R(2,2) > R(3,3) s = sqrt(1 + R(2,2) - R(1,1) - R(3,3)) * 2; w = (R(1,3) - R(3,1)) / s; x = (R(1,2) + R(2,1)) / s; y = s / 4; z = (R(2,3) + R(3,2)) / s; else s = sqrt(1 + R(3,3) - R(1,1) - R(2,2)) * 2; w = (R(2,1) - R(1,2)) / s; x = (R(1,3) + R(3,1)) / s; y = (R(2,3) + R(3,2)) / s; z = s / 4; end q = [w, x, y, z]; % Normalize q = q / norm(q); % Ensure w >= 0 for unique representation if q(1) < 0 q = -q; end end function R = quat2rotmat(q) % Convert quaternion [w, x, y, z] to rotation matrix q = q / norm(q); % Ensure normalized w = q(1); x = q(2); y = q(3); z = q(4); R = [1 - 2*y^2 - 2*z^2, 2*x*y - 2*z*w, 2*x*z + 2*y*w; 2*x*y + 2*z*w, 1 - 2*x^2 - 2*z^2, 2*y*z - 2*x*w; 2*x*z - 2*y*w, 2*y*z + 2*x*w, 1 - 2*x^2 - 2*y^2]; end end end function R = rotationMatrix3D(axis, angle_deg) % Helper function to create rotation matrix from axis-angle % axis: unit vector [x, y, z] % angle_deg: rotation angle in degrees axis = axis(:)' / norm(axis); angle = deg2rad(angle_deg); c = cos(angle); s = sin(angle); t = 1 - c; x = axis(1); y = axis(2); z = axis(3); R = [t*x*x + c, t*x*y - s*z, t*x*z + s*y; t*x*y + s*z, t*y*y + c, t*y*z - s*x; t*x*z - s*y, t*y*z + s*x, t*z*z + c]; end function cifData = parseCIFFile(filename) % PARSECIFFILE Parse a CIF (Crystallographic Information File) % Returns a structure with crystal structure data % % cifData = parseCIFFile(filename) % % Output fields: % crystalSystem - Detected crystal system % spaceGroup - Space group name (Hermann-Mauguin) % latticeParams - struct with a, b, c, alpha, beta, gamma % atomPositions - Nx3 fractional coordinates % atomTypes - Nx1 cell array of element symbols % atomLabels - Nx1 cell array of atom site labels if ~exist(filename, 'file') error('CIF file not found: %s', filename); end % Read the file fid = fopen(filename, 'r'); if fid == -1 error('Could not open CIF file: %s', filename); end content = textscan(fid, '%s', 'Delimiter', '\n', 'Whitespace', ''); fclose(fid); lines = content{1}; % Initialize output cifData = struct(); cifData.spaceGroup = ''; cifData.latticeParams = struct('a', 1, 'b', 1, 'c', 1, 'alpha', 90, 'beta', 90, 'gamma', 90); cifData.atomPositions = []; cifData.atomTypes = {}; cifData.atomLabels = {}; % Parse lattice parameters and space group for i = 1:length(lines) line = strtrim(lines{i}); % Skip empty lines and comments if isempty(line) || line(1) == '#' continue; end % Lattice parameters if startsWith(line, '_cell_length_a') cifData.latticeParams.a = parseNumericValue(line); elseif startsWith(line, '_cell_length_b') cifData.latticeParams.b = parseNumericValue(line); elseif startsWith(line, '_cell_length_c') cifData.latticeParams.c = parseNumericValue(line); elseif startsWith(line, '_cell_angle_alpha') cifData.latticeParams.alpha = parseNumericValue(line); elseif startsWith(line, '_cell_angle_beta') cifData.latticeParams.beta = parseNumericValue(line); elseif startsWith(line, '_cell_angle_gamma') cifData.latticeParams.gamma = parseNumericValue(line); % Space group (various CIF tags) elseif startsWith(line, '_symmetry_space_group_name_H-M') || ... startsWith(line, '_space_group_name_H-M_alt') || ... startsWith(line, '_space_group.name_H-M_alt') cifData.spaceGroup = parseStringValue(line); elseif startsWith(line, '_symmetry_Int_Tables_number') || ... startsWith(line, '_space_group_IT_number') % Store space group number if name not found if isempty(cifData.spaceGroup) cifData.spaceGroup = sprintf('SG#%d', round(parseNumericValue(line))); end end end % Parse atom sites (look for loop_ containing atom site data) [cifData.atomPositions, cifData.atomTypes, cifData.atomLabels] = parseAtomSites(lines); % Determine crystal system from space group or lattice parameters cifData.crystalSystem = determineCrystalSystem(cifData.spaceGroup, cifData.latticeParams); end function val = parseNumericValue(line) % Parse numeric value from a CIF line, handling uncertainty notation tokens = strsplit(strtrim(line)); if length(tokens) >= 2 valStr = tokens{2}; % Remove uncertainty in parentheses, e.g., "5.431(1)" -> "5.431" valStr = regexprep(valStr, '\([0-9]+\)', ''); val = str2double(valStr); if isnan(val) val = 0; end else val = 0; end end function str = parseStringValue(line) % Parse string value from a CIF line tokens = strsplit(strtrim(line)); if length(tokens) >= 2 % Rejoin tokens after the tag, removing quotes str = strjoin(tokens(2:end), ' '); str = strrep(str, '''', ''); str = strrep(str, '"', ''); str = strtrim(str); else str = ''; end end function [positions, types, labels] = parseAtomSites(lines) % Parse atom site loop from CIF positions = []; types = {}; labels = {}; % Find loop_ containing atom sites inLoop = false; loopColumns = {}; xCol = 0; yCol = 0; zCol = 0; typeCol = 0; labelCol = 0; i = 1; while i <= length(lines) line = strtrim(lines{i}); if strcmp(line, 'loop_') inLoop = true; loopColumns = {}; xCol = 0; yCol = 0; zCol = 0; typeCol = 0; labelCol = 0; i = i + 1; continue; end if inLoop % Check if line contains atom_site column header (with or without leading space) if contains(line, '_atom_site') % Column header - extract the tag name loopColumns{end+1} = strtrim(line); % Identify which column is which colIdx = length(loopColumns); if contains(line, '_atom_site_fract_x') xCol = colIdx; elseif contains(line, '_atom_site_fract_y') yCol = colIdx; elseif contains(line, '_atom_site_fract_z') zCol = colIdx; elseif contains(line, '_atom_site_type_symbol') typeCol = colIdx; elseif contains(line, '_atom_site_label') labelCol = colIdx; end elseif ~isempty(line) && ~startsWith(line, '_') && line(1) ~= '#' && ~strcmp(line, 'loop_') % Data line - only process if we have the required columns if xCol > 0 && yCol > 0 && zCol > 0 % Split by whitespace, handling multiple spaces tokens = strsplit(strtrim(line)); tokens = tokens(~cellfun('isempty', tokens)); % Remove empty tokens maxCol = max([xCol, yCol, zCol, typeCol, labelCol]); if length(tokens) >= maxCol || length(tokens) >= max([xCol, yCol, zCol]) x = parseCoordinate(tokens{xCol}); y = parseCoordinate(tokens{yCol}); z = parseCoordinate(tokens{zCol}); positions = [positions; x, y, z]; if typeCol > 0 && length(tokens) >= typeCol types{end+1} = tokens{typeCol}; else types{end+1} = ''; end if labelCol > 0 && length(tokens) >= labelCol labels{end+1} = tokens{labelCol}; else labels{end+1} = ''; end end end elseif strcmp(line, 'loop_') || (startsWith(line, '_') && ~contains(line, '_atom_site')) % End of this loop, check if we found atom sites if ~isempty(positions) break; end % Reset for next loop inLoop = strcmp(line, 'loop_'); if inLoop loopColumns = {}; xCol = 0; yCol = 0; zCol = 0; typeCol = 0; labelCol = 0; end end end i = i + 1; end types = types(:); labels = labels(:); end function val = parseCoordinate(str) % Parse coordinate value, removing uncertainty str = regexprep(str, '\([0-9]+\)', ''); val = str2double(str); if isnan(val) val = 0; end end function crystalSystem = determineCrystalSystem(spaceGroup, latticeParams) % Determine crystal system from space group or lattice parameters % Try to determine from space group name if ~isempty(spaceGroup) sg = upper(spaceGroup); % Cubic: contains 'M3' or 'm-3' or specific cubic groups if contains(sg, 'M3') || contains(sg, 'M-3') || ... contains(sg, '23') || contains(sg, '432') || contains(sg, '-43') crystalSystem = 'cubic'; return; end % Hexagonal: starts with P6, R3, etc. if startsWith(sg, 'P6') || startsWith(sg, 'P-6') || contains(sg, '/M') if latticeParams.gamma == 120 || abs(latticeParams.gamma - 120) < 0.1 crystalSystem = 'hexagonal'; return; end end % Trigonal/Rhombohedral if startsWith(sg, 'R3') || startsWith(sg, 'R-3') || startsWith(sg, 'P3') crystalSystem = 'hexagonal'; % Often grouped with hexagonal return; end % Tetragonal: P4, I4 if startsWith(sg, 'P4') || startsWith(sg, 'I4') || startsWith(sg, 'P-4') || startsWith(sg, 'I-4') crystalSystem = 'tetragonal'; return; end % Orthorhombic: Pnma, Cmcm, etc. if startsWith(sg, 'P') || startsWith(sg, 'C') || startsWith(sg, 'I') || startsWith(sg, 'F') if contains(sg, 'MM') || contains(sg, '222') || contains(sg, 'MC') || contains(sg, 'MA') crystalSystem = 'orthorhombic'; return; end end % Monoclinic: P2, C2, etc. if startsWith(sg, 'P2') || startsWith(sg, 'C2') || contains(sg, '/M') || contains(sg, '2/M') if ~contains(sg, 'MM') crystalSystem = 'monoclinic'; return; end end end % Fall back to lattice parameter analysis a = latticeParams.a; b = latticeParams.b; c = latticeParams.c; alpha = latticeParams.alpha; beta = latticeParams.beta; gamma = latticeParams.gamma; tol = 0.01; % Tolerance for comparisons % Cubic: a = b = c, all angles 90 if abs(a-b)/a < tol && abs(b-c)/b < tol && ... abs(alpha-90) < 0.1 && abs(beta-90) < 0.1 && abs(gamma-90) < 0.1 crystalSystem = 'cubic'; return; end % Hexagonal: a = b != c, alpha = beta = 90, gamma = 120 if abs(a-b)/a < tol && abs(alpha-90) < 0.1 && abs(beta-90) < 0.1 && abs(gamma-120) < 0.1 crystalSystem = 'hexagonal'; return; end % Tetragonal: a = b != c, all angles 90 if abs(a-b)/a < tol && abs(alpha-90) < 0.1 && abs(beta-90) < 0.1 && abs(gamma-90) < 0.1 crystalSystem = 'tetragonal'; return; end % Orthorhombic: a != b != c, all angles 90 if abs(alpha-90) < 0.1 && abs(beta-90) < 0.1 && abs(gamma-90) < 0.1 crystalSystem = 'orthorhombic'; return; end % Monoclinic: alpha = gamma = 90, beta != 90 if abs(alpha-90) < 0.1 && abs(gamma-90) < 0.1 && abs(beta-90) >= 0.1 crystalSystem = 'monoclinic'; return; end % Default to triclinic crystalSystem = 'triclinic'; end` | CRYSTALORIENTATION Represents crystallographic orientation of a location/volume |
| `ipfColor` | `[rgb, varargout] = ipfColor(directionOrOrientation, varargin) % IPFCOLOR Computes IPF color for crystallographic direction (cubic system) % % RGB = IPFCOLOR(DIRECTION) returns the RGB color for a crystallographic % direction in a cubic crystal system using the standard IPF coloring % scheme with the [001]-[011]-[111] standard triangle. % % RGB = IPFCOLOR(CRYSTALORIENTATION, WORLDDIRECTION) returns the IPF color % for a world direction transformed into the crystal frame using the given % crystalOrientation object. This is useful for coloring surfaces based on % their normal directions. % % [RGB, AX] = IPFCOLOR(..., 'plot', true) additionally plots the % standard triangle with the direction marked and returns the axes handle. % % Input: % direction - 3-component vector [h k l] specifying crystallographic direction % % OR % % crystalOrientation - crystalOrientation object % worldDirection - 3-component vector in world coordinates % % Optional Name-Value Pairs: % 'plot' - logical, if true creates a plot (default: false) % 'MarkerSize'- size of the marker in the plot (default: 100) % % Output: % rgb - 1x3 RGB color vector (values 0-1) % ax - axes handle (only if 'plot' is true) % % Color scheme: % [001] = Blue (bottom-left) % [011] = Green (bottom-right) % [111] = Red (top) % % Example: % % Direct crystallographic direction % rgb = ipfColor([1 2 3]); % [rgb, ax] = ipfColor([1 1 0], 'plot', true); % % % Using crystalOrientation with world direction % ori = crystalOrientation(eye(3), 'cubic'); % worldNormal = [0 0 1]; % World Z direction % rgb = ipfColor(ori, worldNormal); % % See also: crystalOrientation, ipfMesh, plotStandardTriangle % Determine input type if isa(directionOrOrientation, 'crystalOrientation') % Two-argument form: crystalOrientation + world direction if nargin < 2 error('When passing a crystalOrientation, a world direction must also be provided'); end worldDirection = varargin{1}; if ~isnumeric(worldDirection) || numel(worldDirection) ~= 3 error('World direction must be a 3-component vector'); end % Transform world direction to crystal coordinates R = directionOrOrientation.getRotationMatrix(); direction = (R' * worldDirection(:))'; % R' transforms world->crystal % Remove the world direction from varargin for parsing varargin = varargin(2:end); elseif isnumeric(directionOrOrientation) && numel(directionOrOrientation) == 3 % Single-argument form: direct crystallographic direction direction = directionOrOrientation; else error('First argument must be a 3-component direction vector or a crystalOrientation object'); end % Parse remaining inputs p = inputParser; addParameter(p, 'plot', false, @islogical); addParameter(p, 'MarkerSize', 100, @isnumeric); parse(p, varargin{:}); doPlot = p.Results.plot; markerSize = p.Results.MarkerSize; % Ensure direction is a row vector direction = direction(:)'; % Normalize direction direction = direction / norm(direction); % Reduce to fundamental zone (standard triangle) using cubic symmetry % Take absolute values and sort to get equivalent direction in standard triangle dirAbs = abs(direction); dirSorted = sort(dirAbs, 'ascend'); % Now dirSorted = [min, mid, max] which maps to the standard triangle % with vertices at [001], [011], [111] h = dirSorted(1); % smallest component k = dirSorted(2); % middle component l = dirSorted(3); % largest component % Calculate RGB using the standard IPF coloring scheme rgb = calculateIPFColor(h, k, l); % Ensure RGB values are in valid range rgb = max(0, min(1, rgb)); % Plot if requested if doPlot ax = plotStandardTriangle(); hold(ax, 'on'); % Get stereographic projection coordinates [x, y] = direction2stereo(h, k, l); scatter(ax, x, y, markerSize, rgb, 'filled', 'MarkerEdgeColor', 'k', 'LineWidth', 1.5); hold(ax, 'off'); varargout{1} = ax; elseif nargout > 1 varargout{1} = []; end end function rgb = calculateIPFColor(h, k, l) % Calculate IPF color based on position in standard triangle % Using the scheme: [001]=Blue, [011]=Green, [111]=Red % Normalize so that l (largest component) = 1 if l > 0 h = h / l; k = k / l; l = 1; else rgb = [0 0 0]; return; end % Calculate color components based on proximity to vertices % [001]: h=0, k=0, l=1 -> Blue % [011]: h=0, k=1, l=1 -> Green % [111]: h=1, k=1, l=1 -> Red % The color is determined by the relative magnitudes % Red component: proportional to h (distance toward [111]) % Green component: proportional to k-h (distance toward [011]) % Blue component: proportional to 1-k (distance toward [001]) red = h; green = k - h; blue = 1 - k; % Normalize to maximum = 1 for vivid colors maxVal = max([red, green, blue]); if maxVal > 0 rgb = [red, green, blue] / maxVal; else rgb = [0 0 1]; % Default to blue for [001] end end function [x, y] = direction2stereo(h, k, l) % Convert crystallographic direction (in fundamental zone) to stereographic % projection coordinates with orientation: % [001] bottom-left, [011] bottom-right, [111] top % Normalize norm_d = sqrt(h^2 + k^2 + l^2); h = h / norm_d; k = k / norm_d; l = l / norm_d; % Stereographic projection % theta = polar angle from [001] % phi = azimuthal angle in h-k plane theta = acos(l); if (h^2 + k^2) > 0 phi = atan2(k, h); else phi = 0; end r = tan(theta / 2); x_stereo = r * cos(phi); y_stereo = r * sin(phi); % Rotate to desired orientation: swap x and y % This puts [001] at origin (bottom-left), [011] to the right, [111] at top x = y_stereo; y = x_stereo; end function ax = plotStandardTriangle() % PLOTSTANDARDTRIANGLE Creates a plot of the standard stereographic triangle % with continuous IPF coloring using a triangular mesh. % Orientation: [001] bottom-left, [011] bottom-right, [111] top % Create figure figure('Color', 'w'); ax = axes; hold(ax, 'on'); % Create triangular mesh for continuous coloring % Sample the fundamental zone and create mesh vertices nDiv = 80; % Number of divisions for smooth coloring % Generate vertices by sampling the standard triangle % Parameterize using (h, k) where 0 <= h <= k <= 1 (with l=1) vertices = []; colors = []; hkValues = []; % Store h,k values for face generation % Create a grid in the (h,k) parameter space % The standard triangle in (h,k) space (with l=1 normalized) is: % 0 <= h <= k <= 1 idx = 0; indexMap = zeros(nDiv+1, nDiv+1); % Map from (i,j) to vertex index for i = 0:nDiv for j = i:nDiv h = i / nDiv; k = j / nDiv; l = 1; % Get stereographic coordinates [x, y] = direction2stereo(h, k, l); idx = idx + 1; vertices(idx, :) = [x, y]; indexMap(i+1, j+1) = idx; % Get color rgb = calculateIPFColor(h, k, l); colors(idx, :) = rgb; hkValues(idx, :) = [h, k]; end end % Build triangular faces faces = []; for i = 0:(nDiv-1) for j = i:(nDiv-1) % Get vertex indices idx1 = indexMap(i+1, j+1); % (i, j) idx2 = indexMap(i+1, j+2); % (i, j+1) idx3 = indexMap(i+2, j+2); % (i+1, j+1) % Lower triangle faces = [faces; idx1, idx2, idx3]; % Upper triangle (if valid) if j > i idx4 = indexMap(i+2, j+1); % (i+1, j) faces = [faces; idx1, idx3, idx4]; end end end % Plot the mesh with interpolated colors patch(ax, 'Faces', faces, 'Vertices', vertices, ... 'FaceVertexCData', colors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); % Plot triangle boundary (the curved edges of stereographic projection) nBoundary = 100; % Edge [001] to [011]: h=0, k varies from 0 to 1 t = linspace(0, 1, nBoundary); bx1 = zeros(1, nBoundary); by1 = zeros(1, nBoundary); for i = 1:nBoundary [bx1(i), by1(i)] = direction2stereo(0, t(i), 1); end plot(ax, bx1, by1, 'k-', 'LineWidth', 1.5); % Edge [011] to [111]: h varies from 0 to 1, k=1 bx2 = zeros(1, nBoundary); by2 = zeros(1, nBoundary); for i = 1:nBoundary [bx2(i), by2(i)] = direction2stereo(t(i), 1, 1); end plot(ax, bx2, by2, 'k-', 'LineWidth', 1.5); % Edge [111] to [001]: h=k, both vary from 1 to 0 bx3 = zeros(1, nBoundary); by3 = zeros(1, nBoundary); for i = 1:nBoundary val = 1 - t(i); [bx3(i), by3(i)] = direction2stereo(val, val, 1); end plot(ax, bx3, by3, 'k-', 'LineWidth', 1.5); % Get vertex positions for labels [x001, y001] = direction2stereo(0, 0, 1); [x011, y011] = direction2stereo(0, 1, 1); [x111, y111] = direction2stereo(1, 1, 1); % Add vertex labels text(ax, x001 - 0.03, y001 - 0.02, '[001]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'right'); text(ax, x011 + 0.03, y011 - 0.02, '[011]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); text(ax, x111, y111 + 0.03, '[111]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); % Format axes axis(ax, 'equal'); axis(ax, 'off'); title(ax, 'IPF Standard Triangle (Cubic)', 'FontSize', 14); hold(ax, 'off'); end` | IPFCOLOR Computes IPF color for crystallographic direction (cubic system) |
| `ipfHistogram` | `[histData, ax] = ipfHistogram(fv, orientationInput, varargin) % IPFHISTOGRAM Create orientation histogram in the IPF standard triangle % % [HISTDATA, AX] = IPFHISTOGRAM(FV, CRYSTALORIENTATION) creates a histogram % of surface normal orientations in the standard triangle (IPF) for cubic % crystals. The histogram shows the frequency distribution of crystallographic % orientations of the mesh surface. % % [HISTDATA, AX] = IPFHISTOGRAM(FV, CRYSTALORIENTATION, 'property', PROP, ...) % creates a property-weighted histogram where PROP is a per-vertex array of % values (e.g., concentration) to be aggregated by orientation. % % Input: % fv - Mesh structure with fields: % fv.vertices - Nx3 array of vertex coordinates % fv.faces - Mx3 array of face indices (triangles) % % orientationInput - Either: % - 3x3 rotation matrix (crystal to world) % - crystalOrientation object % % Optional Name-Value Pairs: % 'property' - Nx1 array of property values per vertex (default: []) % 'binning' - 'angular' (default) or 'adaptive' % 'resolution' - Angular resolution in degrees for angular binning (default: 2) % 'nBins' - Number of bins for adaptive binning (default: 500) % 'aggregation' - 'count', 'mean', 'sum' (default: 'count' if no property, % 'mean' if property provided) % 'areaWeighted' - Logical, weight by face area (default: false) % 'colormap' - Colormap name or Nx3 array (default: 'parula') % 'plot' - Logical, create plot (default: true) % 'showColorbar' - Logical, show colorbar (default: true) % % Output: % histData - Structure with fields: % .bins - Bin center positions [h, k, l] % .counts - Count/weight per bin % .values - Aggregated property values per bin % .crystalNormals - Nx3 crystal normals for all vertices % .binIndices - Bin assignment for each vertex % % ax - Axes handle (if plot is true) % % Example: % % Simple count histogram % [X,Y,Z] = sphere(50); % fv = surf2patch(X,Y,Z,'triangles'); % ori = crystalOrientation(eye(3), 'cubic'); % [hist, ax] = ipfHistogram(fv, ori); % % % Property-weighted histogram % concentration = rand(size(fv.vertices, 1), 1); % [hist, ax] = ipfHistogram(fv, ori, 'property', concentration, ... % 'resolution', 1, 'aggregation', 'mean'); % % % Area-weighted adaptive binning % [hist, ax] = ipfHistogram(fv, ori, 'binning', 'adaptive', ... % 'nBins', 1000, 'areaWeighted', true); % % See also: crystalOrientation, ipfColor, ipfMesh % Determine input type and extract rotation matrix if isa(orientationInput, 'crystalOrientation') R = orientationInput.getRotationMatrix(); elseif isnumeric(orientationInput) && all(size(orientationInput) == [3, 3]) R = orientationInput; else error('orientationInput must be a 3x3 rotation matrix or a crystalOrientation object'); end % Parse inputs p = inputParser; addRequired(p, 'fv', @(x) isstruct(x) && isfield(x,'vertices') && isfield(x,'faces')); addRequired(p, 'orientationInput'); addParameter(p, 'property', [], @(x) isempty(x) || (isnumeric(x) && isvector(x))); addParameter(p, 'binning', 'angular', @(x) ismember(lower(x), {'angular', 'adaptive'})); addParameter(p, 'resolution', 2, @(x) isnumeric(x) && isscalar(x) && x > 0); addParameter(p, 'nBins', 500, @(x) isnumeric(x) && isscalar(x) && x > 0); addParameter(p, 'aggregation', '', @(x) isempty(x) || ismember(lower(x), {'count', 'mean', 'sum'})); addParameter(p, 'areaWeighted', false, @islogical); addParameter(p, 'colormap', 'parula', @(x) ischar(x) || (isnumeric(x) && size(x,2)==3)); addParameter(p, 'plot', true, @islogical); addParameter(p, 'showColorbar', true, @islogical); parse(p, fv, orientationInput, varargin{:}); property = p.Results.property(:); binningMode = lower(p.Results.binning); resolution = p.Results.resolution; nBins = round(p.Results.nBins); aggregation = lower(p.Results.aggregation); areaWeighted = p.Results.areaWeighted; cmapName = p.Results.colormap; doPlot = p.Results.plot; showColorbar = p.Results.showColorbar; % Set default aggregation if isempty(aggregation) if isempty(property) aggregation = 'count'; else aggregation = 'mean'; end end % Validate property size vertices = fv.vertices; faces = fv.faces; nVertices = size(vertices, 1); if ~isempty(property) && length(property) ~= nVertices error('Property array must have one value per vertex (%d vertices)', nVertices); end %% Step 1: Calculate vertex normals vertexNormals = calculateVertexNormals(vertices, faces); %% Step 2: Transform to crystal coordinates R_world2crystal = R'; crystalNormals = (R_world2crystal * vertexNormals')'; %% Step 3: Reduce to fundamental zone (standard triangle) reducedNormals = reduceToFundamentalZone(crystalNormals); %% Step 4: Calculate vertex weights if area-weighted if areaWeighted vertexWeights = calculateVertexWeights(vertices, faces); else vertexWeights = ones(nVertices, 1); end %% Step 5: Create bins and assign vertices to bins if strcmp(binningMode, 'angular') [binCenters, binEdges] = createAngularBins(resolution); else [binCenters, binEdges] = createAdaptiveBins(reducedNormals, nBins); end binIndices = assignToBins(reducedNormals, binCenters); %% Step 6: Aggregate values in each bin nBinsActual = size(binCenters, 1); counts = zeros(nBinsActual, 1); values = zeros(nBinsActual, 1); for b = 1:nBinsActual inBin = (binIndices == b); weights = vertexWeights(inBin); counts(b) = sum(weights); if ~isempty(property) propVals = property(inBin); switch aggregation case 'mean' if sum(weights) > 0 values(b) = sum(propVals .* weights) / sum(weights); else values(b) = NaN; end case 'sum' values(b) = sum(propVals .* weights); case 'count' values(b) = counts(b); end else values(b) = counts(b); end end %% Build output structure histData.bins = binCenters; histData.binEdges = binEdges; histData.counts = counts; histData.values = values; histData.crystalNormals = crystalNormals; histData.reducedNormals = reducedNormals; histData.binIndices = binIndices; histData.aggregation = aggregation; histData.areaWeighted = areaWeighted; %% Step 7: Visualization if doPlot ax = plotHistogramTriangle(histData, cmapName, showColorbar, aggregation, ~isempty(property)); else ax = []; end end %% Helper Functions function normals = calculateVertexNormals(vertices, faces) % CALCULATEVERTEXNORMALS Compute vertex normals by averaging face normals nVertices = size(vertices, 1); nFaces = size(faces, 1); normals = zeros(nVertices, 3); for i = 1:nFaces v1 = faces(i, 1); v2 = faces(i, 2); v3 = faces(i, 3); p1 = vertices(v1, :); p2 = vertices(v2, :); p3 = vertices(v3, :); edge1 = p2 - p1; edge2 = p3 - p1; faceNormal = cross(edge1, edge2); normals(v1, :) = normals(v1, :) + faceNormal; normals(v2, :) = normals(v2, :) + faceNormal; normals(v3, :) = normals(v3, :) + faceNormal; end % Normalize for i = 1:nVertices n = norm(normals(i, :)); if n > 0 normals(i, :) = normals(i, :) / n; end end end function reduced = reduceToFundamentalZone(directions) % REDUCETOFUNDAMENTALZONE Reduce directions to standard triangle using cubic symmetry % Returns [h, k, l] with 0 <= h <= k <= l nDirs = size(directions, 1); reduced = zeros(nDirs, 3); for i = 1:nDirs dir = directions(i, :); n = norm(dir); if n > 0 dir = dir / n; end % Take absolute values and sort ascending dirAbs = abs(dir); dirSorted = sort(dirAbs, 'ascend'); reduced(i, :) = dirSorted; end end function weights = calculateVertexWeights(vertices, faces) % CALCULATEVERTEXWEIGHTS Calculate area-based weights for each vertex nVertices = size(vertices, 1); nFaces = size(faces, 1); weights = zeros(nVertices, 1); for i = 1:nFaces v1 = faces(i, 1); v2 = faces(i, 2); v3 = faces(i, 3); p1 = vertices(v1, :); p2 = vertices(v2, :); p3 = vertices(v3, :); % Face area = 0.5 * |cross product| edge1 = p2 - p1; edge2 = p3 - p1; faceArea = 0.5 * norm(cross(edge1, edge2)); % Distribute 1/3 of face area to each vertex weights(v1) = weights(v1) + faceArea / 3; weights(v2) = weights(v2) + faceArea / 3; weights(v3) = weights(v3) + faceArea / 3; end end function [binCenters, binEdges] = createAngularBins(resolution) % CREATEANGULARBINS Create uniform angular bins in the standard triangle % Resolution is in degrees % Convert resolution to step in (h,k) parameter space % For the standard triangle: 0 <= h <= k <= 1 (with l=1 normalized) % Angular resolution corresponds to spacing in h,k space % Approximate: 1 degree ~ 0.0175 radians, and the triangle spans ~35 degrees % So step size ~ resolution / 35 step = resolution / 45; % Empirical scaling step = max(0.01, min(0.2, step)); % Clamp to reasonable range % Generate grid points in the triangular domain hVals = 0:step:1; kVals = 0:step:1; binCenters = []; for h = hVals for k = kVals if h <= k % Only include points in the triangle binCenters = [binCenters; h, k, 1]; end end end % Normalize bin centers for i = 1:size(binCenters, 1) binCenters(i, :) = binCenters(i, :) / norm(binCenters(i, :)); end binEdges = step; % Store step size as edge info end function [binCenters, binEdges] = createAdaptiveBins(reducedNormals, nBins) % CREATEADAPTIVEBINS Create adaptive bins based on data density % Uses k-means clustering for adaptive bin placement % Normalize all directions norms = sqrt(sum(reducedNormals.^2, 2)); norms(norms == 0) = 1; normalizedDirs = reducedNormals ./ norms; % Limit nBins to number of unique directions uniqueDirs = unique(round(normalizedDirs * 1000) / 1000, 'rows'); nBins = min(nBins, size(uniqueDirs, 1)); if nBins < 2 binCenters = mean(normalizedDirs, 1); binEdges = []; return; end % Use k-means clustering try [~, binCenters] = kmeans(normalizedDirs, nBins, ... 'MaxIter', 100, 'Replicates', 3, 'Display', 'off'); catch % Fallback to uniform if kmeans fails [binCenters, binEdges] = createAngularBins(2); return; end % Ensure bin centers are in fundamental zone binCenters = reduceToFundamentalZone(binCenters); binEdges = []; % Adaptive bins don't have regular edges end function binIndices = assignToBins(reducedNormals, binCenters) % ASSIGNTOBINS Assign each direction to nearest bin center nDirs = size(reducedNormals, 1); nBins = size(binCenters, 1); binIndices = zeros(nDirs, 1); % Normalize directions for i = 1:nDirs n = norm(reducedNormals(i, :)); if n > 0 reducedNormals(i, :) = reducedNormals(i, :) / n; end end % Normalize bin centers for i = 1:nBins n = norm(binCenters(i, :)); if n > 0 binCenters(i, :) = binCenters(i, :) / n; end end % Find nearest bin for each direction using dot product (cosine similarity) for i = 1:nDirs dir = reducedNormals(i, :); similarities = binCenters * dir'; [~, binIndices(i)] = max(similarities); end end function ax = plotHistogramTriangle(histData, cmapName, showColorbar, aggregation, hasProperty) % PLOTHISTOGRAMTRIANGLE Render the histogram as filled contour on standard triangle figure('Color', 'w'); ax = axes; hold(ax, 'on'); bins = histData.bins; values = histData.values; % Remove bins with no data validBins = ~isnan(values) & histData.counts > 0; bins = bins(validBins, :); values = values(validBins); if isempty(bins) warning('No valid data to plot'); return; end % Get 2D coordinates for bin centers [xBins, yBins] = direction2stereo(bins); % Create a fine mesh for interpolation nGrid = 100; [meshVertices, meshFaces, meshColors] = createInterpolatedMesh(xBins, yBins, values, nGrid); % Plot the mesh if ~isempty(meshVertices) patch(ax, 'Faces', meshFaces, 'Vertices', meshVertices, ... 'FaceVertexCData', meshColors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); end % Draw triangle boundary nBoundary = 100; t = linspace(0, 1, nBoundary); % Edge [001] to [011]: h=0, k varies 0 to 1 bx1 = zeros(1, nBoundary); by1 = zeros(1, nBoundary); for i = 1:nBoundary [bx1(i), by1(i)] = direction2stereoSingle(0, t(i), 1); end plot(ax, bx1, by1, 'k-', 'LineWidth', 1.5); % Edge [011] to [111]: k=1, h varies 0 to 1 bx2 = zeros(1, nBoundary); by2 = zeros(1, nBoundary); for i = 1:nBoundary [bx2(i), by2(i)] = direction2stereoSingle(t(i), 1, 1); end plot(ax, bx2, by2, 'k-', 'LineWidth', 1.5); % Edge [111] to [001]: h=k, both vary 1 to 0 bx3 = zeros(1, nBoundary); by3 = zeros(1, nBoundary); for i = 1:nBoundary val = 1 - t(i); [bx3(i), by3(i)] = direction2stereoSingle(val, val, 1); end plot(ax, bx3, by3, 'k-', 'LineWidth', 1.5); % Add vertex labels [x001, y001] = direction2stereoSingle(0, 0, 1); [x011, y011] = direction2stereoSingle(0, 1, 1); [x111, y111] = direction2stereoSingle(1, 1, 1); text(ax, x001 - 0.03, y001 - 0.02, '[001]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'right'); text(ax, x011 + 0.03, y011 - 0.02, '[011]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); text(ax, x111, y111 + 0.03, '[111]', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); % Set colormap if ischar(cmapName) colormap(ax, cmapName); else colormap(ax, cmapName); end % Add colorbar if showColorbar cb = colorbar(ax); if hasProperty switch aggregation case 'mean' cb.Label.String = 'Mean Property Value'; case 'sum' cb.Label.String = 'Sum of Property Values'; case 'count' cb.Label.String = 'Count'; end else cb.Label.String = 'Count'; end end % Format axes axis(ax, 'equal'); axis(ax, 'off'); title(ax, 'IPF Histogram', 'FontSize', 14); hold(ax, 'off'); end function [x, y] = direction2stereo(dirs) % DIRECTION2STEREO Convert multiple directions to stereographic coordinates n = size(dirs, 1); x = zeros(n, 1); y = zeros(n, 1); for i = 1:n [x(i), y(i)] = direction2stereoSingle(dirs(i,1), dirs(i,2), dirs(i,3)); end end function [x, y] = direction2stereoSingle(h, k, l) % DIRECTION2STEREOSINGLE Convert single direction to stereographic coordinates % Normalize norm_d = sqrt(h^2 + k^2 + l^2); if norm_d > 0 h = h / norm_d; k = k / norm_d; l = l / norm_d; end % Stereographic projection theta = acos(l); if (h^2 + k^2) > 0 phi = atan2(k, h); else phi = 0; end r = tan(theta / 2); x_stereo = r * cos(phi); y_stereo = r * sin(phi); % Swap for desired orientation x = y_stereo; y = x_stereo; end function [vertices, faces, colors] = createInterpolatedMesh(xData, yData, values, nGrid) % CREATEINTERPOLATEDMESH Create interpolated mesh for smooth visualization if length(xData) < 3 vertices = []; faces = []; colors = []; return; end % Create fine grid covering the triangle [x001, y001] = direction2stereoSingle(0, 0, 1); [x011, y011] = direction2stereoSingle(0, 1, 1); [x111, y111] = direction2stereoSingle(1, 1, 1); xMin = min([x001, x011, x111]) - 0.01; xMax = max([x001, x011, x111]) + 0.01; yMin = min([y001, y011, y111]) - 0.01; yMax = max([y001, y011, y111]) + 0.01; [xGrid, yGrid] = meshgrid(linspace(xMin, xMax, nGrid), linspace(yMin, yMax, nGrid)); % Interpolate values onto grid try F = scatteredInterpolant(xData, yData, values, 'natural', 'none'); vGrid = F(xGrid, yGrid); catch % Fallback to nearest neighbor vGrid = griddata(xData, yData, values, xGrid, yGrid, 'nearest'); end % Mask points outside the triangle mask = isInsideTriangle(xGrid, yGrid); vGrid(~mask) = NaN; % Convert to patch format [faces, vertices, colors] = surf2patch(xGrid, yGrid, zeros(size(xGrid)), vGrid); % Remove faces with NaN colors validFaces = all(~isnan(colors(faces)), 2); faces = faces(validFaces, :); end function inside = isInsideTriangle(x, y) % ISINSIDETRIANGLE Check if points are inside the standard triangle % Get triangle vertices in stereographic coordinates [x001, y001] = direction2stereoSingle(0, 0, 1); [x011, y011] = direction2stereoSingle(0, 1, 1); [x111, y111] = direction2stereoSingle(1, 1, 1); % Use barycentric coordinates v0 = [x111 - x001, y111 - y001]; v1 = [x011 - x001, y011 - y001]; inside = false(size(x)); for i = 1:numel(x) v2 = [x(i) - x001, y(i) - y001]; dot00 = dot(v0, v0); dot01 = dot(v0, v1); dot02 = dot(v0, v2); dot11 = dot(v1, v1); dot12 = dot(v1, v2); invDenom = 1 / (dot00 * dot11 - dot01 * dot01); u = (dot11 * dot02 - dot01 * dot12) * invDenom; v = (dot00 * dot12 - dot01 * dot02) * invDenom; inside(i) = (u >= -0.01) && (v >= -0.01) && (u + v <= 1.01); end end` | IPFHISTOGRAM Create orientation histogram in the IPF standard triangle |
| `ipfMesh` | `[fvColored, ax] = ipfMesh(fv, orientationInput, varargin) % IPFMESH Colors a mesh based on crystallographic surface normal orientation % % [FVCOLORED, AX] = IPFMESH(FV, ORIENTATIONINPUT) takes a mesh structure % and a crystal orientation, calculates the crystallographic direction of % each vertex normal, and displays the mesh colored according to the IPF % coloring scheme for cubic crystals. % % Input: % fv - Mesh structure with fields: % fv.vertices - Nx3 array of vertex coordinates % fv.faces - Mx3 array of face indices (triangles) % % orientationInput - Either: % - 3x3 rotation matrix describing the orientation % of the crystal coordinate system relative to the % world coordinate system. The matrix transforms % vectors from crystal to world coordinates: % world_vector = R * crystal_vector % - crystalOrientation object % % Optional Name-Value Pairs: % 'plot' - logical, if true displays the mesh (default: true) % 'showLegend' - logical, if true shows IPF triangle legend (default: true) % 'lighting' - logical, if true adds lighting (default: false) % % Output: % fvColored - Structure with fields: % .vertices - same as input % .faces - same as input % .faceVertexCData - Nx3 RGB colors for each vertex % .vertexNormals - Nx3 vertex normals in world coords % .crystalNormals - Nx3 vertex normals in crystal coords % % ax - Axes handle (if plot is true) % % Example: % % Create a sphere mesh % [X,Y,Z] = sphere(50); % fv = surf2patch(X,Y,Z,'triangles'); % % % Define crystal orientation (identity = crystal aligned with world) % R = eye(3); % % % Color and display % [fvColored, ax] = ipfMesh(fv, R); % % % Using crystalOrientation object % ori = crystalOrientation(eye(3), 'cubic'); % [fvColored, ax] = ipfMesh(fv, ori); % % See also: crystalOrientation, ipfColor, patch, surf2patch % Determine input type and extract rotation matrix if isa(orientationInput, 'crystalOrientation') R = orientationInput.getRotationMatrix(); elseif isnumeric(orientationInput) && all(size(orientationInput) == [3, 3]) R = orientationInput; else error('orientationInput must be a 3x3 rotation matrix or a crystalOrientation object'); end % Parse inputs p = inputParser; addRequired(p, 'fv', @(x) isstruct(x) && isfield(x,'vertices') && isfield(x,'faces')); addRequired(p, 'orientationInput'); addParameter(p, 'plot', true, @islogical); addParameter(p, 'showLegend', true, @islogical); addParameter(p, 'lighting', false, @islogical); parse(p, fv, orientationInput, varargin{:}); doPlot = p.Results.plot; showLegend = p.Results.showLegend; useLighting = p.Results.lighting; % Extract mesh data vertices = fv.vertices; faces = fv.faces; nVertices = size(vertices, 1); % Calculate vertex normals vertexNormals = calculateVertexNormals(vertices, faces); % Transform normals from world to crystal coordinates % If R transforms crystal->world, then R' (transpose) transforms world->crystal R_world2crystal = R'; crystalNormals = (R_world2crystal * vertexNormals')'; % Calculate IPF color for each vertex normal vertexColors = zeros(nVertices, 3); for i = 1:nVertices vertexColors(i, :) = ipfColor(crystalNormals(i, :)); end % Create output structure fvColored.vertices = vertices; fvColored.faces = faces; fvColored.faceVertexCData = vertexColors; fvColored.vertexNormals = vertexNormals; fvColored.crystalNormals = crystalNormals; % Plot if requested if doPlot figure('Color', 'w'); if showLegend % Create subplot for mesh and legend ax = subplot(1, 4, [1 2 3]); else ax = axes; end % Display the mesh with vertex colors patch(ax, 'Faces', faces, 'Vertices', vertices, ... 'FaceVertexCData', vertexColors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); axis(ax, 'equal'); xlabel(ax, 'X'); ylabel(ax, 'Y'); zlabel(ax, 'Z'); title(ax, 'IPF Colored Mesh'); view(ax, 3); if useLighting camlight('headlight'); material('dull'); end % Add IPF legend if showLegend axLegend = subplot(1, 4, 4); plotIPFLegend(axLegend); end else ax = []; end end function normals = calculateVertexNormals(vertices, faces) % CALCULATEVERTEXNORMALS Compute vertex normals by averaging face normals % % NORMALS = CALCULATEVERTEXNORMALS(VERTICES, FACES) computes the normal % at each vertex by averaging the normals of all faces sharing that vertex. nVertices = size(vertices, 1); nFaces = size(faces, 1); % Initialize vertex normals normals = zeros(nVertices, 3); % Calculate face normals and accumulate at vertices for i = 1:nFaces % Get vertex indices for this face v1 = faces(i, 1); v2 = faces(i, 2); v3 = faces(i, 3); % Get vertex positions p1 = vertices(v1, :); p2 = vertices(v2, :); p3 = vertices(v3, :); % Calculate face normal using cross product edge1 = p2 - p1; edge2 = p3 - p1; faceNormal = cross(edge1, edge2); % Accumulate to vertex normals (weighted by face area, implicit in cross product magnitude) normals(v1, :) = normals(v1, :) + faceNormal; normals(v2, :) = normals(v2, :) + faceNormal; normals(v3, :) = normals(v3, :) + faceNormal; end % Normalize vertex normals for i = 1:nVertices n = norm(normals(i, :)); if n > 0 normals(i, :) = normals(i, :) / n; end end end function plotIPFLegend(ax) % PLOTIPFLEGEND Plot the IPF standard triangle as a legend axes(ax); hold(ax, 'on'); % Create triangular mesh for continuous coloring nDiv = 50; vertices = []; colors = []; idx = 0; indexMap = zeros(nDiv+1, nDiv+1); for i = 0:nDiv for j = i:nDiv h = i / nDiv; k = j / nDiv; l = 1; [x, y] = legendCoords(h, k, l); idx = idx + 1; vertices(idx, :) = [x, y]; indexMap(i+1, j+1) = idx; rgb = ipfColor([h, k, l]); colors(idx, :) = rgb; end end % Build faces faces = []; for i = 0:(nDiv-1) for j = i:(nDiv-1) idx1 = indexMap(i+1, j+1); idx2 = indexMap(i+1, j+2); idx3 = indexMap(i+2, j+2); faces = [faces; idx1, idx2, idx3]; if j > i idx4 = indexMap(i+2, j+1); faces = [faces; idx1, idx3, idx4]; end end end % Plot mesh patch(ax, 'Faces', faces, 'Vertices', vertices, ... 'FaceVertexCData', colors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); % Plot boundary nBoundary = 100; t = linspace(0, 1, nBoundary); bx1 = zeros(1, nBoundary); by1 = zeros(1, nBoundary); bx2 = zeros(1, nBoundary); by2 = zeros(1, nBoundary); bx3 = zeros(1, nBoundary); by3 = zeros(1, nBoundary); for i = 1:nBoundary [bx1(i), by1(i)] = legendCoords(0, t(i), 1); [bx2(i), by2(i)] = legendCoords(t(i), 1, 1); [bx3(i), by3(i)] = legendCoords(1-t(i), 1-t(i), 1); end plot(ax, bx1, by1, 'k-', 'LineWidth', 1.5); plot(ax, bx2, by2, 'k-', 'LineWidth', 1.5); plot(ax, bx3, by3, 'k-', 'LineWidth', 1.5); % Labels [x001, y001] = legendCoords(0, 0, 1); [x011, y011] = legendCoords(0, 1, 1); [x111, y111] = legendCoords(1, 1, 1); text(ax, x001 - 0.03, y001 - 0.02, '[001]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'right'); text(ax, x011 + 0.03, y011 - 0.02, '[011]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); text(ax, x111, y111 + 0.03, '[111]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); axis(ax, 'equal'); axis(ax, 'off'); title(ax, 'IPF Legend', 'FontSize', 12); hold(ax, 'off'); end function [x, y] = legendCoords(h, k, l) % Convert crystallographic direction to legend plot coordinates % Uses stereographic projection with [001] bottom-left, [011] bottom-right, [111] top norm_d = sqrt(h^2 + k^2 + l^2); if norm_d > 0 h = h / norm_d; k = k / norm_d; l = l / norm_d; end theta = acos(l); if (h^2 + k^2) > 0 phi = atan2(k, h); else phi = 0; end r = tan(theta / 2); x_stereo = r * cos(phi); y_stereo = r * sin(phi); % Swap for desired orientation x = y_stereo; y = x_stereo; end` | IPFMESH Colors a mesh based on crystallographic surface normal orientation |
| `misorientation` | `[angle, axis, details] = misorientation(orientation1, orientation2, crystalSystem) % MISORIENTATION Calculate misorientation between two crystal orientations % % [angle, axis, details] = misorientation(orientation1, orientation2) % [angle, axis, details] = misorientation(orientation1, orientation2, 'cubic') % % Calculates the misorientation angle and axis between two crystal % orientations, accounting for crystal symmetry to find the minimum % (disorientation) angle. % % INPUT: % orientation1 - First orientation as: % - 3x3 rotation matrix % - 4-element quaternion [w, x, y, z] % - 3-element Euler angles [phi1, Phi, phi2] in degrees (Bunge convention) % - crystalOrientation object % orientation2 - Second orientation (same format as orientation1) % crystalSystem - Crystal symmetry (default: 'cubic') % Options: 'cubic', 'hexagonal', 'tetragonal', 'orthorhombic', % 'monoclinic', 'triclinic' % % OUTPUT: % angle - Misorientation angle in degrees (disorientation - minimum angle) % axis - Rotation axis [x, y, z] (unit vector in crystal frame) % details - Structure with additional information: % .fullAngle - Angle before symmetry reduction % .quaternion - Misorientation quaternion % .rotationMatrix - Misorientation rotation matrix % .eulerAngles - Euler angles [phi1, Phi, phi2] % .symmetryOp - Symmetry operator used % .cslType - CSL boundary type if applicable (Sigma value) % % THEORY: % Misorientation: g_mis = g2 * g1^(-1) % Disorientation: minimum angle considering all crystal symmetry equivalents % % For cubic crystals, the maximum disorientation angle is 62.8 degrees. % % EXAMPLES: % % From rotation matrices % R1 = eye(3); % R2 = rotationMatrix([0 0 1], 45); % 45 deg rotation about z % [angle, axis] = misorientation(R1, R2); % % % From Euler angles (Bunge convention, degrees) % euler1 = [0, 0, 0]; % euler2 = [45, 30, 60]; % [angle, axis] = misorientation(euler1, euler2, 'cubic'); % % % From quaternions % q1 = [1, 0, 0, 0]; % Identity % q2 = [0.9659, 0, 0, 0.2588]; % 30 deg about z % [angle, axis] = misorientation(q1, q2); % % REFERENCES: % Randle & Engler (2000) "Texture Analysis" % Morawiec (2004) "Orientations and Rotations" % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments orientation1 orientation2 crystalSystem (1,:) char {mustBeMember(crystalSystem, ... {'cubic', 'hexagonal', 'tetragonal', 'orthorhombic', 'monoclinic', 'triclinic'})} = 'cubic' end % Convert inputs to rotation matrices R1 = toRotationMatrix(orientation1); R2 = toRotationMatrix(orientation2); % Calculate misorientation R_mis = R2 * R1'; % Get crystal symmetry operators symOps = getSymmetryOperators(crystalSystem); nSym = size(symOps, 3); % Find minimum angle (disorientation) considering symmetry minAngle = inf; minAxis = [0; 0; 1]; minSymOp = 1; minQuaternion = [1; 0; 0; 0]; for i = 1:nSym for j = 1:nSym % Apply symmetry: S_i * R_mis * S_j R_test = symOps(:,:,i) * R_mis * symOps(:,:,j); % Convert to angle-axis [testAngle, testAxis] = rotationMatrixToAngleAxis(R_test); % Check if this is the minimum angle if testAngle < minAngle minAngle = testAngle; minAxis = testAxis; minSymOp = i * 100 + j; % Encode both operators minQuaternion = rotationMatrixToQuaternion(R_test); end end end angle = minAngle; axis = minAxis; % Build details structure details = struct(); details.fullAngle = rad2deg(acos((trace(R_mis) - 1) / 2)); details.quaternion = minQuaternion; details.rotationMatrix = quaternionToRotationMatrix(minQuaternion); details.eulerAngles = rotationMatrixToEuler(details.rotationMatrix); details.symmetryOp = minSymOp; details.crystalSystem = crystalSystem; % Check for CSL boundaries details.cslType = checkCSL(angle, axis, crystalSystem); end %% Input Conversion Functions function R = toRotationMatrix(orientation) % Convert various orientation representations to rotation matrix if isa(orientation, 'crystalOrientation') % crystalOrientation object R = orientation.rotationMatrix; elseif isnumeric(orientation) if isequal(size(orientation), [3, 3]) % Already a rotation matrix R = orientation; elseif numel(orientation) == 4 % Quaternion [w, x, y, z] R = quaternionToRotationMatrix(orientation(:)); elseif numel(orientation) == 3 % Euler angles [phi1, Phi, phi2] in degrees R = eulerToRotationMatrix(orientation(:)'); else error('misorientation:invalidInput', ... 'Orientation must be 3x3 matrix, 4-element quaternion, or 3-element Euler angles'); end else error('misorientation:invalidInput', 'Unsupported orientation type'); end end function R = quaternionToRotationMatrix(q) % Convert quaternion [w, x, y, z] to rotation matrix q = q(:) / norm(q); % Normalize w = q(1); x = q(2); y = q(3); z = q(4); R = [1-2*(y^2+z^2), 2*(x*y-z*w), 2*(x*z+y*w); 2*(x*y+z*w), 1-2*(x^2+z^2), 2*(y*z-x*w); 2*(x*z-y*w), 2*(y*z+x*w), 1-2*(x^2+y^2)]; end function q = rotationMatrixToQuaternion(R) % Convert rotation matrix to quaternion [w, x, y, z] t = trace(R); if t > 0 s = 0.5 / sqrt(t + 1); w = 0.25 / s; x = (R(3,2) - R(2,3)) * s; y = (R(1,3) - R(3,1)) * s; z = (R(2,1) - R(1,2)) * s; elseif R(1,1) > R(2,2) && R(1,1) > R(3,3) s = 2 * sqrt(1 + R(1,1) - R(2,2) - R(3,3)); w = (R(3,2) - R(2,3)) / s; x = 0.25 * s; y = (R(1,2) + R(2,1)) / s; z = (R(1,3) + R(3,1)) / s; elseif R(2,2) > R(3,3) s = 2 * sqrt(1 + R(2,2) - R(1,1) - R(3,3)); w = (R(1,3) - R(3,1)) / s; x = (R(1,2) + R(2,1)) / s; y = 0.25 * s; z = (R(2,3) + R(3,2)) / s; else s = 2 * sqrt(1 + R(3,3) - R(1,1) - R(2,2)); w = (R(2,1) - R(1,2)) / s; x = (R(1,3) + R(3,1)) / s; y = (R(2,3) + R(3,2)) / s; z = 0.25 * s; end q = [w; x; y; z]; if w < 0 q = -q; % Ensure positive scalar part end end function R = eulerToRotationMatrix(euler) % Convert Euler angles (Bunge convention, degrees) to rotation matrix % euler = [phi1, Phi, phi2] phi1 = deg2rad(euler(1)); Phi = deg2rad(euler(2)); phi2 = deg2rad(euler(3)); c1 = cos(phi1); s1 = sin(phi1); c = cos(Phi); s = sin(Phi); c2 = cos(phi2); s2 = sin(phi2); R = [c1*c2 - s1*s2*c, s1*c2 + c1*s2*c, s2*s; -c1*s2 - s1*c2*c, -s1*s2 + c1*c2*c, c2*s; s1*s, -c1*s, c]; end function euler = rotationMatrixToEuler(R) % Convert rotation matrix to Euler angles (Bunge convention, degrees) if abs(R(3,3)) < 1 - 1e-8 Phi = acos(R(3,3)); phi1 = atan2(R(3,1)/sin(Phi), -R(3,2)/sin(Phi)); phi2 = atan2(R(1,3)/sin(Phi), R(2,3)/sin(Phi)); else % Gimbal lock Phi = 0; phi1 = atan2(R(1,2), R(1,1)); phi2 = 0; end euler = rad2deg([phi1, Phi, phi2]); % Ensure positive angles euler = mod(euler, 360); end function [angle, axis] = rotationMatrixToAngleAxis(R) % Convert rotation matrix to angle (degrees) and axis % Angle from trace cosAngle = (trace(R) - 1) / 2; cosAngle = max(-1, min(1, cosAngle)); % Clamp to [-1, 1] angle = rad2deg(acos(cosAngle)); if angle < 1e-6 % Identity rotation axis = [0; 0; 1]; elseif abs(angle - 180) < 1e-6 % 180 degree rotation - find axis from R + I [~, idx] = max(diag(R)); axis = (R(:, idx) + eye(3, 1) * (idx == 1) + eye(3, 1) * (idx == 2) * [0;1;0] + eye(3, 1) * (idx == 3) * [0;0;1]); axis = axis / norm(axis); else % General case axis = [R(3,2) - R(2,3); R(1,3) - R(3,1); R(2,1) - R(1,2)]; axis = axis / (2 * sin(deg2rad(angle))); end % Ensure axis points in positive direction (conventional) if axis(1) < 0 || (axis(1) == 0 && axis(2) < 0) || (axis(1) == 0 && axis(2) == 0 && axis(3) < 0) axis = -axis; end end %% Symmetry Operators function symOps = getSymmetryOperators(crystalSystem) % Return symmetry operators for different crystal systems switch lower(crystalSystem) case 'cubic' % 24 proper rotations of cubic system symOps = getCubicSymmetry(); case 'hexagonal' % 12 proper rotations symOps = getHexagonalSymmetry(); case 'tetragonal' % 8 proper rotations symOps = getTetragonalSymmetry(); case 'orthorhombic' % 4 proper rotations symOps = getOrthorhombicSymmetry(); case 'monoclinic' % 2 proper rotations symOps = getMonoclinicSymmetry(); case 'triclinic' % Only identity symOps = eye(3); end end function ops = getCubicSymmetry() % 24 proper rotations of cubic symmetry (point group 432) ops = zeros(3, 3, 24); idx = 1; % Identity ops(:,:,idx) = eye(3); idx = idx + 1; % 90, 180, 270 deg rotations about <100> for axis = 1:3 for angle = [90, 180, 270] ops(:,:,idx) = axisAngleToMatrix(axis, angle); idx = idx + 1; end end % 120, 240 deg rotations about <111> diagonals = [1 1 1; 1 1 -1; 1 -1 1; -1 1 1]; for d = 1:4 for angle = [120, 240] axis = diagonals(d,:); ops(:,:,idx) = rodrigues(axis/norm(axis), deg2rad(angle)); idx = idx + 1; end end % 180 deg rotations about <110> axes110 = [1 1 0; 1 -1 0; 1 0 1; 1 0 -1; 0 1 1; 0 1 -1]; for a = 1:6 axis = axes110(a,:); ops(:,:,idx) = rodrigues(axis/norm(axis), pi); idx = idx + 1; end end function ops = getHexagonalSymmetry() % 12 proper rotations of hexagonal symmetry ops = zeros(3, 3, 12); % Rotations about c-axis (z) for i = 0:5 angle = i * 60; ops(:,:,i+1) = axisAngleToMatrix(3, angle); end % 180 deg rotations about a-axes for i = 0:5 angle_a = i * 60; axis = [cosd(angle_a), sind(angle_a), 0]; ops(:,:,7+i) = rodrigues(axis, pi); end end function ops = getTetragonalSymmetry() % 8 proper rotations ops = zeros(3, 3, 8); ops(:,:,1) = eye(3); % 90, 180, 270 about z ops(:,:,2) = axisAngleToMatrix(3, 90); ops(:,:,3) = axisAngleToMatrix(3, 180); ops(:,:,4) = axisAngleToMatrix(3, 270); % 180 about x, y ops(:,:,5) = axisAngleToMatrix(1, 180); ops(:,:,6) = axisAngleToMatrix(2, 180); % 180 about [110], [1-10] ops(:,:,7) = rodrigues([1 1 0]/sqrt(2), pi); ops(:,:,8) = rodrigues([1 -1 0]/sqrt(2), pi); end function ops = getOrthorhombicSymmetry() % 4 proper rotations ops = zeros(3, 3, 4); ops(:,:,1) = eye(3); ops(:,:,2) = axisAngleToMatrix(1, 180); ops(:,:,3) = axisAngleToMatrix(2, 180); ops(:,:,4) = axisAngleToMatrix(3, 180); end function ops = getMonoclinicSymmetry() % 2 proper rotations ops = zeros(3, 3, 2); ops(:,:,1) = eye(3); ops(:,:,2) = axisAngleToMatrix(2, 180); end function R = axisAngleToMatrix(axisIdx, angleDeg) % Rotation matrix for rotation about coordinate axis c = cosd(angleDeg); s = sind(angleDeg); switch axisIdx case 1 % x-axis R = [1 0 0; 0 c -s; 0 s c]; case 2 % y-axis R = [c 0 s; 0 1 0; -s 0 c]; case 3 % z-axis R = [c -s 0; s c 0; 0 0 1]; end end function R = rodrigues(axis, angle) % Rodrigues formula for rotation matrix axis = axis(:) / norm(axis); K = [0 -axis(3) axis(2); axis(3) 0 -axis(1); -axis(2) axis(1) 0]; R = eye(3) + sin(angle)*K + (1-cos(angle))*(K*K); end %% CSL Boundary Detection function cslType = checkCSL(angle, axis, crystalSystem) % Check if misorientation corresponds to a CSL boundary cslType = ''; if ~strcmpi(crystalSystem, 'cubic') return; % CSL primarily defined for cubic end % Common CSL boundaries for cubic (angle in degrees, axis) cslData = { 3, 60.00, [1 1 1] 5, 36.87, [1 0 0] 7, 38.21, [1 1 1] 9, 38.94, [1 1 0] 11, 50.48, [1 1 0] 13, 22.62, [1 0 0] 15, 48.19, [2 1 0] 17, 28.07, [1 0 0] 19, 26.53, [1 1 0] 21, 21.79, [1 1 1] 25, 16.26, [1 0 0] 27, 31.59, [1 1 0] 29, 43.60, [1 0 0] 31, 17.90, [1 1 1] }; tolerance = 2.0; % degrees for i = 1:size(cslData, 1) sigma = cslData{i, 1}; cslAngle = cslData{i, 2}; cslAxis = cslData{i, 3}; cslAxis = cslAxis / norm(cslAxis); % Check angle if abs(angle - cslAngle) < tolerance % Check axis (considering equivalent directions) axisDot = abs(dot(axis(:), cslAxis(:))); if axisDot > cosd(tolerance) cslType = sprintf('Sigma%d', sigma); return; end end end end` | MISORIENTATION Calculate misorientation between two crystal orientations |
| `boundaryCharacter` | `[charData, ax] = boundaryCharacter(fv, ori1, ori2, varargin) % BOUNDARYCHARACTER Analyze and visualize grain boundary character % % [CHARDATA, AX] = BOUNDARYCHARACTER(FV, ORI1, ORI2) analyzes the character % of a grain boundary between two crystals with orientations ORI1 and ORI2. % Displays the boundary mesh colored by misorientation angle by default. % % The boundary character is determined by: % - Misorientation: The rotation relating the two crystal orientations % - Boundary plane: The interface normal expressed in each crystal's frame % % Input: % fv - Boundary mesh structure with fields: % fv.vertices - Nx3 array of vertex coordinates % fv.faces - Mx3 array of face indices (triangles) % % ori1 - crystalOrientation object or 3x3 rotation matrix for crystal 1 % ori2 - crystalOrientation object or 3x3 rotation matrix for crystal 2 % % Optional Name-Value Pairs: % 'colorBy' - What to color the mesh by: % 'misorientation' (default) - misorientation angle % 'plane1' - boundary plane IPF color in crystal 1 frame % 'plane2' - boundary plane IPF color in crystal 2 frame % 'csl' - CSL sigma value (special boundaries) % 'property' - Nx1 per-vertex property to weight (optional) % 'showIPF' - Logical, show side-by-side IPF triangles (default: true) % 'showCSL' - Logical, identify CSL boundaries (default: true) % 'cslTolerance' - Angular tolerance for CSL detection in degrees (default: 2) % 'colormap' - Colormap for scalar values (default: 'parula') % 'plot' - Logical, create visualization (default: true) % % Output: % charData - Structure with fields: % .misorientation - Misorientation struct with angle, axis % .boundaryPlane1 - Nx3 boundary normals in crystal 1 frame % .boundaryPlane2 - Nx3 boundary normals in crystal 2 frame % .cslSigma - CSL sigma value (NaN if not CSL) % .faceColors - Mx3 RGB colors based on colorBy mode % .vertexNormals - Nx3 boundary normals in world frame % % ax - Axes handles (struct with .mesh, .ipf1, .ipf2 if showIPF is true) % % Example: % % Create boundary mesh (e.g., a flat plane) % [X, Y] = meshgrid(-1:0.1:1, -1:0.1:1); % Z = zeros(size(X)); % fv = surf2patch(X, Y, Z, 'triangles'); % % % Define two crystal orientations % ori1 = crystalOrientation(eye(3), 'cubic'); % ori2 = crystalOrientation(rotationMatrix3D([1,1,1], 60), 'cubic'); % % % Visualize boundary character % [charData, ax] = boundaryCharacter(fv, ori1, ori2); % % % Color by boundary plane in crystal 1 % [charData, ax] = boundaryCharacter(fv, ori1, ori2, 'colorBy', 'plane1'); % % See also: crystalOrientation, ipfMesh, ipfHistogram %% Parse inputs % Extract rotation matrices if isa(ori1, 'crystalOrientation') R1 = ori1.getRotationMatrix(); elseif isnumeric(ori1) && all(size(ori1) == [3, 3]) R1 = ori1; else error('ori1 must be a 3x3 rotation matrix or crystalOrientation object'); end if isa(ori2, 'crystalOrientation') R2 = ori2.getRotationMatrix(); elseif isnumeric(ori2) && all(size(ori2) == [3, 3]) R2 = ori2; else error('ori2 must be a 3x3 rotation matrix or crystalOrientation object'); end p = inputParser; addRequired(p, 'fv', @(x) isstruct(x) && isfield(x,'vertices') && isfield(x,'faces')); addRequired(p, 'ori1'); addRequired(p, 'ori2'); addParameter(p, 'colorBy', 'misorientation', @(x) ismember(lower(x), {'misorientation', 'plane1', 'plane2', 'csl'})); addParameter(p, 'property', [], @(x) isempty(x) || isnumeric(x)); addParameter(p, 'showIPF', true, @islogical); addParameter(p, 'showCSL', true, @islogical); addParameter(p, 'cslTolerance', 2, @(x) isnumeric(x) && isscalar(x) && x > 0); addParameter(p, 'colormap', 'parula', @(x) ischar(x) || (isnumeric(x) && size(x,2)==3)); addParameter(p, 'plot', true, @islogical); parse(p, fv, ori1, ori2, varargin{:}); colorBy = lower(p.Results.colorBy); showIPF = p.Results.showIPF; showCSL = p.Results.showCSL; cslTolerance = p.Results.cslTolerance; cmapName = p.Results.colormap; doPlot = p.Results.plot; vertices = fv.vertices; faces = fv.faces; nVertices = size(vertices, 1); nFaces = size(faces, 1); %% Step 1: Calculate misorientation misori = calculateMisorientation(R1, R2); %% Step 2: Calculate boundary normals in world frame vertexNormals = calculateVertexNormals(vertices, faces); %% Step 3: Transform boundary normals to both crystal frames % R1 transforms crystal1 -> world, so R1' transforms world -> crystal1 boundaryPlane1 = (R1' * vertexNormals')'; boundaryPlane2 = (R2' * vertexNormals')'; %% Step 4: Reduce to fundamental zone for IPF coloring reducedPlane1 = reduceToFundamentalZone(boundaryPlane1); reducedPlane2 = reduceToFundamentalZone(boundaryPlane2); %% Step 5: Detect CSL character if showCSL [cslSigma, cslName] = detectCSL(misori, cslTolerance); else cslSigma = NaN; cslName = ''; end %% Step 6: Calculate colors based on colorBy mode switch colorBy case 'misorientation' % Uniform color based on misorientation angle vertexColors = repmat(misori.angle / 62.8, nVertices, 1); % Normalize to max cubic misorientation vertexColors = repmat([vertexColors, vertexColors, vertexColors], 1, 1); scalarValues = repmat(misori.angle, nVertices, 1); colorLabel = 'Misorientation Angle (°)'; case 'plane1' % IPF color based on boundary plane in crystal 1 frame vertexColors = zeros(nVertices, 3); for i = 1:nVertices vertexColors(i, :) = calculateIPFColor(reducedPlane1(i, :)); end scalarValues = []; colorLabel = 'Boundary Plane (Crystal 1)'; case 'plane2' % IPF color based on boundary plane in crystal 2 frame vertexColors = zeros(nVertices, 3); for i = 1:nVertices vertexColors(i, :) = calculateIPFColor(reducedPlane2(i, :)); end scalarValues = []; colorLabel = 'Boundary Plane (Crystal 2)'; case 'csl' % Color by CSL sigma value if ~isnan(cslSigma) % Use a specific color for the CSL type cslColors = getCSLColors(); if isfield(cslColors, sprintf('sigma%d', cslSigma)) col = cslColors.(sprintf('sigma%d', cslSigma)); else col = [0.5, 0.5, 0.5]; % Gray for unknown CSL end vertexColors = repmat(col, nVertices, 1); else vertexColors = repmat([0.7, 0.7, 0.7], nVertices, 1); % Light gray for non-CSL end scalarValues = repmat(cslSigma, nVertices, 1); colorLabel = 'CSL Sigma Value'; end %% Build output structure charData.misorientation = misori; charData.boundaryPlane1 = boundaryPlane1; charData.boundaryPlane2 = boundaryPlane2; charData.reducedPlane1 = reducedPlane1; charData.reducedPlane2 = reducedPlane2; charData.cslSigma = cslSigma; charData.cslName = cslName; charData.vertexColors = vertexColors; charData.vertexNormals = vertexNormals; charData.R1 = R1; charData.R2 = R2; %% Step 7: Visualization if doPlot ax = struct(); if showIPF % Create figure with mesh and two IPF triangles figure('Color', 'w', 'Position', [100, 100, 1400, 500]); % Mesh plot ax.mesh = subplot(1, 3, 1); plotBoundaryMesh(ax.mesh, fv, vertexColors, scalarValues, cmapName, colorLabel, misori, cslSigma, cslName); % IPF triangle for crystal 1 ax.ipf1 = subplot(1, 3, 2); plotBoundaryIPF(ax.ipf1, reducedPlane1, 'Crystal 1 Frame'); % IPF triangle for crystal 2 ax.ipf2 = subplot(1, 3, 3); plotBoundaryIPF(ax.ipf2, reducedPlane2, 'Crystal 2 Frame'); else figure('Color', 'w'); ax.mesh = axes; plotBoundaryMesh(ax.mesh, fv, vertexColors, scalarValues, cmapName, colorLabel, misori, cslSigma, cslName); end else ax = []; end end %% Helper Functions function normals = calculateVertexNormals(vertices, faces) % Calculate vertex normals by averaging face normals nVertices = size(vertices, 1); nFaces = size(faces, 1); normals = zeros(nVertices, 3); for i = 1:nFaces v1 = faces(i, 1); v2 = faces(i, 2); v3 = faces(i, 3); p1 = vertices(v1, :); p2 = vertices(v2, :); p3 = vertices(v3, :); edge1 = p2 - p1; edge2 = p3 - p1; faceNormal = cross(edge1, edge2); normals(v1, :) = normals(v1, :) + faceNormal; normals(v2, :) = normals(v2, :) + faceNormal; normals(v3, :) = normals(v3, :) + faceNormal; end for i = 1:nVertices n = norm(normals(i, :)); if n > 0 normals(i, :) = normals(i, :) / n; end end end function misori = calculateMisorientation(R1, R2) % Calculate misorientation between two orientations % For cubic symmetry, finds the minimum angle among all equivalent misorientations % Misorientation: rotation from crystal 1 to crystal 2 % deltaR = R2 * R1' (in world frame) % or equivalently in crystal frame: R1' * R2 deltaR = R1' * R2; % Get cubic symmetry operators symOps = getCubicSymmetryOperators(); % Find minimum misorientation angle minAngle = 180; minAxis = [0, 0, 1]; minR = deltaR; for i = 1:size(symOps, 3) for j = 1:size(symOps, 3) % Apply symmetry: Si * deltaR * Sj' Rtest = symOps(:,:,i) * deltaR * symOps(:,:,j)'; % Extract angle from rotation matrix traceR = trace(Rtest); traceR = max(-1, min(3, traceR)); % Clamp for numerical stability angle = acosd((traceR - 1) / 2); if angle < minAngle minAngle = angle; minR = Rtest; % Extract axis if angle > 0.01 && angle < 179.99 axis = [Rtest(3,2) - Rtest(2,3); Rtest(1,3) - Rtest(3,1); Rtest(2,1) - Rtest(1,2)]; axis = axis / norm(axis); minAxis = axis'; end end end end misori.angle = minAngle; misori.axis = minAxis; misori.matrix = minR; end function symOps = getCubicSymmetryOperators() % Return the 24 cubic symmetry operators symOps = zeros(3, 3, 24); % Identity symOps(:,:,1) = eye(3); % 90° rotations about <100> symOps(:,:,2) = [1 0 0; 0 0 -1; 0 1 0]; % 90° about [100] symOps(:,:,3) = [1 0 0; 0 -1 0; 0 0 -1]; % 180° about [100] symOps(:,:,4) = [1 0 0; 0 0 1; 0 -1 0]; % 270° about [100] symOps(:,:,5) = [0 0 1; 0 1 0; -1 0 0]; % 90° about [010] symOps(:,:,6) = [-1 0 0; 0 1 0; 0 0 -1]; % 180° about [010] symOps(:,:,7) = [0 0 -1; 0 1 0; 1 0 0]; % 270° about [010] symOps(:,:,8) = [0 -1 0; 1 0 0; 0 0 1]; % 90° about [001] symOps(:,:,9) = [-1 0 0; 0 -1 0; 0 0 1]; % 180° about [001] symOps(:,:,10) = [0 1 0; -1 0 0; 0 0 1]; % 270° about [001] % 120° rotations about <111> symOps(:,:,11) = [0 0 1; 1 0 0; 0 1 0]; % 120° about [111] symOps(:,:,12) = [0 1 0; 0 0 1; 1 0 0]; % 240° about [111] symOps(:,:,13) = [0 0 -1; -1 0 0; 0 1 0]; % 120° about [-1,1,1] symOps(:,:,14) = [0 -1 0; 0 0 1; -1 0 0]; % 240° about [-1,1,1] symOps(:,:,15) = [0 0 1; -1 0 0; 0 -1 0]; % 120° about [1,-1,1] symOps(:,:,16) = [0 -1 0; 0 0 -1; 1 0 0]; % 240° about [1,-1,1] symOps(:,:,17) = [0 0 -1; 1 0 0; 0 -1 0]; % 120° about [1,1,-1] symOps(:,:,18) = [0 1 0; 0 0 -1; -1 0 0]; % 240° about [1,1,-1] % 180° rotations about <110> symOps(:,:,19) = [0 1 0; 1 0 0; 0 0 -1]; % 180° about [110] symOps(:,:,20) = [0 -1 0; -1 0 0; 0 0 -1];% 180° about [-110] symOps(:,:,21) = [-1 0 0; 0 0 1; 0 1 0]; % 180° about [011] symOps(:,:,22) = [-1 0 0; 0 0 -1; 0 -1 0];% 180° about [0-11] symOps(:,:,23) = [0 0 1; 0 -1 0; 1 0 0]; % 180° about [101] symOps(:,:,24) = [0 0 -1; 0 -1 0; -1 0 0];% 180° about [-101] end function reduced = reduceToFundamentalZone(directions) % Reduce directions to standard triangle nDirs = size(directions, 1); reduced = zeros(nDirs, 3); for i = 1:nDirs dir = directions(i, :); n = norm(dir); if n > 0 dir = dir / n; end dirAbs = abs(dir); dirSorted = sort(dirAbs, 'ascend'); reduced(i, :) = dirSorted; end end function [sigma, name] = detectCSL(misori, tolerance) % Detect if misorientation corresponds to a CSL boundary % Returns sigma value and name, or NaN if not CSL % Common CSL boundaries for cubic crystals % Format: [sigma, angle, axis_h, axis_k, axis_l] cslTable = [ 3, 60.00, 1, 1, 1; % Sigma 3 (twin) 5, 36.87, 1, 0, 0; % Sigma 5 7, 38.21, 1, 1, 1; % Sigma 7 9, 38.94, 1, 1, 0; % Sigma 9 11, 50.48, 1, 1, 0; % Sigma 11 13, 22.62, 1, 0, 0; % Sigma 13a 13, 27.80, 1, 1, 1; % Sigma 13b 15, 48.19, 2, 1, 0; % Sigma 15 17, 28.07, 1, 0, 0; % Sigma 17a 17, 61.93, 2, 2, 1; % Sigma 17b 19, 26.53, 1, 1, 0; % Sigma 19a 19, 46.83, 1, 1, 1; % Sigma 19b 21, 21.79, 1, 1, 1; % Sigma 21a 21, 44.42, 2, 1, 1; % Sigma 21b 23, 40.45, 3, 1, 1; % Sigma 23 25, 16.26, 1, 0, 0; % Sigma 25a 25, 51.68, 3, 3, 1; % Sigma 25b 27, 31.59, 1, 1, 0; % Sigma 27a 27, 35.43, 2, 1, 0; % Sigma 27b 29, 43.60, 1, 0, 0; % Sigma 29a 29, 46.40, 2, 2, 1; % Sigma 29b ]; sigma = NaN; name = ''; angle = misori.angle; axis = misori.axis; % Normalize axis axis = abs(axis); axis = sort(axis, 'descend'); for i = 1:size(cslTable, 1) cslAngle = cslTable(i, 2); cslAxis = cslTable(i, 3:5); cslAxis = cslAxis / norm(cslAxis); cslAxis = sort(abs(cslAxis), 'descend'); % Check angle match if abs(angle - cslAngle) <= tolerance % Check axis match (allow some tolerance) axisDiff = norm(axis - cslAxis); if axisDiff < 0.1 sigma = cslTable(i, 1); name = sprintf('Sigma %d', sigma); return; end end end end function rgb = calculateIPFColor(direction) % Calculate IPF color for a direction in fundamental zone h = direction(1); k = direction(2); l = direction(3); % Normalize so l = 1 if l > 0 h = h / l; k = k / l; else rgb = [0, 0, 0]; return; end % Color components red = h; green = k - h; blue = 1 - k; % Normalize to max = 1 maxVal = max([red, green, blue]); if maxVal > 0 rgb = [red, green, blue] / maxVal; else rgb = [0, 0, 1]; end rgb = max(0, min(1, rgb)); end function colors = getCSLColors() % Define colors for common CSL types colors.sigma3 = [1, 0, 0]; % Red - twin colors.sigma5 = [0, 0.7, 0]; % Green colors.sigma7 = [0, 0, 1]; % Blue colors.sigma9 = [1, 0.5, 0]; % Orange colors.sigma11 = [0.5, 0, 0.5]; % Purple colors.sigma13 = [0, 0.7, 0.7]; % Cyan colors.sigma15 = [0.7, 0.7, 0]; % Yellow colors.sigma17 = [1, 0, 0.5]; % Pink colors.sigma19 = [0.5, 0.5, 0]; % Olive colors.sigma21 = [0, 0.5, 0.5]; % Teal colors.sigma25 = [0.5, 0, 0]; % Dark red colors.sigma27 = [0, 0.5, 0]; % Dark green colors.sigma29 = [0, 0, 0.5]; % Dark blue end function plotBoundaryMesh(ax, fv, vertexColors, scalarValues, cmapName, colorLabel, misori, cslSigma, cslName) % Plot the boundary mesh with colors axes(ax); hold(ax, 'on'); % Check if colors are RGB or scalar if size(vertexColors, 2) == 3 && isempty(scalarValues) % RGB colors (IPF) patch(ax, 'Faces', fv.faces, 'Vertices', fv.vertices, ... 'FaceVertexCData', vertexColors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); else % Scalar values with colormap if ~isempty(scalarValues) patch(ax, 'Faces', fv.faces, 'Vertices', fv.vertices, ... 'FaceVertexCData', scalarValues, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); colormap(ax, cmapName); cb = colorbar(ax); cb.Label.String = colorLabel; else patch(ax, 'Faces', fv.faces, 'Vertices', fv.vertices, ... 'FaceVertexCData', vertexColors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none'); end end axis(ax, 'equal'); xlabel(ax, 'X'); ylabel(ax, 'Y'); zlabel(ax, 'Z'); % Title with misorientation info titleStr = sprintf('Boundary: %.1f° about [%.2f, %.2f, %.2f]', ... misori.angle, misori.axis(1), misori.axis(2), misori.axis(3)); if ~isnan(cslSigma) titleStr = sprintf('%s\n%s', titleStr, cslName); end title(ax, titleStr, 'FontSize', 11); view(ax, 3); rotate3d(ax, 'on'); hold(ax, 'off'); end function plotBoundaryIPF(ax, reducedNormals, titleStr) % Plot boundary plane distribution in IPF triangle axes(ax); hold(ax, 'on'); % Draw the colored standard triangle background drawStandardTriangle(ax); % Plot the boundary plane orientations as points [x, y] = direction2stereo(reducedNormals); scatter(ax, x, y, 20, 'k', 'filled', 'MarkerFaceAlpha', 0.5); % Draw triangle boundary drawTriangleBoundary(ax); % Labels [x001, y001] = direction2stereoSingle(0, 0, 1); [x011, y011] = direction2stereoSingle(0, 1, 1); [x111, y111] = direction2stereoSingle(1, 1, 1); text(ax, x001 - 0.03, y001 - 0.02, '[001]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'right'); text(ax, x011 + 0.03, y011 - 0.02, '[011]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); text(ax, x111, y111 + 0.03, '[111]', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); axis(ax, 'equal'); axis(ax, 'off'); title(ax, titleStr, 'FontSize', 12); hold(ax, 'off'); end function drawStandardTriangle(ax) % Draw the IPF-colored standard triangle nDiv = 50; vertices = []; colors = []; indexMap = zeros(nDiv+1, nDiv+1); idx = 0; for i = 0:nDiv for j = i:nDiv h = i / nDiv; k = j / nDiv; l = 1; [x, y] = direction2stereoSingle(h, k, l); idx = idx + 1; vertices(idx, :) = [x, y]; indexMap(i+1, j+1) = idx; rgb = calculateIPFColor([h, k, l]); colors(idx, :) = rgb; end end % Build faces faces = []; for i = 0:(nDiv-1) for j = i:(nDiv-1) idx1 = indexMap(i+1, j+1); idx2 = indexMap(i+1, j+2); idx3 = indexMap(i+2, j+2); faces = [faces; idx1, idx2, idx3]; if j > i idx4 = indexMap(i+2, j+1); faces = [faces; idx1, idx3, idx4]; end end end patch(ax, 'Faces', faces, 'Vertices', vertices, ... 'FaceVertexCData', colors, ... 'FaceColor', 'interp', ... 'EdgeColor', 'none', ... 'FaceAlpha', 0.3); end function drawTriangleBoundary(ax) % Draw the triangle boundary lines nBoundary = 100; t = linspace(0, 1, nBoundary); bx1 = zeros(1, nBoundary); by1 = zeros(1, nBoundary); bx2 = zeros(1, nBoundary); by2 = zeros(1, nBoundary); bx3 = zeros(1, nBoundary); by3 = zeros(1, nBoundary); for i = 1:nBoundary [bx1(i), by1(i)] = direction2stereoSingle(0, t(i), 1); [bx2(i), by2(i)] = direction2stereoSingle(t(i), 1, 1); [bx3(i), by3(i)] = direction2stereoSingle(1-t(i), 1-t(i), 1); end plot(ax, bx1, by1, 'k-', 'LineWidth', 1.5); plot(ax, bx2, by2, 'k-', 'LineWidth', 1.5); plot(ax, bx3, by3, 'k-', 'LineWidth', 1.5); end function [x, y] = direction2stereo(dirs) % Convert multiple directions to stereographic coordinates n = size(dirs, 1); x = zeros(n, 1); y = zeros(n, 1); for i = 1:n [x(i), y(i)] = direction2stereoSingle(dirs(i,1), dirs(i,2), dirs(i,3)); end end function [x, y] = direction2stereoSingle(h, k, l) % Convert single direction to stereographic coordinates norm_d = sqrt(h^2 + k^2 + l^2); if norm_d > 0 h = h / norm_d; k = k / norm_d; l = l / norm_d; end theta = acos(l); if (h^2 + k^2) > 0 phi = atan2(k, h); else phi = 0; end r = tan(theta / 2); x_stereo = r * cos(phi); y_stereo = r * sin(phi); x = y_stereo; y = x_stereo; end` | BOUNDARYCHARACTER Analyze and visualize grain boundary character |
| `stereoProj` | `[ori, ax] = stereoProj(orientationInput, varargin) % STEREOPROJ Creates a stereographic projection of crystallographic poles % % [ORI, AX] = STEREOPROJ(CRYSTALORIENTATION) creates a stereographic projection % showing the poles of common crystallographic plane families for a crystal % with the given orientation. % % The projection uses the APT (atom probe tomography) convention: % - View is looking down the +Z axis (analysis direction) % - +Z direction is at the center of the projection % - X-Y plane forms the projection plane (+X right, +Y up) % % Input: % orientationInput - Either: % - 3x3 rotation matrix describing the orientation % of the crystal coordinate system relative to the % world coordinate system (crystal to world transform) % - crystalOrientation object % % Optional Name-Value Pairs: % 'crystalSystem' - Crystal system name (default: 'cubic') % Only used if input is a rotation matrix. % Options: 'cubic', 'hexagonal', 'tetragonal', % 'orthorhombic', 'monoclinic', 'triclinic' % 'poles' - Cell array of pole families to display % (default: {'001', '011', '111'}) % 'showWulff' - logical, show Wulff net grid (default: true) % 'showLabels' - logical, show pole labels (default: true) % 'upperOnly' - logical, show only upper hemisphere (default: true) % 'markerSize' - size of pole markers (default: 80) % 'showCube' - logical, show orientation cube (default: true) % % Output: % ori - crystalOrientation object with current orientation % ax - Axes handle % % Interactive Use: % After interactive manipulation, retrieve the current orientation: % ori = getCurrentOrientation(figHandle) % % Pole family notation: % '001' - {100} family: (100), (010), (001), etc. % '011' - {110} family: (110), (101), (011), etc. % '111' - {111} family: (111), etc. % '012' - {012} family: (012), (021), (102), etc. % '112' - {112} family % '122' - {122} family % '113' - {113} family % % Example: % % Identity orientation (crystal aligned with world) % R = eye(3); % [ori, ax] = stereoProj(R); % % % Using crystalOrientation object % ori = crystalOrientation(eye(3), 'cubic'); % [ori, ax] = stereoProj(ori); % % % Show specific pole families with hexagonal system % R = eye(3); % stereoProj(R, 'crystalSystem', 'hexagonal', 'poles', {'001', '011', '111'}); % % % Get orientation after interactive manipulation % [~, ax] = stereoProj(eye(3)); % % ... user drags poles interactively ... % ori = getCurrentOrientation(ancestor(ax, 'figure')); % % See also: crystalOrientation, ipfColor, ipfMesh, getCurrentOrientation % Determine input type and extract rotation matrix if isa(orientationInput, 'crystalOrientation') R = orientationInput.getRotationMatrix(); inputCrystalSystem = orientationInput.crystalSystem; inputOriObject = orientationInput; elseif isnumeric(orientationInput) && all(size(orientationInput) == [3, 3]) R = orientationInput; inputCrystalSystem = ''; % Will use parameter or default inputOriObject = []; else error('Input must be a 3x3 rotation matrix or a crystalOrientation object'); end % Parse inputs p = inputParser; addRequired(p, 'orientationInput'); addParameter(p, 'crystalSystem', 'cubic', @(x) ischar(x) || isstring(x)); addParameter(p, 'poles', {'001', '011', '111'}, @iscell); addParameter(p, 'showWulff', true, @islogical); addParameter(p, 'showLabels', true, @islogical); addParameter(p, 'upperOnly', true, @islogical); addParameter(p, 'markerSize', 80, @isnumeric); addParameter(p, 'showCube', true, @islogical); parse(p, orientationInput, varargin{:}); % Determine crystal system (input object takes precedence over parameter) if ~isempty(inputCrystalSystem) cSystem = inputCrystalSystem; else cSystem = char(p.Results.crystalSystem); end % Create crystalOrientation object if not provided if isempty(inputOriObject) ori = crystalOrientation(R, cSystem); else ori = inputOriObject; end poleFamilies = p.Results.poles; showWulff = p.Results.showWulff; showLabels = p.Results.showLabels; upperOnly = p.Results.upperOnly; markerSize = p.Results.markerSize; showCube = p.Results.showCube; % Create figure figure('Color', 'w'); if showCube % Create subplot layout: stereographic projection on left, cube on right ax = subplot(1, 5, [1 2 3 4]); else ax = axes; end hold(ax, 'on'); % Draw the Wulff net if requested if showWulff drawWulffNet(ax); else % Just draw the outer circle theta = linspace(0, 2*pi, 100); plot(ax, cos(theta), sin(theta), 'k-', 'LineWidth', 1.5); end % Define colors and markers for different pole families poleStyles = struct(); poleStyles.p001 = struct('color', [0 0 1], 'marker', 's'); % Blue squares poleStyles.p011 = struct('color', [0 0.7 0], 'marker', 'd'); % Green diamonds poleStyles.p111 = struct('color', [1 0 0], 'marker', '^'); % Red triangles poleStyles.p012 = struct('color', [1 0.5 0], 'marker', 'o'); % Orange circles poleStyles.p112 = struct('color', [0.5 0 0.5], 'marker', 'v'); % Purple down-triangles poleStyles.p122 = struct('color', [0 0.5 0.5], 'marker', 'p'); % Teal pentagons poleStyles.p113 = struct('color', [0.5 0.5 0], 'marker', 'h'); % Olive hexagons poleStyles.p123 = struct('color', [0.3 0.3 0.3], 'marker', 'o'); % Gray circles % Plot each pole family legendEntries = {}; legendHandles = []; for i = 1:length(poleFamilies) family = poleFamilies{i}; poles = generatePoleFamily(family); % Get style for this family styleField = ['p', family]; if isfield(poleStyles, styleField) style = poleStyles.(styleField); else style = struct('color', rand(1,3), 'marker', 'o'); end % Track projected positions to avoid duplicates projectedPositions = []; projectedLabels = {}; % Transform poles to world coordinates and project for j = 1:size(poles, 1) pole = poles(j, :); pole = pole / norm(pole); % Transform to world coordinates worldPole = (R * pole')'; % Check hemisphere if upperOnly && worldPole(3) < 0 worldPole = -worldPole; % Project antipodal point end if worldPole(3) >= 0 || ~upperOnly % Stereographic projection [x, y] = stereoProject(worldPole); % Check if we already have a pole at this position isDuplicate = false; for k = 1:size(projectedPositions, 1) if norm([x, y] - projectedPositions(k, :)) < 0.01 isDuplicate = true; break; end end % Plot if within bounds and not a duplicate if x^2 + y^2 <= 1.01 && ~isDuplicate h = scatter(ax, x, y, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k', 'LineWidth', 0.5); % Track this position projectedPositions = [projectedPositions; x, y]; % Add label if requested if showLabels labelStr = sprintf('(%d%d%d)', poles(j,1), poles(j,2), poles(j,3)); text(ax, x + 0.03, y + 0.03, labelStr, 'FontSize', 8); end end end end % Store for legend legendHandles(end+1) = scatter(ax, nan, nan, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k'); legendEntries{end+1} = ['{', family(1), family(2), family(3), '}']; end % Add coordinate markers for APT convention (looking down +z) % Center is +z direction, x-y plane is the projection plane text(ax, 1.12, 0, '+X', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(ax, -1.12, 0, '-X', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(ax, 0, 1.12, '+Y', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(ax, 0, -1.12, '-Y', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(ax, 0.05, 0.05, '+Z', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); % Format axes axis(ax, 'equal'); xlim(ax, [-1.3, 1.3]); ylim(ax, [-1.3, 1.3]); axis(ax, 'off'); title(ax, 'Stereographic Projection', 'FontSize', 14); % Add legend if ~isempty(legendHandles) legend(ax, legendHandles, legendEntries, 'Location', 'eastoutside'); end hold(ax, 'off'); % Draw orientation cube if showCube axCube = subplot(1, 5, 5); drawOrientationCube(axCube, R); % Tag the axes for reliable retrieval in callbacks ax.Tag = 'stereoAxis'; axCube.Tag = 'cubeAxis'; % Store data for interactive updates figHandle = gcf; setappdata(figHandle, 'rotationMatrix', R); setappdata(figHandle, 'baseRotationMatrix', R); % Original orientation (doesn't change) setappdata(figHandle, 'crystalOrientationObject', ori); setappdata(figHandle, 'crystalSystem', cSystem); setappdata(figHandle, 'poleFamilies', poleFamilies); setappdata(figHandle, 'showWulff', showWulff); setappdata(figHandle, 'showLabels', showLabels); setappdata(figHandle, 'upperOnly', upperOnly); setappdata(figHandle, 'markerSize', markerSize); setappdata(figHandle, 'poleStyles', poleStyles); % Enable interactive rotation on cube only h = rotate3d(figHandle); h.Enable = 'on'; h.ActionPostCallback = @updateAfterRotation; setAllowAxesRotate(h, ax, false); % Disable rotation on stereo axis setAllowAxesRotate(h, axCube, true); % Enable rotation on cube axis % Add instruction text for cube annotation(figHandle, 'textbox', [0.75, 0.02, 0.25, 0.05], ... 'String', 'Drag cube to rotate crystal', ... 'EdgeColor', 'none', 'HorizontalAlignment', 'center', ... 'FontSize', 9, 'FontAngle', 'italic'); % Add orientation control panel createOrientationPanel(figHandle, R); end end function createOrientationPanel(figHandle, R) % Create editable UI controls for orientation % Get Euler angles [phi1, Phi, phi2] = rotmat2euler(R); % Create panel hPanel = uipanel(figHandle, 'Title', 'Orientation', ... 'Units', 'normalized', ... 'Position', [0.01, 0.01, 0.28, 0.22], ... 'FontSize', 9); % Euler angles section uicontrol(hPanel, 'Style', 'text', 'String', 'Euler Angles (Bunge ZXZ):', ... 'Units', 'normalized', 'Position', [0.02, 0.82, 0.96, 0.15], ... 'HorizontalAlignment', 'left', 'FontSize', 8); % phi1 uicontrol(hPanel, 'Style', 'text', 'String', 'φ1:', ... 'Units', 'normalized', 'Position', [0.02, 0.62, 0.15, 0.15], ... 'HorizontalAlignment', 'right', 'FontSize', 8); hPhi1 = uicontrol(hPanel, 'Style', 'edit', 'String', sprintf('%.1f', phi1), ... 'Units', 'normalized', 'Position', [0.18, 0.64, 0.25, 0.15], ... 'FontSize', 8, 'Tag', 'phi1Edit', ... 'Callback', @(src,~) eulerEditCallback(figHandle)); % Phi uicontrol(hPanel, 'Style', 'text', 'String', 'Φ:', ... 'Units', 'normalized', 'Position', [0.45, 0.62, 0.12, 0.15], ... 'HorizontalAlignment', 'right', 'FontSize', 8); hPhi = uicontrol(hPanel, 'Style', 'edit', 'String', sprintf('%.1f', Phi), ... 'Units', 'normalized', 'Position', [0.58, 0.64, 0.25, 0.15], ... 'FontSize', 8, 'Tag', 'PhiEdit', ... 'Callback', @(src,~) eulerEditCallback(figHandle)); % phi2 uicontrol(hPanel, 'Style', 'text', 'String', 'φ2:', ... 'Units', 'normalized', 'Position', [0.02, 0.42, 0.15, 0.15], ... 'HorizontalAlignment', 'right', 'FontSize', 8); hPhi2 = uicontrol(hPanel, 'Style', 'edit', 'String', sprintf('%.1f', phi2), ... 'Units', 'normalized', 'Position', [0.18, 0.44, 0.25, 0.15], ... 'FontSize', 8, 'Tag', 'phi2Edit', ... 'Callback', @(src,~) eulerEditCallback(figHandle)); % Degree symbol labels uicontrol(hPanel, 'Style', 'text', 'String', '°', ... 'Units', 'normalized', 'Position', [0.43, 0.62, 0.05, 0.15], ... 'HorizontalAlignment', 'left', 'FontSize', 8); uicontrol(hPanel, 'Style', 'text', 'String', '°', ... 'Units', 'normalized', 'Position', [0.83, 0.62, 0.05, 0.15], ... 'HorizontalAlignment', 'left', 'FontSize', 8); uicontrol(hPanel, 'Style', 'text', 'String', '°', ... 'Units', 'normalized', 'Position', [0.43, 0.42, 0.05, 0.15], ... 'HorizontalAlignment', 'left', 'FontSize', 8); % Rotation matrix display (read-only) uicontrol(hPanel, 'Style', 'text', 'String', 'Rotation Matrix:', ... 'Units', 'normalized', 'Position', [0.02, 0.22, 0.96, 0.15], ... 'HorizontalAlignment', 'left', 'FontSize', 8); matStr = sprintf('%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f', ... R(1,1), R(1,2), R(1,3), R(2,1), R(2,2), R(2,3), R(3,1), R(3,2), R(3,3)); hMat = uicontrol(hPanel, 'Style', 'text', 'String', matStr, ... 'Units', 'normalized', 'Position', [0.02, 0.02, 0.96, 0.22], ... 'HorizontalAlignment', 'left', 'FontSize', 7, ... 'FontName', 'FixedWidth', 'Tag', 'matrixDisplay'); % Store handles setappdata(figHandle, 'hPhi1', hPhi1); setappdata(figHandle, 'hPhi', hPhi); setappdata(figHandle, 'hPhi2', hPhi2); setappdata(figHandle, 'hMatrixDisplay', hMat); setappdata(figHandle, 'hOrientationPanel', hPanel); end function eulerEditCallback(figHandle) % Callback when Euler angles are edited % Get edit box handles hPhi1 = getappdata(figHandle, 'hPhi1'); hPhi = getappdata(figHandle, 'hPhi'); hPhi2 = getappdata(figHandle, 'hPhi2'); % Parse values phi1 = str2double(get(hPhi1, 'String')); Phi = str2double(get(hPhi, 'String')); phi2 = str2double(get(hPhi2, 'String')); % Validate if isnan(phi1) || isnan(Phi) || isnan(phi2) return; % Invalid input, do nothing end % Convert Euler angles to rotation matrix R_new = euler2rotmat(phi1, Phi, phi2); % Update stored orientation setappdata(figHandle, 'rotationMatrix', R_new); setappdata(figHandle, 'baseRotationMatrix', R_new); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_new, cSystem)); % Update matrix display hMat = getappdata(figHandle, 'hMatrixDisplay'); matStr = sprintf('%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f', ... R_new(1,1), R_new(1,2), R_new(1,3), ... R_new(2,1), R_new(2,2), R_new(2,3), ... R_new(3,1), R_new(3,2), R_new(3,3)); set(hMat, 'String', matStr); % Reset cube view to default axCube = findobj(figHandle, 'Type', 'axes', 'Tag', 'cubeAxis'); if ~isempty(axCube) view(axCube, [-90, 90]); cla(axCube); drawOrientationCube(axCube, R_new); end % Update stereographic projection updateStereoProjection(figHandle, R_new); end function updateStereoProjection(figHandle, R_effective) % Update the stereographic projection with new orientation poleFamilies = getappdata(figHandle, 'poleFamilies'); showWulff = getappdata(figHandle, 'showWulff'); showLabels = getappdata(figHandle, 'showLabels'); upperOnly = getappdata(figHandle, 'upperOnly'); markerSize = getappdata(figHandle, 'markerSize'); % Delete old stereo axes and create new one axStereo = findobj(figHandle, 'Type', 'axes', 'Tag', 'stereoAxis'); if ~isempty(axStereo) delete(axStereo); end % Create fresh axes for stereographic projection axStereo = subplot(1, 5, [1 2 3 4], 'Parent', figHandle); axStereo.Tag = 'stereoAxis'; hold(axStereo, 'on'); % Redraw Wulff net if showWulff drawWulffNetOnAxis(axStereo); else theta = linspace(0, 2*pi, 100); plot(axStereo, cos(theta), sin(theta), 'k-', 'LineWidth', 1.5, 'HandleVisibility', 'off'); end % Get pole styles poleStyles = getappdata(figHandle, 'poleStyles'); % Legend tracking legendHandles = []; legendEntries = {}; for i = 1:length(poleFamilies) family = poleFamilies{i}; poles = generatePoleFamily(family); styleField = ['p', family]; if isfield(poleStyles, styleField) style = poleStyles.(styleField); else style = struct('color', rand(1,3), 'marker', 'o'); end projectedPositions = []; for j = 1:size(poles, 1) pole = poles(j, :); pole = pole / norm(pole); worldPole = (R_effective * pole')'; if upperOnly && worldPole(3) < 0 worldPole = -worldPole; end if worldPole(3) >= 0 || ~upperOnly [x, y] = stereoProject(worldPole); isDuplicate = false; for k = 1:size(projectedPositions, 1) if norm([x, y] - projectedPositions(k, :)) < 0.01 isDuplicate = true; break; end end if x^2 + y^2 <= 1.01 && ~isDuplicate scatter(axStereo, x, y, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k', 'LineWidth', 0.5, ... 'HandleVisibility', 'off'); projectedPositions = [projectedPositions; x, y]; if showLabels labelStr = sprintf('(%d%d%d)', poles(j,1), poles(j,2), poles(j,3)); text(axStereo, x + 0.03, y + 0.03, labelStr, 'FontSize', 8); end end end end % Add legend entry legendHandles(end+1) = scatter(axStereo, nan, nan, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k'); legendEntries{end+1} = ['{', family(1), family(2), family(3), '}']; end % Coordinate markers text(axStereo, 1.12, 0, '+X', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(axStereo, -1.12, 0, '-X', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(axStereo, 0, 1.12, '+Y', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(axStereo, 0, -1.12, '-Y', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(axStereo, 0.05, 0.05, '+Z', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); % Legend if ~isempty(legendHandles) legend(axStereo, legendHandles, legendEntries, 'Location', 'eastoutside'); end axis(axStereo, 'equal'); xlim(axStereo, [-1.3, 1.3]); ylim(axStereo, [-1.3, 1.3]); axis(axStereo, 'off'); title(axStereo, 'Stereographic Projection', 'FontSize', 14); % Prevent 3D rotation on stereo axes h = rotate3d(figHandle); setAllowAxesRotate(h, axStereo, false); hold(axStereo, 'off'); end function updateAfterRotation(~, evd) % Callback function after cube rotation - updates stereographic projection axCube = evd.Axes; figHandle = ancestor(axCube, 'figure'); % Get stored data R_base = getappdata(figHandle, 'baseRotationMatrix'); % Original crystal orientation % Get the view angles from the cube axes [az, el] = view(axCube); % Use MATLAB's viewmtx to get the transformation matrix % viewmtx returns a 4x4 matrix that transforms world to view coordinates T = viewmtx(az, el); % Extract 3x3 rotation part (upper-left) % This transforms world directions to view directions % In view coords: +X is right, +Y is up, +Z is out of screen (toward viewer) R_view = T(1:3, 1:3); % For stereo projection, we need directions in a frame where % +Z points toward the viewer (center of projection) % The view matrix already does this transformation % Effective crystal orientation for stereo projection R_effective = R_view * R_base; % Store for potential retrieval setappdata(figHandle, 'rotationMatrix', R_effective); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_effective, cSystem)); % Update stereo projection updateStereoProjection(figHandle, R_effective); % Update orientation UI panel updateOrientationUI(figHandle, R_effective); end function updateOrientationUI(figHandle, R) % Update the Euler angle edit boxes and matrix display % Compute Euler angles [phi1, Phi, phi2] = rotmat2euler(R); % Update edit boxes hPhi1 = getappdata(figHandle, 'hPhi1'); hPhi = getappdata(figHandle, 'hPhi'); hPhi2 = getappdata(figHandle, 'hPhi2'); hMat = getappdata(figHandle, 'hMatrixDisplay'); if ~isempty(hPhi1) && isvalid(hPhi1) set(hPhi1, 'String', sprintf('%.1f', phi1)); end if ~isempty(hPhi) && isvalid(hPhi) set(hPhi, 'String', sprintf('%.1f', Phi)); end if ~isempty(hPhi2) && isvalid(hPhi2) set(hPhi2, 'String', sprintf('%.1f', phi2)); end % Update matrix display if ~isempty(hMat) && isvalid(hMat) matStr = sprintf('%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f\n%6.3f %6.3f %6.3f', ... R(1,1), R(1,2), R(1,3), ... R(2,1), R(2,2), R(2,3), ... R(3,1), R(3,2), R(3,3)); set(hMat, 'String', matStr); end end function drawWulffNetOnAxis(ax) % Draw Wulff net on specified axis (for callback use) % All elements have HandleVisibility off to exclude from legend theta = linspace(0, 2*pi, 100); plot(ax, cos(theta), sin(theta), 'k-', 'LineWidth', 1.5, 'HandleVisibility', 'off'); % Draw latitude circles with labels latitudes = [15, 30, 45, 60, 75]; for lat = latitudes latRad = lat * pi / 180; r = tan(latRad / 2); if r <= 1 x = r * cos(theta); y = r * sin(theta); plot(ax, x, y, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5, 'HandleVisibility', 'off'); % Add label text(ax, r + 0.02, 0, sprintf('%d°', lat), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'left', ... 'VerticalAlignment', 'middle'); end end % Add 90° label at edge text(ax, 1.02, 0, '90°', 'FontSize', 7, 'Color', [0.5 0.5 0.5], ... 'HorizontalAlignment', 'left', 'VerticalAlignment', 'middle'); % Draw longitude lines longitudes = 0:15:180-15; for lon = longitudes lonRad = lon * pi / 180; x = [-1, 1] * cos(lonRad); y = [-1, 1] * sin(lonRad); plot(ax, x, y, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5, 'HandleVisibility', 'off'); end % Add longitude labels at edge (every 30°) for lon = 0:30:150 lonRad = deg2rad(lon); x = 1.05 * cos(lonRad); y = 1.05 * sin(lonRad); text(ax, x, y, sprintf('%d°', lon), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'center', ... 'VerticalAlignment', 'middle'); if lon > 0 x = 1.05 * cos(lonRad + pi); y = 1.05 * sin(lonRad + pi); text(ax, x, y, sprintf('%d°', lon + 180), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'center', ... 'VerticalAlignment', 'middle'); end end end function [x, y] = stereoProject(pole) % STEREOPROJECT Stereographic projection from upper hemisphere % Projects a 3D unit vector onto the equatorial plane % Projection is from the south pole (0, 0, -1) % For upper hemisphere (z >= 0): % x_proj = x / (1 + z) % y_proj = y / (1 + z) if pole(3) >= 0 denom = 1 + pole(3); if denom > 1e-10 x = pole(1) / denom; y = pole(2) / denom; else x = pole(1); y = pole(2); end else % Lower hemisphere - project from north pole denom = 1 - pole(3); if denom > 1e-10 x = pole(1) / denom; y = pole(2) / denom; else x = pole(1); y = pole(2); end end end function poles = generatePoleFamily(family) % GENERATEPOLEFAMILY Generate all poles in a crystallographic family % For cubic crystals, generates all symmetrically equivalent poles % Parse the family string (e.g., '001', '011', '111', '112') h = str2double(family(1)); k = str2double(family(2)); l = str2double(family(3)); % Generate all permutations and sign combinations baseIndices = [h, k, l]; permutations = unique(perms(baseIndices), 'rows'); poles = []; for i = 1:size(permutations, 1) p = permutations(i, :); % Generate all sign combinations for s1 = [1, -1] for s2 = [1, -1] for s3 = [1, -1] newPole = [s1*p(1), s2*p(2), s3*p(3)]; % Skip zero vector if norm(newPole) > 0 % Check if this exact pole is already in the list isNew = true; for j = 1:size(poles, 1) if norm(poles(j,:) - newPole) < 1e-10 isNew = false; break; end end if isNew poles = [poles; newPole]; end end end end end end end function drawWulffNet(ax) % DRAWWULFFNET Draw the Wulff net (stereographic grid) % For projection looking down +z axis (APT convention) % Outer circle (equator, z=0 plane) theta = linspace(0, 2*pi, 100); plot(ax, cos(theta), sin(theta), 'k-', 'LineWidth', 1.5, 'HandleVisibility', 'off'); % Draw latitude circles (small circles at constant polar angle from +z) latitudes = [15, 30, 45, 60, 75]; % degrees from +z pole for lat = latitudes drawLatitudeCircle(ax, lat); % Add label at the right side of each circle r = tan(deg2rad(lat) / 2); text(ax, r + 0.02, 0, sprintf('%d°', lat), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'left', ... 'VerticalAlignment', 'middle'); end % Add 90° label at the edge text(ax, 1.02, 0, '90°', 'FontSize', 7, 'Color', [0.5 0.5 0.5], ... 'HorizontalAlignment', 'left', 'VerticalAlignment', 'middle'); % Draw longitude lines (radial lines from center to edge) % These are great circles through the +z pole, which project as straight lines longitudes = 0:15:180-15; % degrees for lon = longitudes drawLongitudeLine(ax, lon); end % Add longitude labels at the edge (every 30°) for lon = 0:30:150 lonRad = deg2rad(lon); x = 1.05 * cos(lonRad); y = 1.05 * sin(lonRad); text(ax, x, y, sprintf('%d°', lon), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'center', ... 'VerticalAlignment', 'middle'); % Also label the opposite side (lon + 180) if lon > 0 x = 1.05 * cos(lonRad + pi); y = 1.05 * sin(lonRad + pi); text(ax, x, y, sprintf('%d°', lon + 180), 'FontSize', 7, ... 'Color', [0.5 0.5 0.5], 'HorizontalAlignment', 'center', ... 'VerticalAlignment', 'middle'); end end end function drawLatitudeCircle(ax, latDeg) % Draw a latitude circle at the given polar angle from +z latRad = latDeg * pi / 180; % In stereographic projection, latitude circles become circles % The radius in the projection is tan(lat/2) for upper hemisphere r = tan(latRad / 2); if r <= 1 theta = linspace(0, 2*pi, 100); x = r * cos(theta); y = r * sin(theta); plot(ax, x, y, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5, 'HandleVisibility', 'off'); end end function drawLongitudeLine(ax, lonDeg) % Draw a longitude line (great circle through the +z pole) % These project as straight lines through the center lonRad = lonDeg * pi / 180; % Straight line from edge to edge through center x = [-1, 1] * cos(lonRad); y = [-1, 1] * sin(lonRad); plot(ax, x, y, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5, 'HandleVisibility', 'off'); end function drawOrientationCube(ax, R) % DRAWORIENTATIONCUBE Draw a unit cube showing crystal orientation % R is the rotation matrix (crystal to world coordinates) axes(ax); hold(ax, 'on'); % Define unit cube vertices (centered at origin) s = 0.5; % half-size cubeVerts = s * [ -1 -1 -1; 1 -1 -1; 1 1 -1; -1 1 -1; -1 -1 1; 1 -1 1; 1 1 1; -1 1 1 ]; % Rotate vertices by crystal orientation rotVerts = (R * cubeVerts')'; % Define faces (6 faces of cube) faces = [ 1 2 3 4; % bottom 5 6 7 8; % top 1 2 6 5; % front 3 4 8 7; % back 1 4 8 5; % left 2 3 7 6 % right ]; % Face colors based on crystal axis directions (fixed colors) % Blue for [001] faces, Green for [010] faces, Red for [100] faces faceColors = [ 0 0 1; % bottom (-Z) - Blue 0 0 1; % top (+Z) - Blue 0 1 0; % front (-Y) - Green 0 1 0; % back (+Y) - Green 1 0 0; % left (-X) - Red 1 0 0 % right (+X) - Red ]; % Draw the cube faces patch(ax, 'Vertices', rotVerts, 'Faces', faces, ... 'FaceVertexCData', faceColors, ... 'FaceColor', 'flat', ... 'EdgeColor', 'k', ... 'LineWidth', 1.5, ... 'FaceAlpha', 0.8); % Add crystal axis labels at the rotated axis directions axisLength = 0.9; axisColors = [1 0 0; 0 1 0; 0 0 1]; % RGB for X, Y, Z axisLabels = {'[100]', '[010]', '[001]'}; for i = 1:3 dir = zeros(1, 3); dir(i) = 1; rotDir = (R * dir')'; % Draw axis line quiver3(ax, 0, 0, 0, rotDir(1)*axisLength, rotDir(2)*axisLength, rotDir(3)*axisLength, ... 'Color', axisColors(i,:), 'LineWidth', 2, 'MaxHeadSize', 0.3); % Add label text(ax, rotDir(1)*axisLength*1.15, rotDir(2)*axisLength*1.15, rotDir(3)*axisLength*1.15, ... axisLabels{i}, 'FontSize', 10, 'FontWeight', 'bold', 'Color', axisColors(i,:), ... 'HorizontalAlignment', 'center'); end % Add world coordinate axes (thin gray lines) line(ax, [-0.7 0.7], [0 0], [0 0], 'Color', [0.5 0.5 0.5], 'LineStyle', '--'); line(ax, [0 0], [-0.7 0.7], [0 0], 'Color', [0.5 0.5 0.5], 'LineStyle', '--'); line(ax, [0 0], [0 0], [-0.7 0.7], 'Color', [0.5 0.5 0.5], 'LineStyle', '--'); % World axis labels text(ax, 0.8, 0, 0, 'X', 'FontSize', 9, 'Color', [0.4 0.4 0.4]); text(ax, 0, 0.8, 0, 'Y', 'FontSize', 9, 'Color', [0.4 0.4 0.4]); text(ax, 0, 0, 0.8, 'Z', 'FontSize', 9, 'Color', [0.4 0.4 0.4]); % Format axes axis(ax, 'equal'); axis(ax, 'vis3d'); xlim(ax, [-1.2 1.2]); ylim(ax, [-1.2 1.2]); zlim(ax, [-1.2 1.2]); % View from +Z looking down (matching stereographic projection orientation) % azimuth = -90 puts +X to the right, elevation = 90 looks straight down +Z view(ax, [-90 90]); axis(ax, 'off'); title(ax, 'Crystal Orientation (view down +Z)', 'FontSize', 12); hold(ax, 'off'); end function [phi1, Phi, phi2] = rotmat2euler(R) % ROTMAT2EULER Convert rotation matrix to Euler angles (Bunge convention) % Bunge convention: ZXZ (phi1 around Z, Phi around X', phi2 around Z'') % All angles returned in degrees % Handle numerical precision issues R = max(-1, min(1, R)); % Phi is the angle between Z axes (0 to 180 degrees) Phi = acosd(R(3,3)); % Handle gimbal lock cases if abs(R(3,3)) > 0.9999 % Phi ≈ 0 or 180, gimbal lock phi1 = atan2d(-R(1,2), R(1,1)); phi2 = 0; if R(3,3) < 0 Phi = 180; else Phi = 0; end else % General case phi1 = atan2d(R(3,1), -R(3,2)); phi2 = atan2d(R(1,3), R(2,3)); end % Normalize angles to [0, 360) range phi1 = mod(phi1, 360); phi2 = mod(phi2, 360); end function R = euler2rotmat(phi1, Phi, phi2) % EULER2ROTMAT Convert Euler angles to rotation matrix (Bunge convention) % Bunge convention: ZXZ (phi1 around Z, Phi around X', phi2 around Z'') % Input angles in degrees % Convert to radians phi1 = deg2rad(phi1); Phi = deg2rad(Phi); phi2 = deg2rad(phi2); % Rotation matrices c1 = cos(phi1); s1 = sin(phi1); c = cos(Phi); s = sin(Phi); c2 = cos(phi2); s2 = sin(phi2); % Combined rotation matrix (ZXZ convention) R = [c1*c2 - s1*c*s2, -c1*s2 - s1*c*c2, s1*s; s1*c2 + c1*c*s2, -s1*s2 + c1*c*c2, -c1*s; s*s2, s*c2, c]; end %% ========================================================================= % DRAG-AND-DROP POLE INTERACTION FUNCTIONS % ========================================================================= function dir = stereoInverse(x, y) % STEREOINVERSE Convert stereographic projection coordinates to 3D direction % Given (x, y) on the projection plane, returns the unit vector direction % Uses upper hemisphere projection from south pole r = sqrt(x^2 + y^2); if r < 1e-10 % At center, direction is +Z dir = [0, 0, 1]; return; end % Inverse stereographic projection % theta = polar angle from +Z axis theta = 2 * atan(r); phi = atan2(y, x); % Convert to Cartesian dir = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]; end function R = rodriguesRotation(axis, angle) % RODRIGUESROTATION Build rotation matrix from axis-angle representation % axis - 3x1 or 1x3 unit vector defining rotation axis % angle - rotation angle in radians % Returns 3x3 rotation matrix % Ensure axis is normalized axis = axis(:)' / norm(axis); if abs(angle) < 1e-10 R = eye(3); return; end % Rodrigues' rotation formula K = [0, -axis(3), axis(2); axis(3), 0, -axis(1); -axis(2), axis(1), 0]; R = eye(3) + sin(angle)*K + (1-cos(angle))*(K*K); end function allowRotate = rotateButtonDownFilter(~, eventData) % ROTATEBUTTONDOWNFILTER Filter to allow pole clicks to pass through rotate3d % Returns false for scatter markers (poles) so their ButtonDownFcn fires % Returns true for other objects so rotate3d handles them % Get the object that was clicked hitObj = eventData.HitObject; % Check if it's a scatter marker (pole) if isa(hitObj, 'matlab.graphics.chart.primitive.Scatter') allowRotate = false; % Don't let rotate3d handle it - pass to scatter's callback else allowRotate = true; % Let rotate3d handle it (e.g., cube rotation) end end function initDragState(figHandle) % INITDRAGSTATE Initialize drag state variables for two-pole interaction % States: 'idle', 'dragging', 'first_pole_set' setappdata(figHandle, 'dragState', 'idle'); setappdata(figHandle, 'draggedPole', []); % Crystal direction being dragged setappdata(figHandle, 'draggedPoleWorld', []); % World direction of dragged pole setappdata(figHandle, 'firstPoleFixed', false); % Is first pole locked? setappdata(figHandle, 'firstPoleCrystal', []); % Crystal direction of first pole setappdata(figHandle, 'firstPoleWorld', []); % World direction first pole is fixed to setappdata(figHandle, 'ghostMarker', []); % Handle to ghost marker during drag setappdata(figHandle, 'lockedMarker', []); % Handle to locked pole indicator setappdata(figHandle, 'previewMarkers', []); % Handles to preview markers during drag setappdata(figHandle, 'dragStartOrientation', []); % Orientation at start of drag setappdata(figHandle, 'previewOrientation', []); % Current preview orientation end function poleClickCallback(src, ~) % POLECLICKCALLBACK Handle mouse click on a pole marker figHandle = ancestor(src, 'figure'); dragState = getappdata(figHandle, 'dragState'); % Get the crystal direction stored in this marker crystalDir = get(src, 'UserData'); if isempty(crystalDir) return; end % Get current orientation and compute world direction R = getappdata(figHandle, 'rotationMatrix'); worldDir = (R * crystalDir(:))'; worldDir = worldDir / norm(worldDir); % Handle based on current state firstPoleFixed = getappdata(figHandle, 'firstPoleFixed'); if firstPoleFixed % Check if clicking the same pole that's already fixed firstPoleCrystal = getappdata(figHandle, 'firstPoleCrystal'); if norm(abs(crystalDir(:)) - abs(firstPoleCrystal(:))) < 0.01 % Clicking the locked pole - ignore or could reset return; end end % Store dragged pole info and starting orientation for preview setappdata(figHandle, 'draggedPole', crystalDir(:)'); setappdata(figHandle, 'draggedPoleWorld', worldDir); setappdata(figHandle, 'dragStartOrientation', R); setappdata(figHandle, 'dragState', 'dragging'); % Set up motion and release callbacks set(figHandle, 'WindowButtonMotionFcn', @figureDragMotion); set(figHandle, 'WindowButtonUpFcn', @figureDragRelease); end function figureDragMotion(figHandle, ~) % FIGUREDRAGMOTION Handle mouse motion during pole drag - real-time preview dragState = getappdata(figHandle, 'dragState'); if ~strcmp(dragState, 'dragging') return; end % Get mouse position in stereo axes coordinates axStereo = findobj(figHandle, 'Type', 'axes', 'Tag', 'stereoAxis'); if isempty(axStereo) return; end % Get current point in axes coordinates cp = get(axStereo, 'CurrentPoint'); x = cp(1, 1); y = cp(1, 2); % Clamp to unit circle r = sqrt(x^2 + y^2); if r > 1 x = x / r; y = y / r; end % Get target direction from stereo coordinates targetDir = stereoInverse(x, y); % Get dragged pole info and current orientation crystalDir = getappdata(figHandle, 'draggedPole'); firstPoleFixed = getappdata(figHandle, 'firstPoleFixed'); R_base = getappdata(figHandle, 'dragStartOrientation'); if isempty(R_base) R_base = getappdata(figHandle, 'rotationMatrix'); end % Calculate preview rotation if ~firstPoleFixed % First pole - minimum rotation preview R_preview = computePreviewRotation(R_base, crystalDir, targetDir, ... getappdata(figHandle, 'upperOnly')); else % Second pole - constrained rotation around first pole firstPoleWorld = getappdata(figHandle, 'firstPoleWorld'); R_preview = computeConstrainedPreviewRotation(R_base, crystalDir, targetDir, ... firstPoleWorld, ... getappdata(figHandle, 'upperOnly')); end % Update display with preview orientation updatePreviewDisplay(figHandle, axStereo, R_preview); end function figureDragRelease(figHandle, ~) % FIGUREDRAGRELEASE Handle mouse release after pole drag dragState = getappdata(figHandle, 'dragState'); if ~strcmp(dragState, 'dragging') return; end % Clear motion/release callbacks set(figHandle, 'WindowButtonMotionFcn', ''); set(figHandle, 'WindowButtonUpFcn', ''); % Delete preview markers hPreview = getappdata(figHandle, 'previewMarkers'); if ~isempty(hPreview) for i = 1:length(hPreview) if isvalid(hPreview(i)) delete(hPreview(i)); end end end setappdata(figHandle, 'previewMarkers', []); % Get the preview orientation that was computed during drag R_preview = getappdata(figHandle, 'previewOrientation'); % Get dragged pole info crystalDir = getappdata(figHandle, 'draggedPole'); firstPoleFixed = getappdata(figHandle, 'firstPoleFixed'); if isempty(R_preview) % No preview was computed, just reset setappdata(figHandle, 'dragState', 'idle'); return; end if ~firstPoleFixed % First pole drag - use the preview rotation and lock the pole % Get target direction from final mouse position axStereo = findobj(figHandle, 'Type', 'axes', 'Tag', 'stereoAxis'); cp = get(axStereo, 'CurrentPoint'); x = cp(1, 1); y = cp(1, 2); r = sqrt(x^2 + y^2); if r > 1 x = x / r; y = y / r; end targetDir = stereoInverse(x, y); % Store the fixed first pole info setappdata(figHandle, 'firstPoleFixed', true); setappdata(figHandle, 'firstPoleCrystal', crystalDir(:)'); setappdata(figHandle, 'firstPoleWorld', targetDir(:)'); setappdata(figHandle, 'rotationMatrix', R_preview); setappdata(figHandle, 'baseRotationMatrix', R_preview); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_preview, cSystem)); % Update displays updateStereoProjectionWithDrag(figHandle, R_preview); updateCubeDisplay(figHandle, R_preview); updateOrientationUI(figHandle, R_preview); updateStatusText(figHandle, 'first_set'); else % Second pole drag - finalize orientation setappdata(figHandle, 'rotationMatrix', R_preview); setappdata(figHandle, 'baseRotationMatrix', R_preview); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_preview, cSystem)); % Reset drag state (orientation is now fully determined) resetDragState(figHandle); % Update displays updateStereoProjectionWithDrag(figHandle, R_preview); updateCubeDisplay(figHandle, R_preview); updateOrientationUI(figHandle, R_preview); updateStatusText(figHandle, 'idle'); end setappdata(figHandle, 'dragState', 'idle'); setappdata(figHandle, 'dragStartOrientation', []); setappdata(figHandle, 'previewOrientation', []); end function applyFirstPoleRotation(figHandle, crystalDir, targetDir) % APPLYFIRSTPOLEROTATION Apply minimum rotation to move pole to target R_current = getappdata(figHandle, 'rotationMatrix'); % Current world direction of this pole currentWorldDir = (R_current * crystalDir(:))'; currentWorldDir = currentWorldDir / norm(currentWorldDir); % Handle hemisphere (if pole was in lower hemisphere, it was flipped) upperOnly = getappdata(figHandle, 'upperOnly'); if upperOnly && currentWorldDir(3) < 0 currentWorldDir = -currentWorldDir; end % Compute rotation from current to target targetDir = targetDir(:)'; dotProd = dot(currentWorldDir, targetDir); dotProd = max(-1, min(1, dotProd)); % Clamp for numerical stability if abs(dotProd - 1) < 1e-10 % Already at target, no rotation needed R_delta = eye(3); elseif abs(dotProd + 1) < 1e-10 % Opposite direction - rotate 180 around any perpendicular axis if abs(currentWorldDir(1)) < 0.9 perpAxis = cross(currentWorldDir, [1, 0, 0]); else perpAxis = cross(currentWorldDir, [0, 1, 0]); end perpAxis = perpAxis / norm(perpAxis); R_delta = rodriguesRotation(perpAxis, pi); else % General case - minimum rotation rotAxis = cross(currentWorldDir, targetDir); rotAxis = rotAxis / norm(rotAxis); rotAngle = acos(dotProd); R_delta = rodriguesRotation(rotAxis, rotAngle); end % Apply rotation to current orientation % R_new transforms crystal to new world coordinates R_new = R_delta * R_current; % Store the fixed first pole info setappdata(figHandle, 'firstPoleFixed', true); setappdata(figHandle, 'firstPoleCrystal', crystalDir(:)'); setappdata(figHandle, 'firstPoleWorld', targetDir); setappdata(figHandle, 'rotationMatrix', R_new); setappdata(figHandle, 'baseRotationMatrix', R_new); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_new, cSystem)); % Update displays updateStereoProjectionWithDrag(figHandle, R_new); updateCubeDisplay(figHandle, R_new); updateOrientationUI(figHandle, R_new); updateStatusText(figHandle, 'first_set'); end function applySecondPoleRotation(figHandle, crystalDir, targetDir) % APPLYSECONDPOLEROTATION Apply constrained rotation around first pole R_current = getappdata(figHandle, 'rotationMatrix'); firstPoleWorld = getappdata(figHandle, 'firstPoleWorld'); % Current world direction of second pole currentWorldDir = (R_current * crystalDir(:))'; currentWorldDir = currentWorldDir / norm(currentWorldDir); % Handle hemisphere upperOnly = getappdata(figHandle, 'upperOnly'); if upperOnly && currentWorldDir(3) < 0 currentWorldDir = -currentWorldDir; end targetDir = targetDir(:)'; firstPoleWorld = firstPoleWorld(:)'; % Project both current and target onto plane perpendicular to first pole % This gives us the angle to rotate around the first pole axis % Remove component along first pole axis currentProj = currentWorldDir - dot(currentWorldDir, firstPoleWorld) * firstPoleWorld; targetProj = targetDir - dot(targetDir, firstPoleWorld) * firstPoleWorld; currentProjNorm = norm(currentProj); targetProjNorm = norm(targetProj); if currentProjNorm < 1e-10 || targetProjNorm < 1e-10 % Second pole is along first pole axis - can't determine rotation % Reset state and return resetDragState(figHandle); return; end currentProj = currentProj / currentProjNorm; targetProj = targetProj / targetProjNorm; % Calculate rotation angle around first pole axis dotProd = dot(currentProj, targetProj); dotProd = max(-1, min(1, dotProd)); % Determine sign of rotation using cross product crossProd = cross(currentProj, targetProj); sign = 1; if dot(crossProd, firstPoleWorld) < 0 sign = -1; end rotAngle = sign * acos(dotProd); % Create rotation around first pole axis R_delta = rodriguesRotation(firstPoleWorld, rotAngle); % Apply rotation R_new = R_delta * R_current; % Update orientation setappdata(figHandle, 'rotationMatrix', R_new); setappdata(figHandle, 'baseRotationMatrix', R_new); % Update crystalOrientation object cSystem = getappdata(figHandle, 'crystalSystem'); setappdata(figHandle, 'crystalOrientationObject', crystalOrientation(R_new, cSystem)); % Reset drag state (orientation is now fully determined) resetDragState(figHandle); % Update displays updateStereoProjectionWithDrag(figHandle, R_new); updateCubeDisplay(figHandle, R_new); updateOrientationUI(figHandle, R_new); updateStatusText(figHandle, 'idle'); end function resetDragState(figHandle) % RESETDRAGSTATE Reset the drag state to idle setappdata(figHandle, 'dragState', 'idle'); setappdata(figHandle, 'firstPoleFixed', false); setappdata(figHandle, 'firstPoleCrystal', []); setappdata(figHandle, 'firstPoleWorld', []); setappdata(figHandle, 'draggedPole', []); setappdata(figHandle, 'draggedPoleWorld', []); % Delete locked marker if exists hLocked = getappdata(figHandle, 'lockedMarker'); if ~isempty(hLocked) && isvalid(hLocked) delete(hLocked); end setappdata(figHandle, 'lockedMarker', []); end function updateCubeDisplay(figHandle, R) % UPDATECUBEDISPLAY Update the orientation cube with new rotation axCube = findobj(figHandle, 'Type', 'axes', 'Tag', 'cubeAxis'); if isempty(axCube) return; end % Clear and redraw cube cla(axCube); drawOrientationCube(axCube, R); % Reset view to look down +Z view(axCube, [-90, 90]); end function updateStatusText(figHandle, state) % UPDATESTATUSTEXT Update the status text based on current drag state hStatus = getappdata(figHandle, 'hStatusText'); if isempty(hStatus) || ~isvalid(hStatus) return; end switch state case 'idle' set(hStatus, 'String', 'Drag a pole to set orientation (two-pole mode)'); case 'first_set' set(hStatus, 'String', 'First pole locked. Drag second pole to complete.'); case 'dragging' set(hStatus, 'String', 'Dragging...'); end end function updateStereoProjectionWithDrag(figHandle, R_effective) % UPDATESTEROPROJECTIONWITHDRAG Update stereo projection with draggable poles % Similar to updateStereoProjection but makes poles clickable poleFamilies = getappdata(figHandle, 'poleFamilies'); showWulff = getappdata(figHandle, 'showWulff'); showLabels = getappdata(figHandle, 'showLabels'); upperOnly = getappdata(figHandle, 'upperOnly'); markerSize = getappdata(figHandle, 'markerSize'); firstPoleFixed = getappdata(figHandle, 'firstPoleFixed'); firstPoleCrystal = getappdata(figHandle, 'firstPoleCrystal'); % Delete old stereo axes and create new one axStereo = findobj(figHandle, 'Type', 'axes', 'Tag', 'stereoAxis'); if ~isempty(axStereo) delete(axStereo); end % Create fresh axes for stereographic projection axStereo = subplot(1, 5, [1 2 3 4], 'Parent', figHandle); axStereo.Tag = 'stereoAxis'; hold(axStereo, 'on'); % Redraw Wulff net if showWulff drawWulffNetOnAxis(axStereo); else theta = linspace(0, 2*pi, 100); plot(axStereo, cos(theta), sin(theta), 'k-', 'LineWidth', 1.5, 'HandleVisibility', 'off'); end % Get pole styles poleStyles = getappdata(figHandle, 'poleStyles'); % Legend tracking legendHandles = []; legendEntries = {}; for i = 1:length(poleFamilies) family = poleFamilies{i}; poles = generatePoleFamily(family); styleField = ['p', family]; if isfield(poleStyles, styleField) style = poleStyles.(styleField); else style = struct('color', rand(1,3), 'marker', 'o'); end projectedPositions = []; for j = 1:size(poles, 1) pole = poles(j, :); pole = pole / norm(pole); worldPole = (R_effective * pole')'; originalPole = pole; % Store original crystal direction if upperOnly && worldPole(3) < 0 worldPole = -worldPole; originalPole = -pole; % Flip crystal direction too end if worldPole(3) >= 0 || ~upperOnly [x, y] = stereoProject(worldPole); isDuplicate = false; for k = 1:size(projectedPositions, 1) if norm([x, y] - projectedPositions(k, :)) < 0.01 isDuplicate = true; break; end end if x^2 + y^2 <= 1.01 && ~isDuplicate % Check if this is the locked first pole isLockedPole = false; if firstPoleFixed && ~isempty(firstPoleCrystal) if norm(abs(originalPole(:)) - abs(firstPoleCrystal(:))) < 0.01 isLockedPole = true; end end % Create clickable scatter marker if isLockedPole % Locked pole - different appearance h = scatter(axStereo, x, y, markerSize * 1.5, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k', 'LineWidth', 2, ... 'HandleVisibility', 'off'); % Add ring around locked pole hRing = plot(axStereo, x, y, 'o', 'MarkerSize', 18, ... 'MarkerEdgeColor', [1 0.5 0], 'LineWidth', 3, ... 'HandleVisibility', 'off'); setappdata(figHandle, 'lockedMarker', hRing); else % Normal draggable pole h = scatter(axStereo, x, y, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k', 'LineWidth', 0.5, ... 'HandleVisibility', 'off'); end % Store crystal direction and add click callback set(h, 'UserData', originalPole(:)'); set(h, 'ButtonDownFcn', @poleClickCallback); projectedPositions = [projectedPositions; x, y]; if showLabels labelStr = sprintf('(%d%d%d)', poles(j,1), poles(j,2), poles(j,3)); text(axStereo, x + 0.03, y + 0.03, labelStr, 'FontSize', 8); end end end end % Add legend entry legendHandles(end+1) = scatter(axStereo, nan, nan, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k'); legendEntries{end+1} = ['{', family(1), family(2), family(3), '}']; end % Coordinate markers text(axStereo, 1.12, 0, '+X', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(axStereo, -1.12, 0, '-X', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(axStereo, 0, 1.12, '+Y', 'FontSize', 12, 'FontWeight', 'bold', 'HorizontalAlignment', 'center'); text(axStereo, 0, -1.12, '-Y', 'FontSize', 10, 'HorizontalAlignment', 'center'); text(axStereo, 0.05, 0.05, '+Z', 'FontSize', 10, 'FontWeight', 'bold', 'HorizontalAlignment', 'left'); % Legend if ~isempty(legendHandles) legend(axStereo, legendHandles, legendEntries, 'Location', 'eastoutside'); end axis(axStereo, 'equal'); xlim(axStereo, [-1.3, 1.3]); ylim(axStereo, [-1.3, 1.3]); axis(axStereo, 'off'); title(axStereo, 'Stereographic Projection', 'FontSize', 14); % Prevent 3D rotation on stereo axes h = rotate3d(figHandle); setAllowAxesRotate(h, axStereo, false); hold(axStereo, 'off'); end function R_preview = computePreviewRotation(R_base, crystalDir, targetDir, upperOnly) % COMPUTEPREVIEWROTATION Compute preview rotation for first pole drag % Current world direction of this pole currentWorldDir = (R_base * crystalDir(:))'; currentWorldDir = currentWorldDir / norm(currentWorldDir); % Handle hemisphere if upperOnly && currentWorldDir(3) < 0 currentWorldDir = -currentWorldDir; end % Compute rotation from current to target targetDir = targetDir(:)'; dotProd = dot(currentWorldDir, targetDir); dotProd = max(-1, min(1, dotProd)); if abs(dotProd - 1) < 1e-10 R_delta = eye(3); elseif abs(dotProd + 1) < 1e-10 if abs(currentWorldDir(1)) < 0.9 perpAxis = cross(currentWorldDir, [1, 0, 0]); else perpAxis = cross(currentWorldDir, [0, 1, 0]); end perpAxis = perpAxis / norm(perpAxis); R_delta = rodriguesRotation(perpAxis, pi); else rotAxis = cross(currentWorldDir, targetDir); rotAxis = rotAxis / norm(rotAxis); rotAngle = acos(dotProd); R_delta = rodriguesRotation(rotAxis, rotAngle); end R_preview = R_delta * R_base; end function R_preview = computeConstrainedPreviewRotation(R_base, crystalDir, targetDir, firstPoleWorld, upperOnly) % COMPUTECONSTRAINEDPREVIEWROTATION Compute preview rotation for second pole (constrained) % Current world direction of second pole currentWorldDir = (R_base * crystalDir(:))'; currentWorldDir = currentWorldDir / norm(currentWorldDir); if upperOnly && currentWorldDir(3) < 0 currentWorldDir = -currentWorldDir; end targetDir = targetDir(:)'; firstPoleWorld = firstPoleWorld(:)'; % Project both onto plane perpendicular to first pole currentProj = currentWorldDir - dot(currentWorldDir, firstPoleWorld) * firstPoleWorld; targetProj = targetDir - dot(targetDir, firstPoleWorld) * firstPoleWorld; currentProjNorm = norm(currentProj); targetProjNorm = norm(targetProj); if currentProjNorm < 1e-10 || targetProjNorm < 1e-10 R_preview = R_base; return; end currentProj = currentProj / currentProjNorm; targetProj = targetProj / targetProjNorm; dotProd = dot(currentProj, targetProj); dotProd = max(-1, min(1, dotProd)); crossProd = cross(currentProj, targetProj); rotSign = 1; if dot(crossProd, firstPoleWorld) < 0 rotSign = -1; end rotAngle = rotSign * acos(dotProd); R_delta = rodriguesRotation(firstPoleWorld, rotAngle); R_preview = R_delta * R_base; end function updatePreviewDisplay(figHandle, axStereo, R_preview) % UPDATEPREVIEWDISPLAY Update pole positions in real-time during drag poleFamilies = getappdata(figHandle, 'poleFamilies'); upperOnly = getappdata(figHandle, 'upperOnly'); markerSize = getappdata(figHandle, 'markerSize'); poleStyles = getappdata(figHandle, 'poleStyles'); firstPoleFixed = getappdata(figHandle, 'firstPoleFixed'); firstPoleCrystal = getappdata(figHandle, 'firstPoleCrystal'); % Get or create preview markers hPreview = getappdata(figHandle, 'previewMarkers'); % Delete old preview markers if ~isempty(hPreview) for i = 1:length(hPreview) if isvalid(hPreview(i)) delete(hPreview(i)); end end end % Create new preview markers hPreview = gobjects(0); hold(axStereo, 'on'); for i = 1:length(poleFamilies) family = poleFamilies{i}; poles = generatePoleFamily(family); styleField = ['p', family]; if isfield(poleStyles, styleField) style = poleStyles.(styleField); else style = struct('color', rand(1,3), 'marker', 'o'); end projectedPositions = []; for j = 1:size(poles, 1) pole = poles(j, :); pole = pole / norm(pole); worldPole = (R_preview * pole')'; originalPole = pole; if upperOnly && worldPole(3) < 0 worldPole = -worldPole; originalPole = -pole; end if worldPole(3) >= 0 || ~upperOnly [x, y] = stereoProject(worldPole); isDuplicate = false; for k = 1:size(projectedPositions, 1) if norm([x, y] - projectedPositions(k, :)) < 0.01 isDuplicate = true; break; end end if x^2 + y^2 <= 1.01 && ~isDuplicate % Check if locked pole isLockedPole = false; if firstPoleFixed && ~isempty(firstPoleCrystal) if norm(abs(originalPole(:)) - abs(firstPoleCrystal(:))) < 0.01 isLockedPole = true; end end % Create preview marker (slightly transparent) if isLockedPole h = scatter(axStereo, x, y, markerSize * 1.5, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', [1 0.5 0], ... 'LineWidth', 2, 'MarkerFaceAlpha', 0.8, ... 'HandleVisibility', 'off'); else h = scatter(axStereo, x, y, markerSize, style.color, 'filled', ... 'Marker', style.marker, 'MarkerEdgeColor', 'k', ... 'LineWidth', 0.5, 'MarkerFaceAlpha', 0.8, ... 'HandleVisibility', 'off'); end % Store for cleanup but don't add click callback during preview hPreview(end+1) = h; projectedPositions = [projectedPositions; x, y]; end end end end hold(axStereo, 'off'); setappdata(figHandle, 'previewMarkers', hPreview); % Store preview orientation for final application setappdata(figHandle, 'previewOrientation', R_preview); end function ori = getCurrentOrientation(figHandle) % GETCURRENTORIENTATION Retrieve the current crystalOrientation from stereoProj figure % % ORI = GETCURRENTORIENTATION(FIGHANDLE) returns the current crystalOrientation % object from an interactive stereoProj figure. Use this after interactive % manipulation to get the final orientation. % % Input: % figHandle - Handle to the stereoProj figure % % Output: % ori - crystalOrientation object with the current orientation % % Example: % [~, ax] = stereoProj(eye(3)); % % ... user interacts with the widget ... % ori = getCurrentOrientation(ancestor(ax, 'figure')); % disp(ori); % % See also: stereoProj, crystalOrientation if ~ishandle(figHandle) || ~strcmp(get(figHandle, 'Type'), 'figure') error('Input must be a valid figure handle'); end ori = getappdata(figHandle, 'crystalOrientationObject'); if isempty(ori) error('No crystalOrientation found. Ensure the figure was created by stereoProj.'); end end` | STEREOPROJ Creates a stereographic projection of crystallographic poles |
| `plotOrientationCube` | `h = plotOrientationCube(orientationInput, varargin) % PLOTORIENTATIONCUBE Plot a cube representing crystallographic orientation in 3D % % H = PLOTORIENTATIONCUBE(ORIENTATIONINPUT) plots an orientation cube % at the origin with default size. % % H = PLOTORIENTATIONCUBE(ORIENTATIONINPUT, 'Name', Value, ...) specifies % additional options using name-value pairs. % % Input: % orientationInput - Either: % - 3x3 rotation matrix describing the orientation % of the crystal coordinate system relative to the % world coordinate system (crystal to world transform) % - crystalOrientation object % % Optional Name-Value Pairs: % 'position' - [x, y, z] position for cube center (default: [0, 0, 0]) % If a crystalOrientation object is passed and has a non-zero % position, that position is used unless overridden. % 'mesh' - Mesh structure with 'vertices' field. If provided, % cube is placed at center of gravity (mean of vertices). % Overrides 'position' if both are specified. % 'size' - Cube size (default: 1) % 'axes' - Axes handle to plot into (default: current axes or new figure) % 'showAxes' - Logical, show crystal axis arrows and labels (default: true) % 'faceAlpha' - Face transparency 0-1 (default: 0.8) % 'edgeColor' - Edge color (default: 'k') % 'lineWidth' - Edge line width (default: 1.5) % % Output: % h - Structure containing handles to graphical objects: % h.patch - Handle to cube patch object % h.arrows - Handles to axis arrows (quiver3) % h.labels - Handles to axis labels (text) % % Example: % % Plot cube at origin with identity orientation % R = eye(3); % plotOrientationCube(R); % % % Using crystalOrientation object % ori = crystalOrientation(eye(3), 'cubic', 'position', [10, 20, 30]); % plotOrientationCube(ori); % Uses position from object % % % Plot cube at specific position with 45° rotation around Z % theta = pi/4; % R = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; 0 0 1]; % plotOrientationCube(R, 'position', [10, 20, 30], 'size', 5); % % % Plot cube at center of a mesh % mesh.vertices = rand(100, 3) * 50; % Random vertices % plotOrientationCube(R, 'mesh', mesh, 'size', 3); % % See also: crystalOrientation, stereoProj % Determine input type and extract rotation matrix if isa(orientationInput, 'crystalOrientation') R = orientationInput.getRotationMatrix(); defaultPosition = orientationInput.position; elseif isnumeric(orientationInput) && all(size(orientationInput) == [3, 3]) R = orientationInput; defaultPosition = [0, 0, 0]; else error('Input must be a 3x3 rotation matrix or a crystalOrientation object'); end % Parse inputs p = inputParser; addRequired(p, 'orientationInput'); addParameter(p, 'position', defaultPosition, @(x) isnumeric(x) && numel(x)==3); addParameter(p, 'mesh', [], @(x) isempty(x) || (isstruct(x) && isfield(x, 'vertices'))); addParameter(p, 'size', 1, @(x) isnumeric(x) && isscalar(x) && x > 0); addParameter(p, 'axes', [], @(x) isempty(x) || ishandle(x)); addParameter(p, 'showAxes', true, @islogical); addParameter(p, 'faceAlpha', 0.8, @(x) isnumeric(x) && x >= 0 && x <= 1); addParameter(p, 'edgeColor', 'k', @(x) ischar(x) || (isnumeric(x) && numel(x)==3)); addParameter(p, 'lineWidth', 1.5, @(x) isnumeric(x) && isscalar(x) && x > 0); parse(p, orientationInput, varargin{:}); position = p.Results.position(:)'; meshData = p.Results.mesh; cubeSize = p.Results.size; ax = p.Results.axes; showAxes = p.Results.showAxes; faceAlpha = p.Results.faceAlpha; edgeColor = p.Results.edgeColor; lineWidth = p.Results.lineWidth; % If mesh is provided, calculate center of gravity from vertices if ~isempty(meshData) vertices = meshData.vertices; position = mean(vertices, 1); end % Get or create axes if isempty(ax) ax = gca; end holdState = ishold(ax); hold(ax, 'on'); % Define unit cube vertices (centered at origin) s = 0.5 * cubeSize; % half-size cubeVerts = [ -1 -1 -1; 1 -1 -1; 1 1 -1; -1 1 -1; -1 -1 1; 1 -1 1; 1 1 1; -1 1 1 ] * s; % Rotate vertices by crystal orientation rotVerts = (R * cubeVerts')'; % Translate to position rotVerts = rotVerts + position; % Define faces (6 faces of cube) faces = [ 1 2 3 4; % bottom (-Z) 5 6 7 8; % top (+Z) 1 2 6 5; % front (-Y) 3 4 8 7; % back (+Y) 1 4 8 5; % left (-X) 2 3 7 6 % right (+X) ]; % Face colors based on crystal axis directions % Blue for [001] faces, Green for [010] faces, Red for [100] faces faceColors = [ 0 0 1; % bottom (-Z) - Blue 0 0 1; % top (+Z) - Blue 0 0.7 0; % front (-Y) - Green 0 0.7 0; % back (+Y) - Green 1 0 0; % left (-X) - Red 1 0 0 % right (+X) - Red ]; % Draw the cube faces hPatch = patch(ax, 'Vertices', rotVerts, 'Faces', faces, ... 'FaceVertexCData', faceColors, ... 'FaceColor', 'flat', ... 'EdgeColor', edgeColor, ... 'LineWidth', lineWidth, ... 'FaceAlpha', faceAlpha); % Initialize output handles h.patch = hPatch; h.arrows = []; h.labels = []; % Add crystal axis arrows and labels if requested if showAxes axisLength = 0.9 * cubeSize; axisColors = [1 0 0; 0 0.7 0; 0 0 1]; % RGB for X, Y, Z axisLabels = {'[100]', '[010]', '[001]'}; hArrows = gobjects(3, 1); hLabels = gobjects(3, 1); for i = 1:3 dir = zeros(1, 3); dir(i) = 1; rotDir = (R * dir')'; % Draw axis arrow from cube center hArrows(i) = quiver3(ax, position(1), position(2), position(3), ... rotDir(1)*axisLength, rotDir(2)*axisLength, rotDir(3)*axisLength, ... 'Color', axisColors(i,:), 'LineWidth', 2, 'MaxHeadSize', 0.3, ... 'AutoScale', 'off'); % Add label at arrow tip labelPos = position + rotDir * axisLength * 1.15; hLabels(i) = text(ax, labelPos(1), labelPos(2), labelPos(3), ... axisLabels{i}, 'FontSize', 10, 'FontWeight', 'bold', ... 'Color', axisColors(i,:), 'HorizontalAlignment', 'center'); end h.arrows = hArrows; h.labels = hLabels; end % Restore hold state if ~holdState hold(ax, 'off'); end % Set axis properties for 3D viewing if this is a new plot axis(ax, 'equal'); axis(ax, 'vis3d'); % Add rotation capability rotate3d(ax, 'on'); end` | PLOTORIENTATIONCUBE Plot a cube representing crystallographic orientation in 3D |

---

## Reconstruction

| Function | Syntax | Description |
|----------|--------|-------------|
| `posReconstruct3DGeiser` | `[pos, objectsR] = posReconstruct3DGeiser(pos,flightPathLength,... detectorEfficiency,effectiveDetectorArea,ionVolume,radiusEvolution,... ICF,objects) %atom probe reconstruction after: Gault et al., Ultramicroscopy 111 (2011) 448 - 457 %detx, dety are the detector hit coordinates in mm %kf is the field factor and ICF is the image compression factor % for reflectron data an image correction is required! % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% fundamental data reconstruction % detector coordinates in polar form [ang, rad] = cart2pol(pos.detx, pos.dety); % launch angle relative to specimen axis thetaP = atan(rad / flightPathLength); % mm/mm % image compression correction theta = thetaP + asin((ICF - 1) * sin(thetaP)); % distance from axis and z shift of each hit [zP, d] = pol2cart(theta, radiusEvolution); % nm % x and y coordinates from the angle on the detector and the distance to % the specimen axis. [pos.x, pos.y] = pol2cart(ang, d); % nm %% calculate z coordinate % the z shift with respect to the top of the cap is Rspec - zP zP = radiusEvolution - zP; % accumulative part of z omega = 1 ./ ionVolume / detectorEfficiency; % atomic volume in nm^3 omega(isnan(omega)) = 0; % magnification M at ion index M = flightPathLength./ICF ./radiusEvolution; % currently evaporating area of the specimen specArea = effectiveDetectorArea ./ M.^2; %individual depth increment dz = omega ./ specArea; % wide angle correction cumZ = cumsum(double(dz)); pos.z = cumZ + zP; clear ang rad d zP %% co-reconstruction of objects if exist('objects','var') for o = 1:length(objects) % detector coordinates in polar form [ang, rad] = cart2pol(objects(o).vertices(:,1),objects(o).vertices(:,2)); % launch angle relaive to specimen axis thetaP = atan(rad / flightPathLength); % mm/mm theta = thetaP + asin((ICF - 1) * sin(thetaP)); % distance from axis and z shift of each hit [zP, d] = pol2cart(theta, radiusEvolution(round(objects(o).vertices(:,3)))); % nm % x and y coordinates from the angle on the detector and the distance to % the specimen axis. [objectsR(o).vertices(:,1), objectsR(o).vertices(:,2)] = pol2cart(ang, d); % nm % the z shift with respect to the top of the cap is Rspec - zP zP = radiusEvolution(round(objects(o).vertices(:,3))) - zP; objectsR(o).vertices(:,3) = cumZ(round(objects(o).vertices(:,3))) + zP; objectsR(o).faces = objects(o).faces; end end` |   |
| `posReflectronCorrection` | `posCorrected = posReflectronCorrection(transPos, intersections) % posReflectronCorrected - corrects the reflectron image distortion in a % dataset, the function corrects the detx and dety coordinates of a % % INPUT: % transPos = pos table that was measured with a reflectron instrument % intersections = variable for the specific instrument - measured with a % grid electrode % % OUTPUT: % posCorrected = corrected pos table with the corrected detx and dety % coordinates - an adjacent reconstruction of the dataset is needed! % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg %% triangulation of the dataset alpha = 10; % [mm] alpha value for triangulation gridTris = alphaTriangulation(alphaShape(intersections.detectorX,intersections.detectorY, alpha)); % alphaTriangulation(shp) returns a triangulation that defines the domain of the alpha shape. % Each row in tri specifies a triangle defined by vertex IDs %% Create translation mesh allocation of detector hit points triangleNumber = tsearchn([intersections.detectorY, intersections.detectorX],gridTris,... [transPos.detx, transPos.dety]); isOutside = find(isnan(triangleNumber)); closestVertex = dsearchn([intersections.detectorY, intersections.detectorX],gridTris,... [transPos.detx, transPos.dety]); for idx = 1:length(isOutside) % MATLAB is finally JIT compiled! :D tetIdx = find(sum(gridTris == closestVertex( isOutside(idx) ) ,2)); triangleNumber(isOutside(idx)) = tetIdx(1); end %% Performing affine transformation through barycentric coordinate approximation % defining triangulation objects detectorTriangulation = triangulation(gridTris,[intersections.detectorY, intersections.detectorX]); gridTriangulation = triangulation(gridTris,[intersections.gridX, intersections.gridY]); % carrying out transformations barycentricCoordinatesPos = cartesianToBarycentric(detectorTriangulation,triangleNumber,[transPos.detx, transPos.dety]); coords = barycentricToCartesian(gridTriangulation,triangleNumber,barycentricCoordinatesPos); % creating corrected pos table posCorrected = transPos; posCorrected.dety = coords(:,2); posCorrected.detx = coords(:,1); end` | posReflectronCorrected - corrects the reflectron image distortion in a |
| `reflectronImageTransform` | `pos = reflectronImageTransform(pos, intersectionCoordinates) % this function transforms the real hit locations of an instrument with a % reflectron into hit locations on a virtual detector, located at the back plane of the % local electrode. These this plane is xx mm from the aperture of the local % electrode. They can be used to carry out a 3D reconstruction of the data. %INPUT % pos: table variable with the entries detx and dety as the % physical detector hit coordinates in double precision float % intersectionCoordinates: intersection coordinates that represent known % coordinates in the virtual detector plane. Provided for % each type of instrument. % currently avialable: % LEAP 4000X HR / LEAP 4000 HR % LEAP 5000XR / LEAP 5000R (to come soon) %OUTPUT % pos: table variable with all entries identical to the input pos % variable except for the detx and dety, which have been % corrected for the reflectron image distortions. % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nürnberg ALPHA = 10; % alpha value for alpha shape the triangulation is based on. % triangulate the grid in physical detector coordinates gridTris = alphaTriangulation(... alphaShape(intersectionCoordinates.detectorX,intersectionCoordinates.detectorY,ALPHA)); %reminder: X lines are the one closer to parallel to the x axis. Their %position represents y coordinates! %find triangle for all hit positions inside triangulation on the detector triangleNumber = tsearchn([intersectionCoordinates.detectorY, intersectionCoordinates.detectorX],gridTris,... [pos.detx, pos.dety]); % for stray hit coordinates outside detector: find closest triangle of triangulation isOutside = find(isnan(triangleNumber)); closestVertex = dsearchn([intersectionCoordinates.detectorY, intersectionCoordinates.detectorX],gridTris,... [pos.detx, pos.dety]); for idx = 1:length(isOutside) % MATLAB is finally JIT compiled! :D tetIdx = find(sum(gridTris == closestVertex( isOutside(idx) ) ,2)); triangleNumber(isOutside(idx)) = tetIdx(1); end %% performing affine transformation % defining triangulation objects detectorTriangulation = triangulation(gridTris,[intersectionCoordinates.detectorY, intersectionCoordinates.detectorX]); gridTriangulation = triangulation(gridTris,[intersectionCoordinates.gridX, intersectionCoordinates.gridY]); % carrying out transformations barycentricCoordinatesPos = cartesianToBarycentric(detectorTriangulation,triangleNumber,[pos.detx, pos.dety]); coords = barycentricToCartesian(gridTriangulation,triangleNumber,barycentricCoordinatesPos); % creating corrected pos table pos.detx = uminus(coords(:,2)); pos.dety = uminus(coords(:,1));` | this function transforms the real hit locations of an instrument with a |

---

## Utilities

| Function | Syntax | Description |
|----------|--------|-------------|
| `setupToolbox` | `setupToolbox(options) % SETUPTOOLBOX Initialize the Atom Probe Toolbox % % setupToolbox() % setupToolbox('checkDeps', true) % setupToolbox('quiet', true) % % Adds all necessary paths and optionally checks dependencies. % Run this once per MATLAB session before using the toolbox. % % OPTIONS: % 'checkDeps' - Run dependency check (default: true) % 'quiet' - Suppress output messages (default: false) % 'permanent' - Save paths permanently (default: false) % % EXAMPLES: % setupToolbox(); % Standard setup % setupToolbox('quiet', true); % Silent setup % setupToolbox('permanent', true); % Add to MATLAB path permanently % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments options.checkDeps (1,1) logical = true options.quiet (1,1) logical = false options.permanent (1,1) logical = false end % Get toolbox root directory toolboxRoot = fileparts(mfilename('fullpath')); if ~options.quiet fprintf('\n'); fprintf('==========================================\n'); fprintf(' Atom Probe Toolbox Setup\n'); fprintf('==========================================\n'); fprintf(' Version: 1.0\n'); fprintf(' Location: %s\n', toolboxRoot); fprintf('==========================================\n\n'); end % Define directories to add subfolders = { '', % Root 'analysis' 'correlative' 'crystallography' 'utilities' 'utilities_Cluster' 'utilities_dualMesh' 'utilities_geom2d' 'utilities_geom2d/geom2d' 'utilities_geom2d/polygons2d' 'utilities_IO' 'utilities_IO/APT_reader_MPIE' 'utilities_IO/EMIODist2' 'doc' }; % Add paths nAdded = 0; for i = 1:length(subfolders) folderPath = fullfile(toolboxRoot, subfolders{i}); if isfolder(folderPath) if ~contains(path, folderPath) addpath(folderPath); nAdded = nAdded + 1; end else if ~options.quiet warning('setupToolbox:missingFolder', 'Folder not found: %s', subfolders{i}); end end end if ~options.quiet fprintf('Added %d folders to MATLAB path.\n\n', nAdded); end % Save path permanently if requested if options.permanent try savepath; if ~options.quiet fprintf('Path saved permanently.\n\n'); end catch ME warning('setupToolbox:savePathFailed', ... 'Could not save path permanently: %s', ME.message); end end % Check dependencies if options.checkDeps if ~options.quiet checkDependencies('verbose', true); else [status, ~] = checkDependencies('verbose', false); if ~status warning('setupToolbox:missingDeps', ... 'Some dependencies are missing. Run checkDependencies() for details.'); end end end if ~options.quiet fprintf('\nAtom Probe Toolbox is ready.\n'); fprintf('Run "doc GettingStarted" for documentation.\n\n'); end end` | SETUPTOOLBOX Initialize the Atom Probe Toolbox |
| `checkDependencies` | `[status, report] = checkDependencies(options) % CHECKDEPENDENCIES Verify MATLAB version and required toolboxes % % [status, report] = checkDependencies() % [status, report] = checkDependencies('verbose', true) % [status, report] = checkDependencies('autoAddPath', true) % % Checks that all required MATLAB toolboxes and internal utilities are % available for the Atom Probe Toolbox to function correctly. % % OPTIONS: % 'verbose' - Display detailed information (default: true) % 'autoAddPath' - Automatically add toolbox paths (default: true) % 'checkOptional' - Also check optional dependencies (default: false) % % OUTPUT: % status - true if all required dependencies are met % report - Structure containing detailed dependency information % .matlabVersion - Current MATLAB version % .required - Table of required dependencies and their status % .optional - Table of optional dependencies and their status % .missing - Cell array of missing required dependencies % .warnings - Cell array of warning messages % % EXAMPLE: % checkDependencies(); % Quick check with console output % [ok, rep] = checkDependencies('verbose', false); % Silent check % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments options.verbose (1,1) logical = true options.autoAddPath (1,1) logical = true options.checkOptional (1,1) logical = false end report = struct(); report.matlabVersion = version; report.matlabRelease = version('-release'); report.warnings = {}; report.missing = {}; % Minimum MATLAB version (R2019b for arguments block support) minVersion = '9.7'; % R2019b currentVersion = version; versionNum = regexp(currentVersion, '^\d+\.\d+', 'match', 'once'); if str2double(versionNum) < str2double(minVersion) report.warnings{end+1} = sprintf('MATLAB version %s or later recommended (current: %s)', ... minVersion, currentVersion); end %% Check Required Toolboxes requiredToolboxes = { 'MATLAB', 'Core MATLAB', true 'Statistics and Machine Learning Toolbox', 'Statistics', true 'Image Processing Toolbox', 'Image Processing', true }; toolboxStatus = cell(size(requiredToolboxes, 1), 4); v = ver; installedToolboxes = {v.Name}; for i = 1:size(requiredToolboxes, 1) tbName = requiredToolboxes{i, 1}; tbShort = requiredToolboxes{i, 2}; tbRequired = requiredToolboxes{i, 3}; isInstalled = any(strcmpi(installedToolboxes, tbName)); toolboxStatus{i, 1} = tbShort; toolboxStatus{i, 2} = tbName; toolboxStatus{i, 3} = isInstalled; toolboxStatus{i, 4} = tbRequired; if ~isInstalled && tbRequired report.missing{end+1} = tbName; end end report.required = cell2table(toolboxStatus, ... 'VariableNames', {'ShortName', 'FullName', 'Installed', 'Required'}); %% Check Optional Toolboxes optionalToolboxes = { 'Curve Fitting Toolbox', 'Curve Fitting', false 'Optimization Toolbox', 'Optimization', false 'Parallel Computing Toolbox', 'Parallel Computing', false 'Computer Vision Toolbox', 'Computer Vision', false }; optionalStatus = cell(size(optionalToolboxes, 1), 4); for i = 1:size(optionalToolboxes, 1) tbName = optionalToolboxes{i, 1}; tbShort = optionalToolboxes{i, 2}; isInstalled = any(strcmpi(installedToolboxes, tbName)); optionalStatus{i, 1} = tbShort; optionalStatus{i, 2} = tbName; optionalStatus{i, 3} = isInstalled; optionalStatus{i, 4} = false; % Not required end report.optional = cell2table(optionalStatus, ... 'VariableNames', {'ShortName', 'FullName', 'Installed', 'Required'}); %% Check Internal Utilities toolboxRoot = fileparts(mfilename('fullpath')); internalPaths = { 'utilities', 'Core utilities' 'utilities_Cluster', 'Cluster analysis' 'utilities_dualMesh', 'Dual mesh generation' 'utilities_geom2d', 'Geometry utilities' 'utilities_IO', 'Input/Output' 'analysis', 'Analysis modules' 'correlative', 'Correlative imaging' 'crystallography', 'Crystallography' 'doc', 'Documentation' }; internalStatus = cell(size(internalPaths, 1), 3); for i = 1:size(internalPaths, 1) pathName = internalPaths{i, 1}; pathDesc = internalPaths{i, 2}; fullPath = fullfile(toolboxRoot, pathName); exists = isfolder(fullPath); internalStatus{i, 1} = pathName; internalStatus{i, 2} = pathDesc; internalStatus{i, 3} = exists; if ~exists report.warnings{end+1} = sprintf('Internal folder missing: %s', pathName); elseif options.autoAddPath % Add to path if not already there if ~contains(path, fullPath) addpath(genpath(fullPath)); end end end report.internal = cell2table(internalStatus, ... 'VariableNames', {'Folder', 'Description', 'Exists'}); %% Check for GPU availability (informational) report.gpuAvailable = false; report.gpuInfo = ''; try if exist('gpuDeviceCount', 'file') && gpuDeviceCount > 0 gpu = gpuDevice; report.gpuAvailable = true; report.gpuInfo = sprintf('%s (%.1f GB)', gpu.Name, gpu.TotalMemory/1e9); end catch % GPU not available or error checking end %% Check parallel pool availability report.parallelAvailable = ~isempty(ver('parallel')); report.parallelWorkers = 0; if report.parallelAvailable try pool = gcp('nocreate'); if ~isempty(pool) report.parallelWorkers = pool.NumWorkers; end catch % Parallel pool not available end end %% Determine overall status status = isempty(report.missing); %% Display results if verbose if options.verbose fprintf('\n'); fprintf('========================================\n'); fprintf(' Atom Probe Toolbox Dependency Check\n'); fprintf('========================================\n\n'); fprintf('MATLAB Version: %s (%s)\n', report.matlabVersion, report.matlabRelease); fprintf('\n'); % Required toolboxes fprintf('REQUIRED TOOLBOXES:\n'); fprintf('-------------------\n'); for i = 1:height(report.required) if report.required.Installed(i) statusStr = '[OK]'; else statusStr = '[MISSING]'; end fprintf(' %s %s\n', statusStr, report.required.ShortName{i}); end fprintf('\n'); % Optional toolboxes if options.checkOptional fprintf('OPTIONAL TOOLBOXES:\n'); fprintf('-------------------\n'); for i = 1:height(report.optional) if report.optional.Installed(i) statusStr = '[OK]'; else statusStr = '[--]'; end fprintf(' %s %s\n', statusStr, report.optional.ShortName{i}); end fprintf('\n'); end % Internal modules fprintf('INTERNAL MODULES:\n'); fprintf('-----------------\n'); for i = 1:height(report.internal) if report.internal.Exists(i) statusStr = '[OK]'; else statusStr = '[MISSING]'; end fprintf(' %s %s\n', statusStr, report.internal.Folder{i}); end fprintf('\n'); % Hardware capabilities fprintf('HARDWARE CAPABILITIES:\n'); fprintf('----------------------\n'); if report.gpuAvailable fprintf(' [OK] GPU: %s\n', report.gpuInfo); else fprintf(' [--] GPU: Not available (CPU fallback will be used)\n'); end if report.parallelAvailable if report.parallelWorkers > 0 fprintf(' [OK] Parallel: %d workers active\n', report.parallelWorkers); else fprintf(' [OK] Parallel: Available (no active pool)\n'); end else fprintf(' [--] Parallel: Not available\n'); end fprintf('\n'); % Warnings if ~isempty(report.warnings) fprintf('WARNINGS:\n'); fprintf('---------\n'); for i = 1:length(report.warnings) fprintf(' ! %s\n', report.warnings{i}); end fprintf('\n'); end % Summary fprintf('========================================\n'); if status fprintf(' Status: READY\n'); fprintf(' All required dependencies are met.\n'); else fprintf(' Status: MISSING DEPENDENCIES\n'); fprintf(' Please install: %s\n', strjoin(report.missing, ', ')); end fprintf('========================================\n\n'); end end` | CHECKDEPENDENCIES Verify MATLAB version and required toolboxes |
| `APTConfig` | `obj = APTConfig() % Private constructor for singleton toolboxPath = fileparts(mfilename('fullpath')); obj.configFilePath = fullfile(toolboxPath, '.aptconfig.json'); obj.load(); end end methods (Static) function obj = getInstance() % Get the singleton instance persistent instance if isempty(instance) || ~isvalid(instance) instance = APTConfig(); end obj = instance; end function value = get(key) % Static method to get a configuration value % Example: APTConfig.get('reconstruction.detectionEfficiency') cfg = APTConfig.getInstance(); value = cfg.getValue(key); end function set(key, value) % Static method to set a configuration value % Example: APTConfig.set('reconstruction.detectionEfficiency', 0.52) cfg = APTConfig.getInstance(); cfg.setValue(key, value); end function reset() % Reset configuration to defaults cfg = APTConfig.getInstance(); cfg.resetToDefaults(); end function show() % Display current configuration cfg = APTConfig.getInstance(); cfg.display(); end end methods function value = getValue(obj, key) % Get a configuration value using dot notation parts = strsplit(key, '.'); value = obj; for i = 1:length(parts) if isstruct(value) value = value.(parts{i}); else value = value.(parts{i}); end end end function setValue(obj, key, value) % Set a configuration value using dot notation parts = strsplit(key, '.'); if length(parts) == 1 obj.(parts{1}) = value; elseif length(parts) == 2 obj.(parts{1}).(parts{2}) = value; else error('APTConfig:nestedTooDeep', 'Configuration nesting too deep'); end end function save(obj) % Save configuration to file configData = struct(); configData.reconstruction = obj.reconstruction; configData.analysis = obj.analysis; configData.visualization = obj.visualization; configData.io = obj.io; configData.performance = obj.performance; try jsonStr = jsonencode(configData); fid = fopen(obj.configFilePath, 'w'); if fid == -1 warning('APTConfig:saveError', 'Could not save configuration file'); return; end fprintf(fid, '%s', jsonStr); fclose(fid); catch ME warning('APTConfig:saveError', 'Error saving configuration: %s', ME.message); end end function load(obj) % Load configuration from file if ~isfile(obj.configFilePath) return; % Use defaults end try fid = fopen(obj.configFilePath, 'r'); if fid == -1 return; end jsonStr = fread(fid, '*char')'; fclose(fid); configData = jsondecode(jsonStr); % Merge with existing (to preserve new fields in code) obj.mergeStruct('reconstruction', configData); obj.mergeStruct('analysis', configData); obj.mergeStruct('visualization', configData); obj.mergeStruct('io', configData); obj.mergeStruct('performance', configData); catch ME warning('APTConfig:loadError', 'Error loading configuration: %s', ME.message); end end function mergeStruct(obj, fieldName, configData) % Merge loaded config with existing defaults if isfield(configData, fieldName) loadedFields = fieldnames(configData.(fieldName)); for i = 1:length(loadedFields) fn = loadedFields{i}; if isfield(obj.(fieldName), fn) obj.(fieldName).(fn) = configData.(fieldName).(fn); end end end end function resetToDefaults(obj) % Reset all settings to defaults defaultConfig = APTConfig(); obj.reconstruction = defaultConfig.reconstruction; obj.analysis = defaultConfig.analysis; obj.visualization = defaultConfig.visualization; obj.io = defaultConfig.io; obj.performance = defaultConfig.performance; % Delete config file if isfile(obj.configFilePath) delete(obj.configFilePath); end end function applyInstrumentPreset(obj, instrumentName) % Apply instrument-specific settings % Example: cfg.applyInstrumentPreset('LEAP5000XR') if ~isfield(obj.instrumentPresets, instrumentName) validNames = fieldnames(obj.instrumentPresets); error('APTConfig:unknownInstrument', ... 'Unknown instrument: %s. Valid options: %s', ... instrumentName, strjoin(validNames, ', ')); end preset = obj.instrumentPresets.(instrumentName); fields = fieldnames(preset); for i = 1:length(fields) obj.reconstruction.(fields{i}) = preset.(fields{i}); end fprintf('Applied instrument preset: %s\n', instrumentName); end function applyMaterialPreset(obj, materialName) % Apply material-specific settings (atomic volume) % Example: cfg.applyMaterialPreset('Al') if ~isfield(obj.materialPresets, materialName) validNames = fieldnames(obj.materialPresets); error('APTConfig:unknownMaterial', ... 'Unknown material: %s. Valid options: %s', ... materialName, strjoin(validNames, ', ')); end obj.reconstruction.atomicVolume = obj.materialPresets.(materialName); fprintf('Applied material preset: %s (atomic volume = %.5f nm^3)\n', ... materialName, obj.reconstruction.atomicVolume); end function display(obj) % Display current configuration fprintf('\n'); fprintf('==========================================\n'); fprintf(' Atom Probe Toolbox Configuration\n'); fprintf('==========================================\n\n'); categories = {'reconstruction', 'analysis', 'visualization', 'io', 'performance'}; for c = 1:length(categories) cat = categories{c}; fprintf('%s:\n', upper(cat)); fprintf('------------------------------------------\n'); fields = fieldnames(obj.(cat)); for f = 1:length(fields) fn = fields{f}; val = obj.(cat).(fn); if isnumeric(val) fprintf(' %-25s: %g\n', fn, val); elseif islogical(val) if val fprintf(' %-25s: true\n', fn); else fprintf(' %-25s: false\n', fn); end elseif ischar(val) fprintf(' %-25s: %s\n', fn, val); end end fprintf('\n'); end fprintf('Config file: %s\n', obj.configFilePath); fprintf('==========================================\n\n'); end function tf = useGPU(obj) % Check if GPU should be used (available and enabled) tf = false; if ~obj.performance.useGPU return; end try if exist('gpuDeviceCount', 'file') && gpuDeviceCount > 0 tf = true; end catch tf = false; end end function tf = useParallel(obj) % Check if parallel computing should be used tf = false; if ~obj.performance.useParallel return; end if ~isempty(ver('parallel')) tf = true; end end function n = getNumWorkers(obj) % Get number of parallel workers to use n = 0; if ~obj.useParallel() return; end if obj.performance.maxWorkers > 0 n = obj.performance.maxWorkers; else % Use all available c = parcluster('local'); n = c.NumWorkers; end end end end` | APTCONFIG Global configuration management for Atom Probe Toolbox |
| `batchProcess` | `results = batchProcess(dataFiles, analysisFcn, options) % BATCHPROCESS Apply analysis pipeline to multiple APT datasets % % results = batchProcess(dataFiles, analysisFcn) % results = batchProcess(dataFiles, analysisFcn, 'parallel', true) % % Processes multiple APT datasets through a common analysis pipeline, % collecting results and handling errors gracefully. % % INPUT: % dataFiles - Cell array of file paths OR folder path with wildcard % e.g., {'file1.pos', 'file2.pos'} or '/data/*.pos' % analysisFcn - Function handle that takes a file path and returns results % Signature: result = analysisFcn(filePath) % OR: result = analysisFcn(filePath, idx, total) for progress info % % OPTIONS: % 'parallel' - Use parallel processing (default: false) % 'continueOnError' - Continue if one file fails (default: true) % 'saveResults' - Save results after each file (default: false) % 'outputFolder' - Folder for saving results (default: pwd) % 'outputPrefix' - Prefix for output files (default: 'batch_') % 'showProgress' - Show progress bar (default: true) % 'logFile' - Path to log file (default: '' = no logging) % % OUTPUT: % results - Structure array with fields: % .fileName - Original file name % .filePath - Full file path % .success - Whether analysis succeeded % .error - Error message if failed % .data - Analysis results (from analysisFcn) % .duration - Processing time in seconds % % EXAMPLES: % % Simple concentration analysis % files = {'sample1.pos', 'sample2.pos', 'sample3.pos'}; % results = batchProcess(files, @(f) posCalculateConcentrationSimple(posLoad(f))); % % % With custom analysis function % myAnalysis = @(f) analyzeDataset(f, 'binWidth', 0.1); % results = batchProcess('/data/*.pos', myAnalysis, 'parallel', true); % % % Using index information for logging % myAnalysis = @(f, idx, total) fprintf('Processing %d/%d\n', idx, total); % results = batchProcess(files, myAnalysis); % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments dataFiles analysisFcn function_handle options.parallel (1,1) logical = false options.continueOnError (1,1) logical = true options.saveResults (1,1) logical = false options.outputFolder (1,:) char = pwd options.outputPrefix (1,:) char = 'batch_' options.showProgress (1,1) logical = true options.logFile (1,:) char = '' end % Resolve file list if ischar(dataFiles) || isstring(dataFiles) dataFiles = char(dataFiles); if contains(dataFiles, '*') || contains(dataFiles, '?') % Wildcard pattern [folder, pattern, ext] = fileparts(dataFiles); if isempty(folder) folder = '.'; end listing = dir(fullfile(folder, [pattern, ext])); dataFiles = cellfun(@(f) fullfile(folder, f), {listing.name}, 'UniformOutput', false); else dataFiles = {dataFiles}; end end nFiles = length(dataFiles); if nFiles == 0 warning('batchProcess:noFiles', 'No files found to process.'); results = struct([]); return; end % Initialize log file if ~isempty(options.logFile) logFid = fopen(options.logFile, 'w'); writeLog(logFid, 'Batch processing started: %s', datestr(now)); writeLog(logFid, 'Number of files: %d', nFiles); else logFid = -1; end % Check if analysis function accepts index arguments try nArgIn = nargin(analysisFcn); catch nArgIn = 1; % Assume single argument if nargin fails end useIndexArgs = nArgIn >= 3 || nArgIn < 0; % -1 means varargin % Initialize results structure results(nFiles) = struct('fileName', '', 'filePath', '', 'success', false, ... 'error', '', 'data', [], 'duration', 0); % Process files if options.parallel && ~isempty(ver('parallel')) % Parallel processing results = processParallel(dataFiles, analysisFcn, options, useIndexArgs, logFid); else % Sequential processing results = processSequential(dataFiles, analysisFcn, options, useIndexArgs, logFid); end % Summary nSuccess = sum([results.success]); nFailed = nFiles - nSuccess; totalTime = sum([results.duration]); if options.showProgress fprintf('\n========================================\n'); fprintf('Batch Processing Complete\n'); fprintf('========================================\n'); fprintf('Total files: %d\n', nFiles); fprintf('Successful: %d\n', nSuccess); fprintf('Failed: %d\n', nFailed); fprintf('Total time: %.1f s\n', totalTime); fprintf('========================================\n'); end if logFid > 0 writeLog(logFid, ''); writeLog(logFid, 'Batch processing complete'); writeLog(logFid, 'Successful: %d / %d', nSuccess, nFiles); writeLog(logFid, 'Total time: %.1f s', totalTime); fclose(logFid); end % Save final combined results if options.saveResults outputFile = fullfile(options.outputFolder, [options.outputPrefix 'results.mat']); save(outputFile, 'results'); fprintf('Results saved to: %s\n', outputFile); end end %% Sequential Processing function results = processSequential(dataFiles, analysisFcn, options, useIndexArgs, logFid) nFiles = length(dataFiles); % Initialize results results(nFiles) = struct('fileName', '', 'filePath', '', 'success', false, ... 'error', '', 'data', [], 'duration', 0); if options.showProgress prog = ProgressTracker(nFiles, 'Processing files'); end for i = 1:nFiles filePath = dataFiles{i}; [~, fileName, ext] = fileparts(filePath); results(i).fileName = [fileName, ext]; results(i).filePath = filePath; if logFid > 0 writeLog(logFid, 'Processing [%d/%d]: %s', i, nFiles, results(i).fileName); end startTime = tic; try % Call analysis function if useIndexArgs results(i).data = analysisFcn(filePath, i, nFiles); else results(i).data = analysisFcn(filePath); end results(i).success = true; if logFid > 0 writeLog(logFid, ' SUCCESS (%.2f s)', toc(startTime)); end catch ME results(i).success = false; results(i).error = sprintf('%s: %s', ME.identifier, ME.message); if logFid > 0 writeLog(logFid, ' FAILED: %s', results(i).error); end if ~options.continueOnError error('batchProcess:analysisError', ... 'Analysis failed for %s: %s', filePath, ME.message); end end results(i).duration = toc(startTime); % Save intermediate result if options.saveResults && results(i).success outputFile = fullfile(options.outputFolder, ... sprintf('%s%s.mat', options.outputPrefix, fileName)); resultData = results(i).data; save(outputFile, 'resultData'); end if options.showProgress prog.update(i); end end if options.showProgress prog.finish(); end end %% Parallel Processing function results = processParallel(dataFiles, analysisFcn, options, useIndexArgs, logFid) nFiles = length(dataFiles); % Initialize results as cell array for parfor resultCell = cell(nFiles, 1); fileNames = cell(nFiles, 1); filePaths = dataFiles; % Extract file names for i = 1:nFiles [~, name, ext] = fileparts(dataFiles{i}); fileNames{i} = [name, ext]; end if options.showProgress fprintf('Processing %d files in parallel...\n', nFiles); end % Create local copies for parfor continueOnError = options.continueOnError; saveResults = options.saveResults; outputFolder = options.outputFolder; outputPrefix = options.outputPrefix; parfor i = 1:nFiles result = struct('fileName', fileNames{i}, 'filePath', filePaths{i}, ... 'success', false, 'error', '', 'data', [], 'duration', 0); startTime = tic; try if useIndexArgs result.data = analysisFcn(filePaths{i}, i, nFiles); else result.data = analysisFcn(filePaths{i}); end result.success = true; catch ME result.success = false; result.error = sprintf('%s: %s', ME.identifier, ME.message); if ~continueOnError error('batchProcess:analysisError', ... 'Analysis failed for %s: %s', filePaths{i}, ME.message); end end result.duration = toc(startTime); % Save intermediate result if saveResults && result.success [~, name, ~] = fileparts(filePaths{i}); outputFile = fullfile(outputFolder, sprintf('%s%s.mat', outputPrefix, name)); resultData = result.data; parsave(outputFile, resultData); end resultCell{i} = result; end % Convert cell array back to structure array results = [resultCell{:}]; % Log results (can't do this inside parfor) if logFid > 0 for i = 1:nFiles if results(i).success writeLog(logFid, '[%d/%d] %s: SUCCESS (%.2f s)', ... i, nFiles, results(i).fileName, results(i).duration); else writeLog(logFid, '[%d/%d] %s: FAILED - %s', ... i, nFiles, results(i).fileName, results(i).error); end end end end %% Helper Functions function writeLog(fid, format, varargin) if fid > 0 timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS'); fprintf(fid, '[%s] %s\n', timestamp, sprintf(format, varargin{:})); end end function parsave(filename, data) % Save function that works inside parfor save(filename, 'data'); end` | BATCHPROCESS Apply analysis pipeline to multiple APT datasets |
| `ProgressTracker` | `obj = ProgressTracker(totalSteps, taskName, options) arguments totalSteps (1,1) double {mustBePositive} taskName (1,:) char = 'Processing' options.showGUI (1,1) logical = false options.mode (1,:) char {mustBeMember(options.mode, {'iteration', 'percentage'})} = 'iteration' options.minInterval (1,1) double = 0.5 options.showETA (1,1) logical = true end obj.totalSteps = totalSteps; obj.taskName = taskName; obj.currentStep = 0; obj.startTime = tic; obj.lastUpdateTime = 0; obj.minInterval = options.minInterval; obj.showGUI = options.showGUI; obj.showETA = options.showETA; obj.mode = options.mode; obj.isFinished = false; obj.lastMessage = ''; if obj.showGUI obj.waitbarHandle = waitbar(0, obj.taskName, ... 'Name', 'Progress', ... 'CreateCancelBtn', 'setappdata(gcbf,''canceling'',1)'); setappdata(obj.waitbarHandle, 'canceling', 0); else % Print initial message fprintf('%s: 0%%', obj.taskName); end end function cancelled = update(obj, step, message) % Update progress % Returns true if user cancelled (GUI mode only) arguments obj step (1,1) double message (1,:) char = '' end cancelled = false; obj.currentStep = step; % Check for cancellation in GUI mode if obj.showGUI && isvalid(obj.waitbarHandle) if getappdata(obj.waitbarHandle, 'canceling') cancelled = true; obj.finish('Cancelled'); return; end end % Throttle updates elapsed = toc(obj.startTime); if elapsed - obj.lastUpdateTime < obj.minInterval && step < obj.totalSteps return; end obj.lastUpdateTime = elapsed; % Calculate progress if strcmp(obj.mode, 'percentage') progress = step / 100; pctComplete = step; else progress = step / obj.totalSteps; pctComplete = progress * 100; end % Estimate time remaining etaStr = ''; if obj.showETA && progress > 0.01 totalTime = elapsed / progress; remainingTime = totalTime - elapsed; etaStr = obj.formatTime(remainingTime); end % Build status message if isempty(message) if strcmp(obj.mode, 'percentage') statusMsg = sprintf('%s: %.0f%%', obj.taskName, pctComplete); else statusMsg = sprintf('%s: %d/%d (%.0f%%)', ... obj.taskName, step, obj.totalSteps, pctComplete); end else statusMsg = sprintf('%s: %s', obj.taskName, message); end if ~isempty(etaStr) statusMsg = sprintf('%s - ETA: %s', statusMsg, etaStr); end % Update display if obj.showGUI && isvalid(obj.waitbarHandle) waitbar(progress, obj.waitbarHandle, statusMsg); else % Clear previous line and print new status fprintf(repmat('\b', 1, length(obj.lastMessage))); fprintf('%s', statusMsg); obj.lastMessage = statusMsg; end end function finish(obj, message) % Mark progress as complete arguments obj message (1,:) char = 'Complete' end if obj.isFinished return; end obj.isFinished = true; elapsed = toc(obj.startTime); elapsedStr = obj.formatTime(elapsed); if obj.showGUI if isvalid(obj.waitbarHandle) delete(obj.waitbarHandle); end else fprintf(repmat('\b', 1, length(obj.lastMessage))); fprintf('%s: %s (%s)\n', obj.taskName, message, elapsedStr); end end function delete(obj) % Destructor - ensure waitbar is closed if obj.showGUI && ~isempty(obj.waitbarHandle) && isvalid(obj.waitbarHandle) delete(obj.waitbarHandle); end if ~obj.isFinished fprintf('\n'); % Ensure newline end end end methods (Static) function str = formatTime(seconds) % Format seconds into human-readable string if seconds < 60 str = sprintf('%.0fs', seconds); elseif seconds < 3600 mins = floor(seconds / 60); secs = mod(seconds, 60); str = sprintf('%dm %02.0fs', mins, secs); else hours = floor(seconds / 3600); mins = floor(mod(seconds, 3600) / 60); str = sprintf('%dh %02dm', hours, mins); end end function demo() % Demonstrate ProgressTracker usage fprintf('Demo 1: Command-line progress\n'); n = 50; prog = ProgressTracker(n, 'Processing items'); for i = 1:n pause(0.05); % Simulate work prog.update(i); end prog.finish(); fprintf('\nDemo 2: With custom messages\n'); files = {'data1.pos', 'data2.pos', 'data3.pos', 'data4.pos', 'data5.pos'}; prog = ProgressTracker(length(files), 'Loading files'); for i = 1:length(files) pause(0.3); % Simulate work prog.update(i, files{i}); end prog.finish(); fprintf('\nDemo complete!\n'); end end end` | PROGRESSTRACKER Unified progress tracking for long-running operations |
| `validateInputs` | `validateInputs(varargin) % VALIDATEINPUTS Unified input validation for Atom Probe Toolbox functions % % validateInputs(name1, value1, type1, name2, value2, type2, ...) % % Validates input arguments with informative error messages. % % INPUTS: % Arguments come in triplets: (name, value, type) % - name: string, the parameter name for error messages % - value: the value to validate % - type: string or cell array specifying validation rules % % SUPPORTED TYPES: % 'posTable' - Valid position table with required columns % 'ranges' - Valid ranges table % 'ions' - Valid ions table % 'numeric' - Numeric array (any size) % 'scalar' - Single numeric value % 'positive' - Positive numeric value(s) % 'nonnegative' - Non-negative numeric value(s) % 'integer' - Integer value(s) % 'vector' - 1D numeric array % 'matrix' - 2D numeric array % 'string' - Character array or string % 'logical' - Logical value % 'table' - MATLAB table % 'struct' - Structure % 'cell' - Cell array % 'function' - Function handle % 'file' - Existing file path % 'directory' - Existing directory path % 'patch' - Valid patch structure (vertices, faces) % 'colorScheme' - Valid color scheme table % 'quaternion' - Valid quaternion (4-element unit vector) % 'rotationMatrix'- Valid 3x3 rotation matrix % {'option', {'a','b','c'}} - Value must be one of the listed options % {'size', [m,n]} - Array must have specified size % {'minLength', n} - Minimum length for arrays % {'columns', {'col1','col2'}} - Table must have specified columns % % EXAMPLES: % validateInputs('pos', pos, 'posTable', 'radius', r, 'positive'); % validateInputs('method', method, {'option', {'linear','nearest'}}); % validateInputs('data', data, {'size', [3, NaN]}); % 3 rows, any columns % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg if mod(nargin, 3) ~= 0 error('validateInputs:invalidArguments', ... 'Arguments must come in triplets: (name, value, type)'); end nArgs = nargin / 3; for i = 1:nArgs idx = (i-1)*3 + 1; name = varargin{idx}; value = varargin{idx + 1}; typeSpec = varargin{idx + 2}; validateSingleInput(name, value, typeSpec); end end function validateSingleInput(name, value, typeSpec) % Validate a single input argument % Handle cell array type specifications (compound types) if iscell(typeSpec) validateCompoundType(name, value, typeSpec); return; end % Simple type validation switch lower(typeSpec) case 'postable' validatePosTable(name, value); case 'ranges' validateRanges(name, value); case 'ions' validateIons(name, value); case 'numeric' if ~isnumeric(value) error('validateInputs:invalidType', ... '%s must be numeric.', name); end case 'scalar' if ~isnumeric(value) || ~isscalar(value) error('validateInputs:invalidType', ... '%s must be a numeric scalar.', name); end case 'positive' if ~isnumeric(value) || any(value(:) <= 0) error('validateInputs:invalidValue', ... '%s must be positive.', name); end case 'nonnegative' if ~isnumeric(value) || any(value(:) < 0) error('validateInputs:invalidValue', ... '%s must be non-negative.', name); end case 'integer' if ~isnumeric(value) || any(mod(value(:), 1) ~= 0) error('validateInputs:invalidValue', ... '%s must be integer-valued.', name); end case 'vector' if ~isnumeric(value) || (~isvector(value) && ~isempty(value)) error('validateInputs:invalidType', ... '%s must be a numeric vector.', name); end case 'matrix' if ~isnumeric(value) || ndims(value) > 2 error('validateInputs:invalidType', ... '%s must be a 2D numeric matrix.', name); end case 'string' if ~ischar(value) && ~isstring(value) error('validateInputs:invalidType', ... '%s must be a character array or string.', name); end case 'logical' if ~islogical(value) && ~(isnumeric(value) && all(value(:) == 0 | value(:) == 1)) error('validateInputs:invalidType', ... '%s must be logical.', name); end case 'table' if ~istable(value) error('validateInputs:invalidType', ... '%s must be a table.', name); end case 'struct' if ~isstruct(value) error('validateInputs:invalidType', ... '%s must be a structure.', name); end case 'cell' if ~iscell(value) error('validateInputs:invalidType', ... '%s must be a cell array.', name); end case 'function' if ~isa(value, 'function_handle') error('validateInputs:invalidType', ... '%s must be a function handle.', name); end case 'file' if ~ischar(value) && ~isstring(value) error('validateInputs:invalidType', ... '%s must be a file path string.', name); end if ~isfile(value) error('validateInputs:fileNotFound', ... 'File not found: %s', value); end case 'directory' if ~ischar(value) && ~isstring(value) error('validateInputs:invalidType', ... '%s must be a directory path string.', name); end if ~isfolder(value) error('validateInputs:directoryNotFound', ... 'Directory not found: %s', value); end case 'patch' validatePatch(name, value); case 'colorscheme' validateColorScheme(name, value); case 'quaternion' if ~isnumeric(value) || numel(value) ~= 4 error('validateInputs:invalidQuaternion', ... '%s must be a 4-element quaternion.', name); end normVal = norm(value); if abs(normVal - 1) > 1e-6 error('validateInputs:invalidQuaternion', ... '%s must be a unit quaternion (norm = 1, got %.6f).', name, normVal); end case 'rotationmatrix' if ~isnumeric(value) || ~isequal(size(value), [3, 3]) error('validateInputs:invalidRotationMatrix', ... '%s must be a 3x3 matrix.', name); end % Check orthogonality: R * R' should be identity RRt = value * value'; if norm(RRt - eye(3), 'fro') > 1e-6 error('validateInputs:invalidRotationMatrix', ... '%s must be an orthogonal matrix (R * R'' = I).', name); end % Check determinant = 1 (proper rotation, not reflection) if abs(det(value) - 1) > 1e-6 error('validateInputs:invalidRotationMatrix', ... '%s must have determinant = 1 (got %.6f).', name, det(value)); end otherwise error('validateInputs:unknownType', ... 'Unknown validation type: %s', typeSpec); end end function validateCompoundType(name, value, typeSpec) % Handle compound type specifications like {'option', {'a','b'}} if isempty(typeSpec) return; end specType = typeSpec{1}; switch lower(specType) case 'option' options = typeSpec{2}; if ~any(strcmpi(value, options)) optStr = strjoin(options, ', '); error('validateInputs:invalidOption', ... '%s must be one of: %s (got: %s)', name, optStr, char(value)); end case 'size' expectedSize = typeSpec{2}; actualSize = size(value); % NaN in expectedSize means "any" for that dimension for d = 1:length(expectedSize) if ~isnan(expectedSize(d)) && ... (d > length(actualSize) || actualSize(d) ~= expectedSize(d)) error('validateInputs:invalidSize', ... '%s has wrong size. Expected [%s], got [%s].', ... name, num2str(expectedSize), num2str(actualSize)); end end case 'minlength' minLen = typeSpec{2}; if length(value) < minLen error('validateInputs:invalidLength', ... '%s must have at least %d elements (got %d).', ... name, minLen, length(value)); end case 'columns' requiredCols = typeSpec{2}; if ~istable(value) error('validateInputs:invalidType', ... '%s must be a table.', name); end missingCols = setdiff(requiredCols, value.Properties.VariableNames); if ~isempty(missingCols) error('validateInputs:missingColumns', ... '%s is missing required columns: %s', name, strjoin(missingCols, ', ')); end case 'range' bounds = typeSpec{2}; if ~isnumeric(value) || any(value(:) < bounds(1)) || any(value(:) > bounds(2)) error('validateInputs:outOfRange', ... '%s must be in range [%g, %g].', name, bounds(1), bounds(2)); end otherwise error('validateInputs:unknownCompoundType', ... 'Unknown compound validation type: %s', specType); end end function validatePosTable(name, value) % Validate a position table if ~istable(value) error('validateInputs:invalidPosTable', ... '%s must be a table.', name); end requiredCols = {'x', 'y', 'z'}; missingCols = setdiff(requiredCols, lower(value.Properties.VariableNames)); if ~isempty(missingCols) error('validateInputs:invalidPosTable', ... '%s must contain columns: x, y, z. Missing: %s', name, strjoin(missingCols, ', ')); end end function validateRanges(name, value) % Validate a ranges table if ~istable(value) error('validateInputs:invalidRanges', ... '%s must be a table.', name); end requiredCols = {'mcbegin', 'mcend'}; actualCols = lower(value.Properties.VariableNames); missingCols = setdiff(lower(requiredCols), actualCols); if ~isempty(missingCols) error('validateInputs:invalidRanges', ... '%s must contain columns: mcbegin, mcend. Missing: %s', name, strjoin(missingCols, ', ')); end end function validateIons(name, value) % Validate an ions table if ~istable(value) error('validateInputs:invalidIons', ... '%s must be a table.', name); end requiredCols = {'ion', 'chargeState'}; actualCols = value.Properties.VariableNames; missingCols = setdiff(requiredCols, actualCols); if ~isempty(missingCols) error('validateInputs:invalidIons', ... '%s must contain columns: ion, chargeState. Missing: %s', name, strjoin(missingCols, ', ')); end end function validatePatch(name, value) % Validate a patch structure if ~isstruct(value) error('validateInputs:invalidPatch', ... '%s must be a structure.', name); end if ~isfield(value, 'vertices') || ~isfield(value, 'faces') error('validateInputs:invalidPatch', ... '%s must have ''vertices'' and ''faces'' fields.', name); end if size(value.vertices, 2) ~= 3 error('validateInputs:invalidPatch', ... '%s.vertices must be Nx3.', name); end if size(value.faces, 2) < 3 error('validateInputs:invalidPatch', ... '%s.faces must have at least 3 columns.', name); end end function validateColorScheme(name, value) % Validate a color scheme table if ~istable(value) error('validateInputs:invalidColorScheme', ... '%s must be a table.', name); end requiredCols = {'ion', 'color'}; missingCols = setdiff(requiredCols, value.Properties.VariableNames); if ~isempty(missingCols) error('validateInputs:invalidColorScheme', ... '%s must contain columns: ion, color. Missing: %s', name, strjoin(missingCols, ', ')); end end` | VALIDATEINPUTS Unified input validation for Atom Probe Toolbox functions |
| `runTests` | `results = runTests(options) % RUNTESTS Run all tests for the Atom Probe Toolbox % % results = runTests() % results = runTests('pattern', 'test_*.m') % results = runTests('verbose', true) % % Discovers and runs test files throughout the toolbox. Test files should % be named with 'test_' prefix and contain functions that return true/false. % % OPTIONS: % 'pattern' - File pattern to match (default: 'test_*.m') % 'folder' - Specific folder to search (default: all) % 'verbose' - Show detailed output (default: true) % 'stopOnFail' - Stop on first failure (default: false) % % OUTPUT: % results - Structure with test results: % .total - Total tests run % .passed - Number passed % .failed - Number failed % .skipped - Number skipped % .duration - Total time % .details - Table with per-test results % % TEST FILE FORMAT: % Test files should define functions that return true (pass) or false (fail). % Functions starting with 'test' are automatically discovered. % % Example test_myFeature.m: % ``` % function success = test_basic() % x = myFunction(1, 2); % success = (x == 3); % end % % function success = test_edge_case() % try % myFunction([], []); % success = false; % Should have thrown error % catch % success = true; % end % end % ``` % % (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg arguments options.pattern (1,:) char = 'test_*.m' options.folder (1,:) char = '' options.verbose (1,1) logical = true options.stopOnFail (1,1) logical = false end startTime = tic; toolboxRoot = fileparts(mfilename('fullpath')); % Find test files if isempty(options.folder) searchPath = toolboxRoot; else searchPath = fullfile(toolboxRoot, options.folder); end testFiles = dir(fullfile(searchPath, '**', options.pattern)); if isempty(testFiles) fprintf('No test files found matching pattern: %s\n', options.pattern); results = struct('total', 0, 'passed', 0, 'failed', 0, 'skipped', 0); return; end if options.verbose fprintf('\n'); fprintf('==========================================\n'); fprintf(' Atom Probe Toolbox Test Runner\n'); fprintf('==========================================\n'); fprintf(' Found %d test files\n', length(testFiles)); fprintf('==========================================\n\n'); end % Initialize results testResults = {}; totalTests = 0; passedTests = 0; failedTests = 0; skippedTests = 0; % Run each test file for f = 1:length(testFiles) testFile = testFiles(f); testPath = fullfile(testFile.folder, testFile.name); [~, testName, ~] = fileparts(testFile.name); if options.verbose fprintf('Running: %s\n', testName); end % Get test functions from file testFunctions = getTestFunctions(testPath); if isempty(testFunctions) if options.verbose fprintf(' (no test functions found)\n'); end continue; end % Run each test function for t = 1:length(testFunctions) funcName = testFunctions{t}; totalTests = totalTests + 1; result = struct(); result.file = testName; result.function = funcName; result.passed = false; result.skipped = false; result.error = ''; result.duration = 0; funcStart = tic; try % Navigate to test directory and run oldDir = cd(testFile.folder); cleanup = onCleanup(@() cd(oldDir)); % Call the test function funcHandle = str2func(funcName); testPassed = funcHandle(); result.duration = toc(funcStart); if islogical(testPassed) && testPassed result.passed = true; passedTests = passedTests + 1; statusStr = 'PASS'; elseif islogical(testPassed) && ~testPassed result.passed = false; failedTests = failedTests + 1; statusStr = 'FAIL'; else % Non-boolean return - treat as skip result.skipped = true; skippedTests = skippedTests + 1; statusStr = 'SKIP'; end catch ME result.duration = toc(funcStart); result.passed = false; result.error = sprintf('%s: %s', ME.identifier, ME.message); failedTests = failedTests + 1; statusStr = 'ERROR'; end if options.verbose if result.passed fprintf(' [%s] %s (%.3fs)\n', statusStr, funcName, result.duration); else fprintf(' [%s] %s (%.3fs)\n', statusStr, funcName, result.duration); if ~isempty(result.error) fprintf(' %s\n', result.error); end end end testResults{end+1} = result; if options.stopOnFail && ~result.passed && ~result.skipped fprintf('\nStopping on first failure.\n'); break; end end if options.stopOnFail && failedTests > 0 break; end if options.verbose fprintf('\n'); end end totalDuration = toc(startTime); % Build results structure results = struct(); results.total = totalTests; results.passed = passedTests; results.failed = failedTests; results.skipped = skippedTests; results.duration = totalDuration; if ~isempty(testResults) results.details = struct2table([testResults{:}]); end % Print summary if options.verbose fprintf('==========================================\n'); fprintf(' Test Summary\n'); fprintf('==========================================\n'); fprintf(' Total: %d\n', totalTests); fprintf(' Passed: %d\n', passedTests); fprintf(' Failed: %d\n', failedTests); fprintf(' Skipped: %d\n', skippedTests); fprintf(' Time: %.2f s\n', totalDuration); fprintf('==========================================\n'); if failedTests == 0 fprintf(' All tests passed!\n'); else fprintf(' %d test(s) failed.\n', failedTests); end fprintf('==========================================\n\n'); end end function testFunctions = getTestFunctions(testFilePath) % Extract test function names from a test file testFunctions = {}; try % Read file content fid = fopen(testFilePath, 'r'); if fid == -1 return; end content = fread(fid, '*char')'; fclose(fid); % Find function definitions starting with 'test' pattern = 'function\s+\w+\s*=\s*(test\w*)\s*\('; matches = regexp(content, pattern, 'tokens'); for i = 1:length(matches) testFunctions{end+1} = matches{i}{1}; end % Also check for functions without return value pattern2 = 'function\s+(test\w*)\s*\('; matches2 = regexp(content, pattern2, 'tokens'); for i = 1:length(matches2) if ~any(strcmp(testFunctions, matches2{i}{1})) testFunctions{end+1} = matches2{i}{1}; end end catch % Failed to parse file end end` | RUNTESTS Run all tests for the Atom Probe Toolbox |

---


function generateApiReference(options)
% GENERATEAPIREFERENCE Generate doc/API_Reference.md from source files
%
% generateApiReference()
% generateApiReference('outputFile', 'doc/API_Reference.md')
% generateApiReference('categories', functionCategories())
%
% (c) by Prof. Peter Felfer Group @FAU Erlangen-Nurnberg

arguments
    options.outputFile (1,:) char = ''
    options.categories (1,1) struct = struct()
    options.verbose (1,1) logical = true
end

% Get toolbox root
toolboxRoot = fileparts(fileparts(mfilename('fullpath')));

if isempty(options.outputFile)
    options.outputFile = fullfile(toolboxRoot, 'doc', 'API_Reference.md');
end

if isempty(fieldnames(options.categories))
    options.categories = functionCategories();
end

categories = options.categories;

if options.verbose
    fprintf('Generating API reference: %s\n', options.outputFile);
end

lines = {};
lines{end+1} = '# Atom Probe Toolbox - API Quick Reference';
lines{end+1} = '';
lines{end+1} = '_Auto-generated by doc/generateApiReference.m_';
lines{end+1} = '';
lines{end+1} = 'A condensed reference of all functions organized by category.';
lines{end+1} = '';
lines{end+1} = '---';
lines{end+1} = '';

categoryNames = fieldnames(categories);
for c = 1:length(categoryNames)
    catName = categoryNames{c};
    cat = categories.(catName);

    lines{end+1} = sprintf('## %s', cat.name);
    lines{end+1} = '';
    lines{end+1} = '| Function | Syntax | Description |';
    lines{end+1} = '|----------|--------|-------------|';

    for f = 1:length(cat.functions)
        funcName = cat.functions{f};
        [sig, desc] = getFunctionSummary(funcName, toolboxRoot);
        if isempty(desc)
            desc = ' '; % keep table cell non-empty
        end
        lines{end+1} = sprintf('| `%s` | `%s` | %s |', funcName, sig, desc);
    end

    lines{end+1} = '';
    lines{end+1} = '---';
    lines{end+1} = '';
end

% Write file
[outputDir, ~, ~] = fileparts(options.outputFile);
if ~isfolder(outputDir)
    mkdir(outputDir);
end

fid = fopen(options.outputFile, 'w');
if fid == -1
    error('generateApiReference:writeFailed', 'Could not write %s', options.outputFile);
end

for i = 1:numel(lines)
    fprintf(fid, '%s\n', lines{i});
end
fclose(fid);

if options.verbose
    fprintf('API reference written.\n');
end

end

function [signature, description] = getFunctionSummary(funcName, toolboxRoot)
    filePath = findFunctionFile(funcName, toolboxRoot);
    if isempty(filePath)
        signature = [funcName '(...)'];
        description = '';
        return;
    end

    content = fileread(filePath);
    signature = extractSignature(content, funcName);
    description = extractDescription(content);
end

function filePath = findFunctionFile(funcName, toolboxRoot)
    patterns = {
        fullfile(toolboxRoot, '**', [funcName '.m'])
    };

    matches = [];
    for i = 1:numel(patterns)
        listing = dir(patterns{i});
        matches = [matches; listing];
    end

    if isempty(matches)
        filePath = '';
        return;
    end

    % Prefer paths outside Release 1.0
    paths = arrayfun(@(d) fullfile(d.folder, d.name), matches, 'UniformOutput', false);
    keep = ~contains(paths, [filesep 'Release 1.0' filesep]);
    if any(keep)
        paths = paths(keep);
    end

    % Pick the shortest path as a heuristic
    [~, idx] = min(cellfun(@length, paths));
    filePath = paths{idx};
end

function signature = extractSignature(content, funcName)
    funcLine = regexp(content, '^\s*function\s+.*$', 'match', 'once', 'lineanchors');
    if isempty(funcLine)
        % Possibly a classdef
        signature = funcName;
        return;
    end
    signature = strtrim(regexprep(funcLine, '^\s*function\s+', ''));
    signature = regexprep(signature, '\s+', ' ');
    if isempty(signature)
        signature = [funcName '(...)'];
    end
end

function description = extractDescription(content)
    description = '';
    lines = regexp(content, '\r\n|\n|\r', 'split');

    startIdx = 1;
    for i = 1:numel(lines)
        line = strtrim(lines{i});
        if startsWith(line, 'function') || startsWith(line, 'classdef')
            startIdx = i + 1;
            break;
        end
    end

    inBlock = false;
    for i = startIdx:numel(lines)
        line = strtrim(lines{i});
        if startsWith(line, '%{')
            inBlock = true;
            continue;
        end
        if startsWith(line, '%}')
            inBlock = false;
            continue;
        end
        if inBlock
            continue;
        end
        if startsWith(line, '%')
            desc = regexprep(line, '^%+\s*', '');
            if ~isempty(desc)
                description = desc;
                return;
            end
        elseif ~isempty(line)
            break;
        end
    end
end
